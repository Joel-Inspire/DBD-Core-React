0010 REM "Expand XML File Data<EC3XPN>
0020 SETESC 9300; SETERR 9000
0035 REM "5.7 - 08/16/18 - 13.38 - crg - SSP# 302625
0037 REM "302625-Four51 XML orders are failing                               
0040 REM "Copyright 2018 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 ! XML_FILE -> Name of XML File
0051 ! RAW_XML -> Memory file containing raw XML text
0052 ! RAW_PATH -> Memory file, read with index
0053 ! OUTPUT -> Memory file, read with index
0054 ! ENTITY -> Memory file, key is last entity in path, values are separated with $FE$s
0055 ! OPTION$
0056 ! @ = use @ as attribute indicator
0090 CLEAR ; SETERR 0100; ENTER XML_FILE$,OPTION$,RAW_XML,RAW_PATH,OUTPUT,ENTITY
0100 SETERR 9000
0110 X0$="EC3XPN",X1$="Expand XML File Data"
0200 REM "
0240 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,-1,X1,X2
0500 ! Open files
0505 DIM Z[NUM(X3$(60,3))]
0510 Z$="02OSEDB...  13O ZZPARM  " ! use S to ensure we get iol= on open of EDB
0520 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; ON Z0 GOTO 0521,9900
0540 EDB_KEY_SIZE=99,EDB_KEY_SIZE=NUM(FIN(Z[2],"KEY_SIZE",ERR=*NEXT),ERR=*NEXT)
0600 ! Analyse options
0605 IF POS("@"=OPTION$) THEN ATTR_SEP$="@" ELSE ATTR_SEP$=""
0700 ! Initialize
0710 FIND$=$090A0D$,REPLACE$=DIM(3) ! SSP 235389
0800 ! verify file is there, open, load RAW_XML file and XML$
0805 IF MID(XML_FILE$,1,1)="~" THEN Z[1]=NUM(MID(XML_FILE$,2),ERR=9900) ELSE Z[1]=HFN; OPEN INPUT (Z[1],ISZ=8000,ERR=DONE)XML_FILE$
0810 RAW_XML=HFN; RAW_XML_INDEX=0; OPEN (RAW_XML,BSZ=8000)"*MEMORY*"
0815 SELECT XML_IN$ FROM Z[1]
0816 XML_IN$=SUB(XML_IN$,$00$,"") ! Remove nulls ($00$) in case it is in unicode
0820 WRITE RECORD (RAW_XML,IND=RAW_XML_INDEX++,ERR=*NEXT)XML_IN$ ! save in memory file
0825 XML$=XML$+SUB(SUB(SUB(XML_IN$,FIND$(1,1),REPLACE$(1,1)),FIND$(2,1),REPLACE$(2,1)),FIND$(3,1),REPLACE$(3,1)) ! change tabs and line endings to spaces, SSP 235389 - Replaced TBL() with SUB()
0830 NEXT RECORD 
0900 ! Open files
0910 RAW_PATH=HFN; RAW_PATH_INDEX=0; OPEN (RAW_PATH,BSZ=2048)"*memory*"
0920 OUTPUT=HFN; OUTPUT_INDEX=0; OPEN (OUTPUT)"*memory*"
0930 ENTITY=HFN; OPEN (ENTITY,BSZ=10000)"*memory*"
1000 ! Begin processing
1020 INDEX=1,PATH$=""
1025 GOSUB GET_ENTITY
1030 WHILE ENTITY$<>""
1035 PATH$=PATH$+"/"+ENTITY$
1040 T_INDEX=1; GOSUB GET_ATTRIBUTE
1045 WHILE ATTR$<>""
1050 AF_PATH$=PATH$+"/"+ATTR_SEP$+ATTR$,AF_VALUE$=ATTR_VALUE$; GOSUB ADD_TO_FILES
1055 GOSUB GET_ATTRIBUTE
1060 WEND 
1065 GOSUB GET_VALUE
1070 IF POS("/>"=TOKEN$)=0 THEN AF_PATH$=PATH$,AF_VALUE$=VALUE$; GOSUB ADD_TO_FILES ELSE AF_PATH$=STP(PATH$,1,"/"),AF_VALUE$=VALUE$; GOSUB ADD_TO_FILES; TP=POS("/"+ENTITY$=PATH$,-1); IF TP THEN PATH$=MID(PATH$,1,TP-1) ! Add path and value to file; If <entity /> remove from path
1085 GOSUB GET_ENTITY
1090 WEND 
1900 DONE:
1995 GOTO 9900
2000 GET_ENTITY:! ^100 xml$ is data, token$ is token, entity$ is entity contents
2005 REPEAT 
2010 M=MSK(XML$(INDEX),"<[^<|/][^<]*(>)|(/>)"),M_MSL=MSL,P=POS("</"=XML$(INDEX))
2015 IF P<M THEN {! is Pos of end token less than the pos of next starting entity?
2020 ! skip end token, and trim PATH$ back to matching entity
2025 PE=POS(">"=XML$(INDEX+P)); PP=POS("/"+MID(XML$,INDEX+P+1,PE-2)=PATH$,-1)
2030 IF PP<>0 THEN PATH$=MID(PATH$,1,PP-1)
2035 INDEX=INDEX+P+PE
2040  }
2045 UNTIL M<=P
2050 IF M=0 THEN {
2055 TOKEN$="",ENTITY$=""
2060  } ELSE {
2065 TOKEN$=FN_UNESCAPE$(XML$(INDEX+M-1,M_MSL)),INDEX=INDEX+M+M_MSL-1
2070 M=MSK(TOKEN$,"<[^ ]*[ >]") ! 302625
2075 IF M=0 THEN ENTITY$="" ELSE ENTITY$=MID(TOKEN$,M+1,MSL-2)
2080  }
2085 IF POS(MID(ENTITY$,1,1)="?!") THEN GOTO GET_ENTITY ! if entity name starts with ? OR ! then is meta data related (typ ?xml or !DOCTYPE entity) and we want to skip
2095 RETURN 
2099 ! ******************************************8
2100 GET_VALUE:! ^100 given current index determine if we have value or sub-entities
2105 VALUE$=""
2110 P1=POS("<"=XML$(INDEX)); P2=POS("</"=XML$(INDEX)); IF P1=P2 THEN VALUE$=FN_UNESCAPE$(XML$(INDEX,P1-1)); INDEX+=P2-1
2115 RETURN 
2120 ! ******************************
2200 GET_ATTRIBUTE:! ^100 given TOKEN$ get next attribute (ATTR$) and attribute value (ATTR_VALUE$) from token based on T_INDEX
2205 ATTR$="",ATTR_VALUE$=""
2210 TM=MSK(TOKEN$(T_INDEX),"[^ ]*="+QUO+"[^"+QUO+"]*"+QUO) ! non_spaces="not_quotes"
2215 IF TM<>0 THEN {
2220 ATTR_T$=TOKEN$(T_INDEX+TM-1,MSL),T_INDEX+=TM+MSL
2225 TP=POS("="=ATTR_T$)
2230 IF TP=0 THEN {
2235 ATTR$=ATTR_T$
2240  } ELSE {
2245 ATTR$=MID(ATTR_T$,1,TP-1),ATTR_VALUE$=STP(MID(ATTR_T$,TP+1),2,QUO)
2250  }
2255  }
2260 RETURN 
2265 ! **********************************************
7410 DEF FN_OUTPUT(LOCAL EVAL_MODE)
7420 IF EVAL_MODE=0 THEN {
7430 WRITE (OUTPUT,IND=OUTPUT_INDEX++)PFO_PATH$+"="+AF_VALUE$
7440  }; IF EVAL_MODE=1 THEN {
7450 WRITE (OUTPUT,IND=OUTPUT_INDEX++)PFO_PATH$+"="+EXPR_PROC'EVAL$(AF_VALUE$)
7460  }
7470 RETURN EVAL_MODE
7480 END DEF
7499 ! ****************************************
7500 DEF FN_UNESCAPE$(LOCAL IN$) ! Check for & and if present then do substitute, SSP167762. SSP249997 add &# translations.
7510 IF POS("&"=IN$)<>0 THEN {
7515 IN$=SUB(IN$,"&lt;","<")
7520 IN$=SUB(IN$,"&gt;",">")
7525 IN$=SUB(IN$,"&amp;","&")
7530 IN$=SUB(IN$,"&quot;",QUO)
7535 IN$=SUB(IN$,"&apos;","'") ! SSP247374
7540  }
7550 IF POS("&#"=IN$)<>0 THEN {
7555 IN$=SUB(IN$,"&#60;","<")
7560 IN$=SUB(IN$,"&#62;",">")
7565 IN$=SUB(IN$,"&#38;","&")
7570 IN$=SUB(IN$,"&#34;",QUO)
7575 IN$=SUB(IN$,"&#39;","'")
7580  }
7587 IF POS(", "=IN$)<>0 THEN IN$=SUB(IN$,", ",",")
7590 RETURN IN$
7595 END DEF
7599 ! ****************************************
7600 ADD_TO_FILES:! Given AF_PATH$ and AF_VALUE$ then add to RAW_PATH and ENTITY, process and if needed add to OUTPUT
7605 AF_PATH$=SUB(AF_PATH$,"Pricing/Pricing","Pricing")
7606 PATH_REPEAT=0; IF PREV_AF_PATH$=AF_PATH$ THEN COUNT_REPEAT=COUNT_REPEAT+1 ELSE PREV_AF_PATH$=AF_PATH$,COUNT_REPEAT=1 ! 233282
7609 WRITE_RAW_PATH:
7610 WRITE (RAW_PATH,IND=RAW_PATH_INDEX++)AF_PATH$,AF_VALUE$ ! RAW_PATH: AF_PATH$, AF_VALUE$
7615 IF NOT(NUL(AF_VALUE$)) THEN {! Add to entity search file
7620 TE=POS("/"=AF_PATH$,-1) ! find last "entity" on PATH
7625 IF TE<>0 THEN {
7630 ENTITY_KEY$=MID(AF_PATH$,TE+1)
7634 ! Each Entity Key will have a list of one or more values, separated by the $FE$ char, at the end: value1+$FE$+value2+$FE$+value3+$FE$ -> should allow reading directly into an array
7635 GOSUB READ_ENTITY ! READ (ENTITY,KEY=ENTITY_KEY$,DOM=*NEXT)ENTITY_KEY$,ENTITY_AF_VALUE$
7640 GOSUB WRITE_ENTITY ! WRITE (ENTITY,KEY=ENTITY_KEY$)ENTITY_KEY$,ENTITY_AF_VALUE$+AF_VALUE$+$FE$
7645  }
7675  }
7680 ! Run through EDB to get OUTPUT file
7685 GOSUB PROCESS_FOR_OUTPUT
7687 IF NOT(PATH_REPEAT) AND PREV_AF_PATH$<>AF_PATH$ THEN PATH_REPEAT=1; GOSUB WRITE_RAW_PATH ! 233282
7695 RETURN 
7699 ! **************************************************
7700 PROCESS_FOR_OUTPUT:! given AF_PATH$ and AF_VALUE$ process through EDB
7705 DIM EDB$:IOL(Z[2]); FIND (Z[2],KEY=PAD(AF_PATH$,EDB_KEY_SIZE),DOM=*RETURN)EDB$
7715 PFO_PATH$=AF_PATH$ ! We will use PFO_PATH$ in our processing
7720 IF EDB.FORWARD_ATTR$="Y" THEN PATH$=PATH$+"/"+AF_VALUE$ ! Add to the real path
7721 IF POS(EDB.FORWARD_VAL_YN$="YR")>0 THEN FORWARD_VAL$=AF_VALUE$; IF (SSN>"07" AND NOT(NUL(EDB.FORWARD_VAL_EXPR$))) THEN EXPR_PROC$=STP(EDB.FORWARD_VAL_EXPR$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN FORWARD_VAL$=EXPR_PROC'EVAL$(AF_VALUE$) END_IF ; END_IF ; IF NOT(NUL(FORWARD_VAL$)) THEN IF EDB.FORWARD_VAL_YN$="Y" THEN PATH$="/"+FORWARD_VAL$+PATH$ ELSE IF EDB.FORWARD_VAL_YN$="R" THEN PATH$="/"+FORWARD_VAL$ ! Add to the real path, SSP 238051-Ability to replace real path with expression
7725 IF NOT(NUL(EDB.REPLACE_LEFT$)) THEN PFO_PATH$=STP(EDB.REPLACE_LEFT$) ! If REPLACE_LEFT$ is set then use it in place of the path
7730 IF EDB.DROP_LINE$<>"Y" THEN IF (SSN>"07" AND NOT(NUL(EDB.RL_EXPR$))) THEN EXPR_PROC$=STP(EDB.RL_EXPR$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN MX=FN_OUTPUT(1) ELSE MX=FN_OUTPUT(0) END_IF ; ELSE MX=FN_OUTPUT(0)
7735 IF NOT(NUL(EDB.REPLACE_LEFT_2$)) THEN PFO_PATH$=STP(EDB.REPLACE_LEFT_2$) ELSE GOTO 7741 ! If REPLACE_LEFT_2$ is set then use it in place of the path
7740 IF EDB.DROP_LINE$<>"Y" THEN IF (SSN>"07" AND NOT(NUL(EDB.RL_EXPR_2$))) THEN EXPR_PROC$=STP(EDB.RL_EXPR_2$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN MX=FN_OUTPUT(1) ELSE MX=FN_OUTPUT(0) END_IF ; ELSE MX=FN_OUTPUT(0)
7745 IF NOT(NUL(EDB.REPLACE_LEFT_3$)) THEN PFO_PATH$=STP(EDB.REPLACE_LEFT_3$) ELSE GOTO 7751 ! If REPLACE_LEFT_3$ is set then use it in place of the path
7750 IF EDB.DROP_LINE$<>"Y" THEN IF (SSN>"07" AND NOT(NUL(EDB.RL_EXPR_3$))) THEN EXPR_PROC$=STP(EDB.RL_EXPR_3$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN MX=FN_OUTPUT(1) ELSE MX=FN_OUTPUT(0) END_IF ; ELSE MX=FN_OUTPUT(0)
7760 IF NOT(NUL(EDB.ADD_LINE_1$)) THEN IF (SSN>"07" AND EDB.ADDLINE_EXPR_YN$="Y") THEN EXPR_PROC$=STP(EDB.ADD_LINE_1$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN WRITE (OUTPUT,IND=OUTPUT_INDEX++)EXPR_PROC'EVAL$(AF_VALUE$) ELSE WRITE (OUTPUT,IND=OUTPUT_INDEX++)STP(EDB.ADD_LINE_1$) END_IF ; ELSE WRITE (OUTPUT,IND=OUTPUT_INDEX++)STP(EDB.ADD_LINE_1$)
7770 IF NOT(NUL(EDB.ADD_LINE_2$)) THEN IF (SSN>"07" AND EDB.ADDLINE_EXPR_YN_2$="Y") THEN EXPR_PROC$=STP(EDB.ADD_LINE_2$,2); GOSUB PARSE_EXPRESSION; IF EXPR_PROC THEN WRITE (OUTPUT,IND=OUTPUT_INDEX++)EXPR_PROC'EVAL$(AF_VALUE$) ELSE WRITE (OUTPUT,IND=OUTPUT_INDEX++)STP(EDB.ADD_LINE_2$) END_IF ; ELSE WRITE (OUTPUT,IND=OUTPUT_INDEX++)STP(EDB.ADD_LINE_2$)
7775 IF EDB.ENUM_REPEATS$="Y" THEN AF_PATH$=AF_PATH$+"."+STR(COUNT_REPEAT) ! 233282
7795 RETURN 
7799 ! ********************************************
7800 PARSE_EXPRESSION:
7805 IF SSN<"07" THEN GOTO *RETURN
7810 IF EXPR_PROC<>0 THEN DROP OBJECT EXPR_PROC; EXPR_PROC=0
7820 IF EXPR_PARSER=0 THEN EXPR_PARSER=NEW("ZZGPSR",ERR=*RETURN)
7830 IF EXPR_PARSER THEN EXPR_PROC=EXPR_PARSER'GETEXPR(EXPR_PROC$,ERR=*PROCEED)
7850 RETURN 
7860 ! ********************************************
7900 READ_ENTITY:
7905 ENTITY_AF_VALUE$="",SEQ_ENT=0
7915 SEQ_ENT+=1; READ (ENTITY,KEY=ENTITY_KEY$+STR(SEQ_ENT:"000"),DOM=DONE_READ_ENTITY)ENTITY_KEY$,SUB_ENTITY_AF_VALUE$
7920 ENTITY_AF_VALUE$+=SUB_ENTITY_AF_VALUE$
7930 GOTO 7915
7940 DONE_READ_ENTITY:
7945 RETURN 
7949 ! 
7950 WRITE_ENTITY:
7955 SEQ_ENT=0; REC_ENTITY_AF_VALUE$=ENTITY_AF_VALUE$+AF_VALUE$+$FE$
7960 IF LEN(ENTITY_KEY$+SEP+REC_ENTITY_AF_VALUE$+SEP)>10000 THEN SUB_ENTITY_AF_VALUE$=MID(REC_ENTITY_AF_VALUE$,1,(10000-LEN(ENTITY_KEY$+SEP+SEP))); REC_ENTITY_AF_VALUE$=MID(REC_ENTITY_AF_VALUE$,(10000-LEN(ENTITY_KEY$+SEP+SEP))) ELSE SUB_ENTITY_AF_VALUE$=REC_ENTITY_AF_VALUE$; REC_ENTITY_AF_VALUE$=""
7965 SEQ_ENT+=1; WRITE (ENTITY,KEY=ENTITY_KEY$+STR(SEQ_ENT:"000"))ENTITY_KEY$,SUB_ENTITY_AF_VALUE$
7970 IF NOT(NUL(REC_ENTITY_AF_VALUE$)) THEN GOTO 7960
7990 DONE_WRITE_ENTITY:
7995 RETURN 
7999 ! 
9000 REM "ERROR PROCESSING
9005 IF ERR=69 THEN GOTO 9500
9010 Y5=ERR,Y6=TCB(5)
9015 SETERR 9016; Y8$=LST(PGM(Y6))
9016 SETERR 9000
9040 CALL "ZZERRM",Y8$,X0$,Y7$,X3$,Y5,Y6,Y7,Y8,0
9045 REM 
9050 ON Y7 GOTO 9060,9100,9800,9070,9090
9055 REM 
9060 RETRY 
9070 SETERR 9080
9075 EXECUTE Y7$
9080 SETERR 9000; RETRY 
9090 SETERR 0000; RETRY 
9100 REM " TRANSFER CONTROL
9180 GOTO 1098
9190 GOTO 9800
9300 SETESC 9350
9310 SETERR 9350
9315 IF X3$(47,1)="N" THEN RETURN ELSE SETESC 0000; RETURN 
9350 SETERR 9000; RETURN 
9500 REM "CTRL LOGIC
9510 SETERR 9000; GOSUB 6400
9520 ON C9 GOTO 2113,2270
9900 REM "END PROGRAM
9910 CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
9930 SETERR 9940; Q1$=A1$; EXIT 
9940 SETESC 9350
9950 RUN "ZMENU"
9999 END 
56002 REM "201157-Create XML import for inventory file update
56004 REM "207266-Companion item message line feature being tested in DEV.
56006 REM "203699-Ability to apply expressions to XML data
56007 REM "233282-Modify XML mapping setup-Enumerate repeat instances     
56008 REM "235389-HRB cXML order not in DB/d, showing failed in Ariba.        
56009 REM "238051-EDB key is 99, add support for longer xml path mappings
56010 REM "239930-XML file parser hit an internal limit on entity size
56012 REM "247374-EC3XPN XML special characters, need to add apostrophe.      
56014 REM "249997-Flowpoint; Fortune3 not encoding 5 special chars. Now they  
56016 REM "302625-XML parsing affected by regular expression rules in PxPlus 2017
