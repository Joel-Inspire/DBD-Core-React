0010 ! TFUPDT - Update Physical Files from the Data Dictionary
0020 PRINT 'CS','BLUE',"Update Physical Data Files from Dictionary",'RM'
0035 REM "5.7 - 09/27/24 - 11.571837 - crg - SSP# 307505
0037 REM "307505-DBD-512: Ignore views during physical updates               
0040 REM "Copyright 2024 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0090 BEGIN 
0095 IF SSN<"102" THEN MSGBOX "This feature requires Providex version 10.2 or above"; GOTO PROC_EXIT
0100 CALL "ZZWMX3" ! Set Global Variables
0110 %DATA_DIR$=%DATAPATH$+DLM ! Set up the global path variable
0120 DIM ERROR$[100]; ERR_INDEX=0 ! setup for errors
0500 DDF_FN=HFN; OPEN (DDF_FN)"providex.ddf" ! Open DD header file
0510 ! DDE_FN=HFN; OPEN (DDE_FN)"providex.dde" ! Open DDE file
0550 GOSUB OPEN_DDE
0599 ! 
0950 NEXT_TABLE:INPUT 'LF','LF',"Single table to do, blank=all, END=exit: ",TNAME$; IF (UCS(TNAME$)="END" OR CTL=4) THEN GOTO UPDATE_COMPLETE
1000 IF NUL(TNAME$) THEN GOTO *NEXT ELSE READ (DDF_FN,KNO=1,KEY=TNAME$,DOM=NEXT_TABLE)DDF_KEY$; GOTO READ_DDF
1010 READ (DDF_FN,KEY="000000",KNO=0,DOM=*NEXT) ! Bypass Global Dictionary
1050 NEXT_DDF:
1060 DDF_KEY$=KEY(DDF_FN,KNO=0,END=UPDATE_COMPLETE)
1100 READ_DDF:READ (DDF_FN,KEY=DDF_KEY$)LOGNAME$,PATH$,*,*,*,*,*,*,*,*,DFSEP$ ! Next ddf record
1105 ! IF DDF_KEY$(1,6)="000681" THEN ESCAPE 
1110 IF POS(LOGNAME$(1,3)="AR7APJ",3)<>0 THEN KEY_OK=1; GOSUB CHECK_FILE_TYPE; IF NOT(KEY_OK) THEN GOTO NEXT_DDF; REM "SSP#202622
1120 IF POS("VIEW:"=UCS(LOGNAME$))<>0 OR MID(UCS(LOGNAME$),1,3)="VW_" THEN GOTO NEXT_DDF ! ssp#217742,307505
1130 IF STP(PATH$)="" THEN PRINT 'SB','MAGENTA',"Warning: "+DDF_KEY$+" - "+LOGNAME$+" has no path.  Cannot create.",'RM'; GOTO NEXT_DDF ! Check for incomplete record
1140 IF POS("z.csi"=PATH$) AND %C$<>"500" THEN GOTO NEXT_DDF ! 172677 - if z.csi in path and company not 500 then skip it
1150 GOSUB CHECK_DATA_REP
1160 PRINT "Creating ",DDF_KEY$," - "+LOGNAME$,@(50)," >> ",PATH$
1165 D_FLAG$="D" ! Update dictionary only
1170 CALL "*dict/dd_updt;Update_Physical",LOGNAME$,"",D_FLAG$,ERRMSG$
1180 IF STP(ERRMSG$,2)<>"" THEN PRINT 'RED',ERRMSG$,'RM'; ERR_INDEX+=1; IF ERR_INDEX>DIM(READ MAX(ERROR$)) THEN TOO_MANY_ERRORS=1; GOTO UPDATE_COMPLETE ELSE ERROR$[ERR_INDEX]=ERRMSG$
1200 GOSUB CHECK_INDEXES
1990 IF NUL(TNAME$) THEN GOTO NEXT_DDF ELSE GOTO NEXT_TABLE
1999 ! 
2000 UPDATE_COMPLETE:
2010 CLOSE (DDF_FN)
2015 CLOSE (DDE_FN)
2020 PRINT "File update complete"
2030 IF ERR_INDEX THEN {
2040 PRINT 'RED',"There were "+STR(ERR_INDEX)+" errors found!",'RM'
2050 IF TOO_MANY_ERRORS THEN PRINT 'RED',"Update stopped, too many errors found!"
2060 PRINT "Press any key to see the errors",; INPUT *; PRINT 'CS',
2070 FOR I=1 TO ERR_INDEX
2080 IF MOD(I,9)=0 THEN PRINT "Press any key to continue..",; INPUT *
2090 PRINT ERROR$[I]
2100 NEXT I
2110  }
9000 PROC_EXIT:
9999 END 
10000 CHECK_FILE_TYPE:; REM "SSP#202662
10100 FILE_NM$=LOGNAME$(1,3)+%C$
10200 CALL "ZZINFO",FILE_ID,STATUS,%X3$,REC_USED,TOT_REC,KEY_SZ,BYTE,DISC,TYPE,TOT_SEC,FILE_NM$
10300 IF KEY_SZ=0 THEN KEY_OK=0
10390 RETURN 
10399 ! 
10400 IOLIST NAME$,PATH$,LST_UPD$,FILE_PROC$,OWNER$,LST_PHYS_UPD$,DESC$,GROUP$,EXTENSION$,ALTIOLIST$,SEP$,FILE_SEC$,FILE_NOTES$,OPTIONS$,VERSION$,BLOCKSIZE$,FILEFLAGS$
10500 CHECK_DATA_REP:! 167070 see if logname is in data replication, if so we need to update the real data dictionary because we may have gotten a new one from a release 
10502 IF MID(DDF_KEY$,1,3)=LOGNAME$ THEN LOGNAME$=DDF_KEY$
10505 HOLD_PROC$=""; REM "SSP 188227
10510 DR_NAME$=MID(LOGNAME$,1,3)+%C$
10520 DR1=HFN; OPEN (DR1,ERR=END_OF_CHECK)"DR1"+%C$
10521 READ (DR1,KEY=PAD(DR_NAME$,8,1),DOM=*NEXT)
10523 DR1_KEY$=KEY(DR1,END=END_OF_CHECK); READ (DR1,KEY=DR1_KEY$,DOM=END_OF_CHECK)DR1$
10524 IF MID(DR1_KEY$,1,6)<>DR_NAME$ THEN GOTO END_OF_CHECK
10530 IF MID(DR1$,301,1)<>"Y" THEN GOTO 10523; REM SSP 188227
10535 DR0=HFN; OPEN (DR0,ERR=END_OF_CHECK)"DR0"+%C$
10540 FIND (DR0,KEY=MID(DR1$,41,20),ERR=END_OF_CHECK)DR0$
10545 IO$=MID(DR0$,171,10); IF NUL(IO$) THEN GOTO END_OF_CHECK
10546 HOLD_PROC$="!"+IO$
10547 END_OF_CHECK:
10550 EXTRACT (DDF_FN,KEY=LOGNAME$,KNO=1,ERR=10590,REC=D$)IOL=10400
10555 D.FILE_PROC$=HOLD_PROC$
10560 REM "D.FILE_PROC$="!"+IO$
10565 WRITE (DDF_FN,REC=D$)IOL=10400
10590 CLOSE (DR1,ERR=*NEXT); CLOSE (DR0,ERR=*NEXT)
10595 RETURN 
10599 ! 
11000 CHECK_INDEXES:
11030 IF POS("="=PATH$)<>1 THEN FPATH$=PATH$ ELSE FPATH$=EVS(PATH$(2),ERR=*RETURN)
11100 KX=HFN; OPEN (KX,ERR=*RETURN)FPATH$; FPATH$=PTH(KX)
11110 READ (KX,END=*NEXT)*; GOTO CHK_PHY_KEYS
11120 CLOSE (KX); RETURN 
11125 ! 
11150 CHK_PHY_KEYS:
11160 DDF.KEY$=KEC(DDF_FN,KNO=0)
11165 DDF.SEP$=DFSEP$
11200 CALL "*dict/keys;Get_key_str",DDE_FN,DDF.KEY$,NEW_KDEF$,NEW_IOL$,NEW_RSZ,EXKEY,ERROR$
11220 CALL "*dict/maint;Get_Keydsc",KX,OLD_KDEF$,OLD_KIOL$; CLOSE (KX)
11240 IF OLD_KDEF$=NEW_KDEF$ THEN RETURN 
11290 ! 
11300 FIX_INDEXES:! Drop and add indexes as needed assumes check for OLD_KDEF$ equal to NEW_KDEF$ has been done. We will make the file have the same indexes as NEW_KDEF$ by dropping and adding indexes as needed to insure the same indexes in the same order.
11305 PRINT 'WINDOW'(1,15,78,7,"Updating: "+FILEPATH$),'CS',
11310 ! Compare get each index off the list, if the indexes are different, then drop the old index, and add the new. When OLD_KDEF is exhausted then we will just be adding new ones.
11315 OLD_DEF$=OLD_KDEF$+",",NEW_DEF$=NEW_KDEF$+",",KNO_NUMBER=-1 ! 263584
11320 WHILE NOT(NUL(NEW_DEF$))
11330 NEW_IND$=FN%NEXT_FROM_LIST$(NEW_DEF$,","),NEW_DEF$=MID(NEW_DEF$,LEN(NEW_IND$)+2)
11335 NEXT_OLD_KDEF:
11340 OLD_IND$=FN%NEXT_FROM_LIST$(OLD_DEF$,","),OLD_DEF$=MID(OLD_DEF$,LEN(OLD_IND$)+2)
11350 KNO_NUMBER+=1
11360 IF OLD_IND$<>NEW_IND$ AND KNO_NUMBER>0 THEN {
11370 ! If there is an old index that doesn't match then drop it
11380 IF NOT(NUL(OLD_IND$)) THEN PRINT @(0,0),'CS',"Dropping Index # "+STR(KNO_NUMBER); EXECUTE "DROP INDEX "+STR(KNO_NUMBER)+" FROM FPATH$",ERR=*NEXT; GOTO NEXT_OLD_KDEF
11395 ! Now add the new index
11400 PRINT @(0,0),'CS',"Adding index: ",NEW_IND$
11410 EXECUTE "add index "+NEW_IND$+" to fpath$",ERR=*NEXT
11420  }
11430 WEND 
11440 PRINT 'WR',
11450 RETURN 
11499 ! 
11900 RETURN 
11999 ! 
12000 OPEN_DDE:
12010 DDEIOL:IOLIST IOLOBJ$,NAME$,DESC$,TYPE$,LEN$,OCC$,FORMAT$,VALID$,PRINT$,HELP$,NOTES$,KEYDEF$,QUERY$,CLASS$,FLAGS$,DFLT$,ALT_NAME$,USER_TAG$,ELEM_SEC$,ELEM_EXT$,ORIGINATOR$
12020 DDE_FN=0
12040 X=HFN; OPEN (X,IOL=12010,REC=DDE$,ERR=NO_DDE)%Z__PVXDDF$+"providex.dde"; DDE_FN=X
12050 RETURN 
12060 NO_DDE: ERRMSG$=E$+"Unable to access Data element dictionary <providex.dde>"+SEP+"err: "+MSG(RET); EXITTO PROC_EXIT
