0010 ! FUNCTIONS PROGRAM <ZZ2FNC>
0020 ! "CREATED 6/14/01 PLH
0030 ! "MODIFIED FOR TSK 8/20/01 PLH
0035 REM "5.7 - 03/02/18 - 9.283055 - crg - SSP# 000001
0037 REM "000001-Linux user ID used exclusively to identify DB/d operator
0040 REM "Copyright 2018 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 ! 
0060 ! " Internal labels are prefixed with z to show last in editor goto window. 
0070 ! 
0100 ! ^100 Copyright 2001 TopForm Software, Inc.; Norcross Georgia
0110 ! GET_PRG_REMARK       ! PARAMETERS 1: STRING-PROGRAM NAME, 2: STRING-PROGRAM LINE
0120 ! GET_PRG_CALL_STACK   ! PARAMETERS 1: STRING-PROGRAM NAME, 2: INTEGER-PRGLEVEL
0130 ! IS_PROTECTED         ! PARAMETERS 1: INT-OPEN FILE HANDLE, 2: BOOLEAN-RET_CDE
0140 ! IS_A_PROGRAM         ! PARAMETERS 1: INT-OPEN FILE HANDLE, 2: BOOLEAN-RET_CDE
0150 ! LIST_PRG             ! PARAMETERS 1: STRING-PROGRAM NAME, 2: STRING-TEXT FILE
0160 ! NEXT_DELIMITED_VALUE ! PARAMETERS 1: STRING-VALUE VAR, 2: STRING-DELIMITED LIST 3: STRING-DELIMITING CHAR
0170 ! CHECK_LINK_NAME      ! PARAMETERS 1: STRING-VALUE LINK FILE NAME 2: INTEGER BOOLEAN FLAG
0180 ! GET_STACK_PRG_NAME   ! PARMETERS  1: INT-STACK LEVEL 2: STRING-PRG NAME
0190 ! GETSERVERNETBIOSNAME ! PARAMETERS 1: STRING-VALUE SERVER NAME
0200 ! MAKEDIR              ! PARAMETERS 1: STRING-VALUE FULLPATHNAME
0210 ! GETFILEDATE          ! PARAMETERS 1: STRING-PRG & PATH 2: STRING-FLAG (acm) 3: STRING-MASK
0220 ! TOGGLEFLAG           ! PARAMETERS 1: STRING-FLAG VAR 2: STRING-FLAG CHAR 3: INTEGER 0-OFF, >1,ON, 4: INT-LENGTH
0230 ! GETUSERNAME          ! PARAMETERS 1: STRING - USERNAME$
0240 ! OPENSORTUSERFILE     ! PARAMETERS 1: STRING - FILEROOT$, 2: INTEGER FILE HANDLE, 3: STRING [OPT] USERNAME$
0250 ! SPLIT                ! PARAMETERS ARG1-4 CAN BE -B(BYTES) OR -L(LINES) FOLLOWED BY A NUMBER,rest are file name and new name
0260 ! SENDMAIL             ! PARAMETERS 1: STRING ARG1$, 2) STRING  ARG2$
0270 ! ROOTDRIVE            ! PARAMETERS 1: STRING ROOT$
0280 ! SERIALRECCNT  ! PARAMETERS 1) INTEGER _HANDLE, 2) INTEGERLCNT
0283 ! START_TRACE          ! PARAMETERS 1: INT-OPEN FILE HANDLE, 2:STRING-PROGRAM NAME, 3: STRING-USERNAME
0300 ! 
1000 ! ^ 1000 FIRST LINE OF CODE IN PROGRAM
1010 ! PARAMETERS 1: STRING PROGRAM NAME, 2: STRING PROGRAM LINE
1020 GET_PRG_REMARK:
1030 SETERR 1350
1040 ENTER PRG$,PRG_LINE$
1050 LOCAL CH1,BRESULT
1060 CH1=UNT
1070 OPEN (CH1,ERR=*NEXT)PRG$; GOTO 1135
1080 PRG_LINE$="** Unable to list first line **"
1090 GOTO ZGET_PRG_REMARK_EXIT
1100 CALL PGN+";IS_A_PROGRAM",CH1,BRESULT
1110 IF BRESULT<>1 THEN PRG_LINE$="** Not a program **"; GOTO ZGET_PRG_REMARK_EXIT
1120 CALL PGN+";IS_PROTECTED",CH1,BRESULT
1130 IF BRESULT<>1 THEN PRG_LINE$="** Protected Program **"; GOTO ZGET_PRG_REMARK_EXIT
1140 CLOSE (CH1,ERR=*NEXT)
1150 P$=PGN
1160 NX_LINE$=LST(PGM(TCB(4)+30))
1170 EXECUTE NX_LINE$(5),ERR=1260
1180 GOTO 1200
1190 LOAD PRG$; PRG_LINE$=LST(PGM(1)); LOAD P$; GOTO 1200
1200 IF PRG_LINE$="" THEN GOTO ZGET_PRG_REMARK_EXIT
1210 IF MID(PRG_LINE$,5)<>" " THEN {
1220 PRG_LINE$=MID(PRG_LINE$,6)
1230  } ELSE {
1240 PRG_LINE$=MID(PRG_LINE$,5)
1250  }
1260 P=POS("REM "=PRG_LINE$)
1270 IF P=0 THEN {
1280 P=POS("!"=PRG_LINE$)
1290 IF P<>0 THEN P=P+2
1300  } ELSE {
1310 P=P+5
1320  }
1330 IF P=0 THEN P=1
1340 PRG_LINE$=MID(PRG_LINE$,P)
1350 ZGET_PRG_REMARK_EXIT:
1360 CLOSE (CH1,ERR=*NEXT)
1370 EXIT 
1400 ! ^ 100 RETURNS HIGHEST CALL STACK FOR OPEN PROGRAM OR ZERO IF NOT OPEN
1410 ! PARAMETERS 1: STRING PROGRAM NAME, 2: INTEGER PRGLEVEL
1420 GET_PRG_CALL_STACK:
1430 ENTER F0$,PRGLEVEL
1440 LOCAL LEVEL,STKLEVEL
1450 LOCAL WHERE$,PROG$
1460 PRGLEVEL=0
1470 LEVEL=TCB(12,ERR=*NEXT)
1480 FOR STKLEVEL=LEVEL-1 TO 1 STEP -1
1490 WHERE$=UCS(STK(STKLEVEL))
1500 PROG$=MID(WHERE$,POS(DLM=WHERE$,-1)+1)
1510 IF CVS(PROG$,7)=CVS(F0$,7) THEN {
1520 PRGLEVEL=STKLEVEL
1530 EXITTO ZGET_PRG_CALL_STACK_EXIT
1540  }
1550 NEXT 
1560 ZGET_PRG_CALL_STACK_EXIT:
1570 EXIT 
1600 ! ^ 100 BOOLEAN TEST FOR OPEN PROGRAM IS PASSWORD PROTECTED
1610 ! PARAMETERS 1: OPEN FILE HANDLE, 2: BOOLEAN RET_CDE
1620 IS_PROTECTED:
1630 ENTER FHND,RET_CDE
1640 LOCAL HEADER$,PSWITCH$,PAND$
1650 RET_CDE=0
1660 READ RECORD (FHND,SIZ=256,IND=0)HEADER$
1670 PSWITCH$=HEADER$(90,1)
1680 PAND$=AND(PSWITCH$,$01$)
1690 IF PAND$=$01$ THEN RET_CDE=1
1700 EXIT 
1800 ! ^ 100  BOOLEAN TEST OF OPEN FILE FOR PROGRAM
1810 ! PARAMETERS 1: OPEN FILE HANDLE, 2: BOOLEAN RET_CDE
1820 IS_A_PROGRAM:
1830 ENTER FHND,RET_CDE
1840 LOCAL F$
1850 RET_CDE=0
1860 IF FHND=0 THEN GOTO ZIS_A_PROGRAM_EXIT
1870 F$=FID(FHND,ERR=*NEXT)
1880 IF MID(F$,10,1)=$04$ THEN RET_CDE=1
1890 ZIS_A_PROGRAM_EXIT:
1900 EXIT 
2000 ! ^ 100
2010 LIST_PRG:
2020 ENTER PRG$,WRKFLE$
2030 ERASE WRKFLE$,ERR=*NEXT; GOTO *SAME
2040 SERIAL WRKFLE$
2050 CALL "*pg.cnv",ERR=*NEXT,PRG$,WRKFLE$; GOTO ZLIST_PRG_EXIT
2060 WRKFLE$=""
2070 ZLIST_PRG_EXIT:
2080 EXIT 
2100 ! ^ 100
2110 NEXT_DELIMITED_VALUE:
2120 ENTER F$,FLIST$,CHAR$
2130 LOCAL P; F$=""
2140 IF POS(" "<FLIST$)=0 THEN GOTO 2230
2150 P=POS(CHAR$=FLIST$)
2160 IF P=1 THEN {
2170 FLIST$=MID(FLIST$,2)
2180 GOTO 2140
2190  }
2200 IF P>1 THEN {
2210 F$=MID(FLIST$,1,P-1)
2220 FLIST$=MID(FLIST$,P+1)
2230 ! 
2240 EXIT 
2250 ! 
2300 ! ^ 100,5 Test if file exists and if so is a link file
2305 CHECK_LINK_NAME:
2310 ENTER LNKNAME$,IS_LNK
2315 LOCAL LNK_FLE,MSG$,LNK_REC$
2320 LNK_FLE=HFN; OPEN (LNK_FLE,ISZ=256,ERR=ZNOLINK,BSY=ZLOCK_COLLISION)LNKNAME$
2325 READ RECORD (LNK_FLE,IND=0,ERR=ZBADLINK)LNK_REC$
2330 IF LEN(LNK_REC$)<>256 THEN GOTO ZBADLINK
2335 IF POS(LNK_REC$(1,1)+LNK_REC$(5,4)="[lnk]"+"[dev]"+"[apr]",5)=0 THEN GOTO ZBADLINK
2340 CLOSE (LNK_FLE); IS_LNK=1
2345 GOTO ZCHECK_LINK_NAME_CLEANUP
2350 ! 
2355 ZNOLINK:
2360 IF ERR=12 THEN IS_LNK=-1 ELSE IS_LNK=0
2365 GOTO ZCHECK_LINK_NAME_CLEANUP
2370 ! 
2375 ZLOCK_COLLISION:
2380 IS_LNK=-1
2385 GOTO ZCHECK_LINK_NAME_CLEANUP
2390 ! 
2395 ZBADLINK:
2400 IS_LNK=0
2405 ! 
2410 ZCHECK_LINK_NAME_CLEANUP:
2415 CLOSE (LNK_FLE,ERR=*NEXT)
2420 EXIT 
2540 ! 
2550 EXIT 
2560 EXIT 
2570 ! GET STACK_PRG_NAME$
2580 GET_STACK_PRG_NAME:
2590 ENTER STKLEVEL,PROG$
2600 LOCAL WHERE$,P
2610 WHERE$=STK(STKLEVEL)
2620 FULLPATH$=MID(WHERE$,POS(DLM=WHERE$)+1)
2630 P=POS(HWD=FULLPATH$,-1)
2640 RELPATH$=MID(FULLPATH$,P+LEN(HWD)+1)
2650 P1=POS("LIB"=UCS(RELPATH$),-1)
2660 IF P1>0 THEN {
2670 PROG$=RELPATH$
2680  } ELSE {
2690 PROG$=MID(WHERE$,POS(DLM=WHERE$,-1)+1)
2700  }
2710 EXIT 
2720 ! !^100
2730 ! Returns character separated full file names
2740 TFND_FILES:
2750 ENTER DIRPATH$,FILE_NAME$,SEP_CHAR$,EXACT_CASE_YN$,SUB_DIR_YN$
2760 LOCAL FILES_FOUND$,FILES_LIST$,CMD_LINE$,TF$,FILTER$,DIR_FILTER$
2770 LOCAL CAP_CASE,SUB_CASE,CH1,OLDPARAM
2780 IF DIRPATH$="" THEN EXIT 
2790 IF SEP_CHAR$="" THEN SEP_CHAR$="|"
2800 IF POS("Yy":EXACT_CASE_YN$)>0 THEN CAP_CASE=1 ELSE CAP_CASE=0
2810 IF POS("Yy":SUB_DIR_YN$)>0 THEN SUB_CASE=1 ELSE SUB_CASE=0
2820 CH1=UNT
2830 IF SUB_CASE THEN {
2840 OLDPARAM=PRM('SD')
2850 SET_PARAM 'SD'=1
2860 DIR_FILTER$=QUO+"*"+DLM+QUO
2870  }
2880 IF SUB_CASE=0 AND FILE_NAME$="" OR SUB_CASE=0 AND FILE_NAME$="*" THEN {
2890 FILTER$=""
2900  } ELSE {
2910 IF CAP_CASE=1 THEN {
2920 FILTER$=" WHERE FILES_FOUND$ LIKE FILE_NAME$"
2930  } ELSE {
2940 FILTER$=" WHERE UCS(FILES_FOUND$) LIKE UCS(FILE_NAME$)"
2950  }
2960 IF SUB_CASE=1 THEN FILTER$+=" OR "+DIR_FILTER$
2970  }
2980 CMD_LINE$+="SELECT FILES_FOUND$ FROM DIRPATH$"+FILTER$
2990 ! CMD_LINE$+="; IF FILES_FOUND$<>"+QUO+"."+QUO+" AND FILES_FOUND$<>"+QUO+".."+QUO+" THEN{"
3000 ! SUB DIRECTORY code calls this function recursively
3010 ! IF SUB_CASE=1 THEN CMD_LINE$+=" OPEN(CH1)DIRPATH$+DLM+FILES_FOUND$"
3020 ! IF SUB_CASE=1 THEN CMD_LINE$+="; TF$ = FID(CH1);CLOSE(CH1);IF TF$(10,1)=$0D$ THEN {"
3030 ! IF SUB_CASE=1 THEN CMD_LINE$+=" FILES_LIST$+=FN%find_FILES$(DIRPATH$+DLM+FILES_FOUND$,FILE_NAME$,SEP_CHAR$,EXACT_CASE_YN$,SUB_DIR_YN$)"
3040 ! IF SUB_CASE=1 THEN CMD_LINE$+=" }ELSE{"
3050 CMD_LINE$+="; FILES_LIST$+=DIRPATH$+DLM+FILES_FOUND$+SEP_CHAR$"
3060 ! IF SUB_CASE=1 THEN CMD_LINE$+="}"
3070 CMD_LINE$+="; NEXT RECORD"
3080 CMD_LINE$=STR(TCB(4)+30)+CMD_LINE$
3090 PRINT CMD_LINE$ ! DEBUG.PRINT
3100 ESCAPE 
3110 EXECUTE CMD_LINE$
3120 ! Execute line goes here, be careful renumbering!
3130 RETURN FILES_LIST$
3140 END DEF
3150 ! 
3160 GETSERVERNETBIOSNAME:
3170 ENTER SERVER$
3180 ! IF WINDOWS AND NOT WINDX THEN NO SERVER NAME SHOULD BE RETURNED, JUST EXIT
3190 IF TCB(82)>0 AND TCB(88)=0 THEN SERVER$=""; EXIT 
3200 LOCAL _SRV,P
3210 _SRV=HFN
3220 OPEN (_SRV)"[tcp];0"
3230 HOSTPORTSERVR$=KEF(_SRV)
3240 CLOSE (_SRV)
3250 WHERE=POS(";"=HOSTPORTSERVR$,-1,1)+1
3260 SERVER$=MID(HOSTPORTSERVR$,WHERE)
3270 P=POS("."=SERVER$)
3280 IF P>0 THEN SERVER$=MID(SERVER$,1,P-1)
3290 EXIT 
3300 ! 
3310 MAKEDIR:
3320 ENTER FULLPATHNAME$
3330 LOCAL X,N,CNT,_DIR
3340 LOCAL BKSL$,DPATH$
3350 IF FULLPATHNAME$="" THEN EXIT 
3360 ! USE WORK VAR TO PREVENT CHANGES TO PASSED VAR
3370 DPATH$=FULLPATHNAME$
3380 CNT=POS("/\":DPATH$,1,0)
3390 IF CNT=0 THEN EXIT 
3400 BKSL$=MID(DPATH$,POS("/\":DPATH$),1)
3410 ! 
3420 _DIR=UNT
3430 OPEN (_DIR,ERR=*NEXT)DPATH$; CLOSE (_DIR); EXIT 
3440 DIM DIRS$[CNT]
3450 ! 
3460 FOR X=CNT TO 1 STEP -1
3470 DLMPOS=POS("/\":DPATH$,1,X)
3480 DIRS$[X]=MID(DPATH$,DLMPOS+1)
3490 DPATH$=MID(DPATH$,1,DLMPOS-1)
3500 OPEN (_DIR,ERR=*NEXT)DPATH$; CLOSE (_DIR); EXITTO 3520
3510 NEXT X
3520 ! 
3530 FOR N=X TO CNT
3540 DPATH$+=BKSL$+DIRS$[N]
3550 DIRECTORY DPATH$
3560 NEXT N
3570 EXIT 
3580 ! 
3590 GETFILEDATE:
3600 ENTER AFULLNAME$,WHICH$,DATE_MASK$,ERR=*NEXT; GOTO 3630
3610 ENTER AFULLNAME$
3620 WHICH$=""; DATE_MASK$=""
3630 LOCAL _DIR,W,P,DATE$; P=PRC; PRECISION 8
3640 SWITCH LCS(WHICH$)
3650 CASE "c"; W=13; BREAK ! Creation Date
3660 CASE "a"; W=9; BREAK ! Accessed Date
3670 DEFAULT ; W=5; BREAK ! Modified Date AND default
3680 END SWITCH 
3690 _DIR=UNT
3700 OPEN (_DIR,ERR=3705,ISZ=1)AFULLNAME$
3710 DATE$=DTE(JUL(1970,1,1)+DEC($00$+MID(FIN(_DIR),W,4))/(86400),*:DATE_MASK$)
3720 CLOSE (_DIR)
3730 PRECISION P; RETURN DATE$
3740 EXIT 
3750 ! 
3760 TOGGLEFLAG:
3770 ENTER FVAR$,FLG$,ON,MAX
3780 LOCAL S
3790 S=POS(FLG$=FVAR$)
3800 IF S=0 AND ON=1 AND POS(" "=FVAR$)=0 AND LEN(FVAR$)<MAX THEN FVAR$=PAD(FVAR$,MAX,1," ")
3810 IF ON THEN {
3820 IF S=0 THEN FVAR$=SUB(FVAR$," ",FLG$,1)
3830  } ELSE {
3840 IF S>0 THEN FVAR$=SUB(FVAR$,FLG$," ",1)
3850  }
3860 EXIT 
3870 ! 
3880 GETUSERNAME:
3890 ENTER UNAME$
3900 ! IF TCB(88) THEN {
3910 ! CALL "[WDX]*WINDX.UTL;GET_VAL","WHO",UNAME$
3920 ! } ELSE {
3930 UNAME$=WHO
3940 ! } ! ENDIF WINDX
3950 EXIT 
3960 ! 
3970 OPENSORTUSERFILE:
3980 ENTER FILEROOT$,_HANDLE,USERNAME$
3990 IF USERNAME$="" THEN CALL PGN+";GETUSERNAME",USERNAME$
4000 _HANDLE=99; OPEN (_HANDLE,ERR=*NEXT)FILEROOT$+%C$+USERNAME$; GOTO 4080 ! TM Profile Sort
4010 IF ERR=12 THEN {
4020 SORT FILEROOT$+%C$+USERNAME$,35,0
4030 RETRY 
4040  } ELSE {
4045 IF ERR=14 THEN {
4046 GOTO 4080
4047  } ELSE {
4050 MSGBOX "Unable to open or create sort file ZPC"+%C$+" due to an error "+STR(ERR)+". Cannot process this routine.","Attention","info"
4060 _HANDLE=0
4070  }
4080 EXIT 
4090 ! 
4100 SPLIT:
4110 ! ARG1-4 CAN BE -B(BYTES) OR -L(LINES) FOLLOWED BY A NUMBER,rest are file name and new name
4120 LOCAL ARGCNT,SIZE,ISLINES,SUFFIX_LEN,ISUNIX,FILESIZE,RECCNT,FCNT
4130 LOCAL X,_FN,_O,_N,TMP,LAST
4140 LOCAL FILENAME$,NEWFILE$,SUFFIX$,ARG$,FLIST$,MASK$
4150 ! 
4160 ENTER ARG1$,ARG2$,ARG3$,ARG4$,ARG5$,ARG6$,ERR=*NEXT
4170 IF POS("IX"=UCS(SYS)) THEN ISUNIX=1 ELSE ISUNIX=0
4180 ! 
4190 FOR X=1 TO 6
4200 ARG$=EVS("ARG"+STR(X)+"$",ERR=*CONTINUE)
4210 IF ARG$="" THEN EXITTO 4400
4220 IF LEN(ARG$)=2 AND UCS(ARG$)="-L" THEN ISLINES=1,SIZE=NUM(EVS("ARG"+STR(X+1)+"$",ERR=*PROCEED),ERR=*NEXT),X=X+1; CONTINUE ELSE GOTO 4240
4230 IF SIZE=0 THEN SIZE=1000; CONTINUE
4240 IF LEN(ARG$)>2 AND UCS(MID(ARG$,1,2))="-L" THEN ISLINES=1,SIZE=NUM(MID(ARG$,3),ERR=*NEXT); CONTINUE ELSE GOTO 4260
4250 IF SIZE=0 THEN SIZE=1000; CONTINUE
4260 ! 
4270 IF LEN(ARG$)=2 AND UCS(ARG$)="-A" THEN SUFFIX_LEN=NUM(EVS("ARG"+STR(X+1)+"$",ERR=*PROCEED),ERR=*NEXT),X=X+1; CONTINUE ELSE GOTO 4290
4280 IF SUFFIX_LEN=0 THEN SUFFIX_LEN=1; CONTINUE
4290 IF LEN(ARG$)>2 AND UCS(MID(ARG$,1,2))="-A" THEN SUFFIX_LEN=NUM(MID(ARG$,3),ERR=*NEXT); CONTINUE ELSE GOTO 4310
4300 IF SUFFIX_LEN=0 THEN SUFFIX_LEN=1; CONTINUE
4310 ! 
4320 IF LEN(ARG$)=2 AND UCS(ARG$)="-B" THEN ISLINES=0,SIZE=NUM(EVS("ARG"+STR(X+1)+"$",ERR=*PROCEED),ERR=*NEXT),X=X+1; CONTINUE ELSE GOTO 4335
4330 IF SIZE=0 THEN EXIT 
4340 IF LEN(ARG$)>2 AND UCS(MID(ARG$,1,2))="-B" THEN ISLINES=0,SIZE=NUM(MID(ARG$,3),ERR=*NEXT); CONTINUE ELSE GOTO 4370
4350 IF SIZE=0 THEN EXIT 
4360 ! 
4370 IF ARG$<>"" AND FILENAME$="" THEN FILENAME$=ARG$; CONTINUE
4380 IF ARG$<>"" AND NEWFILE$="" THEN NEWFILE$=ARG$
4390 NEXT X
4400 ! 
4410 _FN=UNT
4420 OPEN (_FN,ERR=*NEXT)FILENAME$; GOTO 4440
4430 EXIT 
4440 ! 
4450 ! determine number of new files and suffix range
4460 IF ISLINES THEN {
4470 CALL PGN+";SERIALRECCNT",_FN,RECCNT
4560 IF RECCNT>SIZE THEN FCNT=RECCNT/SIZE ELSE FCNT=1
4570 ! 
4580  } ELSE {! IS BYTE
4590 FILESIZE=DEC(MID(FIN(_FN),1,4),ERR=*NEXT)
4600 IF SIZE<>0 AND FILESIZE>SIZE THEN FCNT=FILESIZE/SIZE
4610  }
4620 IF FPT(FCNT)>0 THEN FCNT=INT(FCNT+1)
4621 ! 
4630 ! determine path
4640 FPATH$=PTH(_FN)
4650 FPATH$=FNGET_PARSED_PATH$(FPATH$)
4660 CLOSE (_FN)
4670 ! 
4680 IF FPT(FCNT)>0 THEN FCNT+=1
4690 FCNT=INT(FCNT)
4700 IF SUFFIX_LEN=0 THEN SUFFIX_LEN=2
4710 IF FCNT>26^SUFFIX_LEN THEN MSGBOX "Too many files for suffix length specified","Error"; EXIT 
4720 ! 
4730 FOR X=1 TO SUFFIX_LEN
4740 TMP=FCNT|26^X
4750 IF TMP>26 THEN LAST=INT(TMP/26); IF LAST>26 THEN LAST=26
4760 IF FCNT/26^X>1 THEN MASK$="[a-z]"+MASK$; IF TMP<=26 THEN MASK$="[a]"+MASK$; X=X+1; CONTINUE ELSE MASK$="[a-"+CHR(LAST)+"]"+MASK$; CONTINUE
4770 MASK$="[a]"+MASK$
4780 NEXT X
4790 ! 
4800 IF NEWFILE$="" THEN NEWFILE$=FILENAME$
4810 MASK$=NEWFILE$+MASK$
4820 FLIST$=FN%GET_FILES$(FPATH$,MASK$,";","Y","N")
4830 IF FLIST$<>"" THEN MSGBOX "Overwrite files:"+FLIST$,"Input Required","YESNO",RET$
4840 IF RET$="NO" THEN EXIT 
4850 ! 
4860 _O=HFN
4870 IF ISLINES THEN OPEN (_O)FILENAME$ ELSE OPEN (_O,ISZ=-1)FILENAME$
4880 ! 
4890 FOR Y=1 TO FCNT
4900 ! 
4910 ! MAKE FILE NAME
4920 DIM MASK$(SUFFIX_LEN,"a")
4930 TMP=0
4940 FOR X=1 TO SUFFIX_LEN
4950 TMP=(Y|(26^X))/(26^(X-1))
4960 IF X=1 AND TMP=0 THEN TMP=26
4970 IF X>1 AND FPT(TMP)>0 THEN TMP=INT(TMP)+1
4980 MASK$(SUFFIX_LEN-X+1,1)=CHR(96+TMP)
4990 NEXT X
5000 ! 
5010 FCURRENT$=NEWFILE$+MASK$
5020 ERASE FCURRENT$,ERR=*NEXT
5030 SERIAL FCURRENT$
5040 ! 
5050 _N=UNT
5060 IF ISLINES THEN {
5070 OPEN LOCK (_N)FCURRENT$
5080 FOR X=1 TO SIZE
5090 READ RECORD (_O,END=5170,IND=(X-1)*Y)A$
5100 WRITE RECORD (_N)A$; A$=""
5110 NEXT X
5120  } ELSE {
5130 OPEN LOCK (_N,ISZ=-1)FCURRENT$
5140 READ RECORD (_O,SIZ=SIZE,END=5170,IND=(Y-1)*SIZE)A$
5150 WRITE RECORD (_N,SIZ=SIZE)A$; A$=""
5160  }
5170 ! 
5180 CLOSE (_N,ERR=*NEXT)
5190 ! 
5200 NEXT Y
5210 ! 
5220 SENDMAIL:
5230 IF TCB(82)<2 THEN EXIT 
5240 ENTER ARG1$,ARG2$,ERR=*NEXT
5250 CALL PGN+";ROOTDRIVE",ROOT$
5260 IF POS("-"=ARG1$)>0 THEN FULLFILENAME$=ARG2$ ELSE FULLFILENAME$=ARG1$
5261 OPEN (UNT,ERR=*NEXT)FULLFILENAME$; _TM=LFO; TEMP$=PTH(_TM); CLOSE (_TM); IF TEMP$<>"" THEN FULLFILENAME$=TEMP$
5270 FILENAME$=FNGET_FILENAME$(FULLFILENAME$)
5280 PICKUPDIRECTORY$=ROOT$+"\inetpub\mailroot\pickup\" ! TODO REPLACE WITH CDO CLASS TO FIND METABASE PATH
5290 INVOKE "MOVE /y "+FULLFILENAME$+" "+PICKUPDIRECTORY$+FILENAME$
5300 EXIT 
5310 ! 
5400 ! ^ 100
5410 ROOTDRIVE:
5420 ENTER ROOT$
5430 ROOT$=ENV("SYSTEMDRIVE")
5440 IF ROOT$<>"" THEN EXIT 
5450 LOCAL WPATH$,WINVER$,CSIDL_WINDOWS,P
5460 CSIDL_WINDOWS=36
5470 CALL PGN+";getfolderpath",CSIDL_WINDOWS,WPATH$,WINVER$
5480 P=POS(":"=WPATH$)
5490 IF P<>0 THEN ROOT$=MID(WPATH$,1,P) ELSE ROOT$=""
5500 EXIT 
5510 ! 
5520 SERIALRECCNT:
5530 ENTER _HANDLE,LCNT
5540 LOCAL OLDIND,FILENAME$,FIBX$,FINX$
5550 LCNT=0
5560 IF _HANDLE=0 THEN MSGBOX "File handle not provided!","","OK"; EXIT 
5561 FIBX$=FIB(_HANDLE); IF MID(FIBX$,10,1)<>$01$ THEN MSGBOX FIN(_HANDLE,"FILENAME")+" is not a serial file"; EXIT 
5565 FINX$=FIN(_HANDLE)
5570 OLDIND=IND(_HANDLE,ERR=*NEXT)
5580 IF OLDIND=0 THEN FILENAME$=FIN(_HANDLE,"FILENAME")
5590 LCNT=DEC(MID(FIN(_HANDLE),1,4),ERR=*NEXT)
5600 IF LCNT=0 OR LCNT>2*10^9 THEN LCNT=10^6
5610 ! 
5620 READ (_HANDLE,IND=LCNT,END=*NEXT)
5630 LCNT=IND(_HANDLE,ERR=*NEXT)
5640 IF FILENAME$<>"" THEN {
5650 CLOSE (_HANDLE,ERR=*PROCEED); IF FINX$(27,2)=$0010$ THEN OPEN LOCK (_HANDLE)FILENAME$ ELSE OPEN (_HANDLE)FILENAME$
5660  } ELSE {
5670 READ (_HANDLE,IND=OLDIND-1,ERR=*NEXT)
5680  }
5690 EXIT 
5700 ! 
5710 START_TRACE:
5720 ENTER _TRACE,PRGNAME$,USERNAME$,ERR=*NEXT
5730 IF USERNAME$="" THEN CALL PGN+";GETUSERNAME",USERNAME$
5740 IF PRGNAME$="" THEN CALL PGN+";GET_STACK_PRG_NAME",STK-1,PRGNAME$
5750 TRACENAME$="TMP"+PRGNAME$+"_TRACE."+USERNAME$
5760 ERASE TRACENAME$,ERR=*NEXT
5770 SERIAL TRACENAME$
5780 _TRACE=HFN
5790 OPEN LOCK (_TRACE)TRACENAME$
5800 SETTRACE (_TRACE)
5810 EXIT 
5820 ! 
6160 ! 
9998 ! ^9998,1
9999 END 
10000 ! ^10000
20000 ! ^ 20000
20010 ! 
20020 DEF FN_DO_MESS(LOCAL MESS$)
20030 LOCAL TMP
20040 IF ISUNIX THEN TRANSLATE MESS$,";"+$02$+"\;"
20050 IF ISUNIX THEN TMP=SYS("echo "+MESS$+" >/dev/console 2>/dev/null")
20060 IF NOT(ISUNIX) THEN MSGBOX MESS$,"TopForm ZZ2FNC"
20070 RETURN 0
20080 END DEF
20090 ! 
20100 DEF FNIS_VALID(DPATH$)
20110 LOCAL _DIR
20120 _DIR=UNT
20130 OPEN (_DIR,ERR=*NEXT,ISZ=1)DPATH$; CLOSE (_DIR); RETURN 1
20140 RETURN 0
20150 END DEF
20160 ! 
20170 DEF FNGET_PATH$(FILENAME$)
20180 LOCAL _DIR,DPATH$,P
20190 _DIR=UNT
20200 OPEN (_DIR,ERR=20240,ISZ=1)DPATH$
20210 DPATH$=PTH(_DIR),P=POS("/\":DPATH$,-1)
20220 IF P>1 THEN DPATH$=MID(DPATH$,1,P-1)
20230 CLOSE (_DIR)
20240 RETURN DPATH$
20250 END DEF
20260 ! 
20270 DEF FNGET_PARSED_PATH$(APATH$)
20280 LOCAL P,CUSTOMDLM$
20290 IF POS(DLM="/\")=0 THEN CUSTOMDLM$=DLM
20300 P=POS("/\"+CUSTOMDLM$:APATH$,-1)
20310 IF P>1 THEN APATH$=MID(APATH$,1,P-1)
20320 RETURN APATH$
20330 END DEF
20340 ! 
20350 DEF FNGET_FILENAME$(APATH$)
20360 LOCAL P,CUSTOMDLM$
20370 IF POS(DLM="/\")=0 THEN CUSTOMDLM$=DLM
20380 P=POS("/\"+CUSTOMDLM$:APATH$,-1)
20390 IF P>1 THEN APATH$=MID(APATH$,P+1)
20400 RETURN APATH$
20410 END DEF
