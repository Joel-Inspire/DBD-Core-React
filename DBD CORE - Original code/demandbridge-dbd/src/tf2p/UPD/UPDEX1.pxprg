0010 ! UPDEX1 - File EX1 Maintenance
0035 REM "5.6 - 01/28/08 - 12.108611 - crg - SSP# 202107
0037 REM "202107-Oracle Database integration with TopForm                    
0040 REM "Copyright 2008 DemandBridge, Inc.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 ! FILENO - channel of open file
0051 ! KEYNO  - KEY NUMBER
0052 ! SEG1-SEG5$ : KEY SEGMENTS . CAN BE NULL
0053 ! A$ - RECORD A$
0054 ! FOUND - IF RECORD FOUND, THEN 1 ELSE 0
0055 ! BUSY - IF RECORD BUSY THEN 1 ELSE 0
0056 ! OK - IF RECORD ADDED OK=1 ELSE 0
0310 IOLIST A$
0500 INIT:
0505 DIM Z[255]; OPENED=0
0506 PVX2ORA$="PVX2ORA"
0520 IF FILENO<>0 AND POS("EX1"=PTH(FILENO))<>0 THEN GOTO 0589
0530 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,X5$,X0,X1,0
0540 Z$="01S EX1...  "; CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; FILENO=Z[1],OPENED=1
0590 RETURN 
0598 ! 
0599 ! 
0600 WRAPUP:
0610 IF OPENED THEN CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
0690 RETURN 
0698 ! 
0699 ! 
1000 READBYKEY:
1010 ENTER FILENO,KEYNO,SEG1$,SEG2$,SEG3$,SEG4$,SEG5$,A$,A{ALL},FOUND
1015 FOUND=0
1020 GOSUB INIT
1025 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1049 XP=PRM('XI'); SET_PARAM 'XI'
1050 IF FILENO<>0 THEN READ (FILENO,KNO=KEYNO,KEY=SEG1$+SEG2$+SEG3$+SEG4$+SEG5$,DOM=*NEXT)IOL=0310; FOUND=1
1051 SET_PARAM 'XI'=XP
1080 GOSUB WRAPUP
1090 EXIT 
1098 ! 
1099 ! 
1100 READNEXT:
1110 ENTER FILENO,A$,A{ALL},FOUND
1115 FOUND=0
1120 GOSUB INIT
1125 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1149 XP=PRM('XI'); SET_PARAM 'XI'
1150 IF FILENO<>0 THEN READ (FILENO,END=*NEXT)IOL=0310; FOUND=1
1151 SET_PARAM 'XI'=XP
1180 GOSUB WRAPUP
1190 EXIT 
1198 ! 
1199 ! 
1200 READPREV:
1210 ENTER FILENO,A$,A{ALL},FOUND
1215 FOUND=0
1220 GOSUB INIT
1225 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1249 XP=PRM('XI'); SET_PARAM 'XI'
1250 IF FILENO<>0 THEN PKEY$=KEP(FILENO,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=0310; FOUND=1
1251 SET_PARAM 'XI'=XP
1280 GOSUB WRAPUP
1290 EXIT 
1298 ! 
1299 ! 
1300 READFIRST:
1310 ENTER FILENO,A$,A{ALL},FOUND
1315 FOUND=0
1320 GOSUB INIT
1325 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1349 XP=PRM('XI'); SET_PARAM 'XI'
1350 IF FILENO<>0 THEN PKEY$=KEF(FILENO,KNO=0,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=0310; FOUND=1
1351 SET_PARAM 'XI'=XP
1380 GOSUB WRAPUP
1390 EXIT 
1398 ! 
1399 ! 
1400 READLAST:
1410 ENTER FILENO,A$,A{ALL},FOUND
1415 FOUND=0
1420 GOSUB INIT
1425 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1449 XP=PRM('XI'); SET_PARAM 'XI'
1450 IF FILENO<>0 THEN PKEY$=KEL(FILENO,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=0310; FOUND=1
1451 SET_PARAM 'XI'=XP
1480 GOSUB WRAPUP
1490 EXIT 
1498 ! 
1499 ! 
1500 EXTRACTBYKEY:
1510 ENTER FILENO,KEYNO,SEG1$,SEG2$,SEG3$,SEG4$,SEG5$,A$,A{ALL},FOUND,BUSY
1515 FOUND=0,BUSY=0
1525 CALL "UPDEX1;CLEAR_FIELDS",A$,A{ALL}
1549 XP=PRM('XI'); SET_PARAM 'XI'
1550 IF POS("EX1"=PTH(FILENO))=0 THEN BUSY=1 ELSE READ (FILENO,KNO=KEYNO,KEY=SEG1$+SEG2$+SEG3$+SEG4$+SEG5$,DOM=*NEXT)IOL=0310; FOUND=1,BUSY=1,PRIMEKEY$=KEC(FILENO,KNO=0); EXTRACT (FILENO,KEY=PRIMEKEY$,KNO=0,ERR=*NEXT); BUSY=0
1551 SET_PARAM 'XI'=XP
1590 EXIT 
1598 ! 
1599 ! 
1600 INSERT:
1610 ENTER FILENO,A$,A{ALL},OK
1615 OK=0,PRIMEKEY$=A$(1,30)
1620 GOSUB INIT
1650 WRITE (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=0310
1680 GOSUB WRAPUP
1690 EXIT 
1698 ! 
1699 ! 
1700 DELETE:
1710 ENTER FILENO,A$,A{ALL},FOUND,BUSY
1715 FOUND=0,BUSY=1,PRIMEKEY$=A$(1,30)
1720 GOSUB INIT
1750 REMOVE (FILENO,KEY=PRIMEKEY$,DOM=DELETE_END,ERR=*NEXT); BUSY=0
1775 DELETE_END:
1780 GOSUB WRAPUP
1790 EXIT 
1798 ! 
1799 ! 
1800 CLEAR_FIELDS:
1810 ENTER A$,A{ALL}
1820 DIM A$(1632),A[10]
1890 EXIT 
1898 ! 
1899 ! 
1900 UPDATE:
1910 ENTER FILENO,A$,A{ALL},BUSY
1915 BUSY=1,PRIMEKEY$=A$(1,30)
1920 GOSUB INIT
1950 WRITE (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=0310; BUSY=0
1980 GOSUB WRAPUP
1990 EXIT 
1998 ! 
1999 ! 
2000 CLEAR_LOCK:
2010 ENTER FILENO
2020 GOSUB INIT
2050 READ (FILENO,KNO=0,KEY="",ERR=*NEXT)
2080 GOSUB WRAPUP
2090 EXIT 
2098 ! 
2099 ! 
2200 WRITELOCK:
2210 ENTER FILENO,A$,A{ALL}
2215 PRIMEKEY$=A$(1,30)
2220 GOSUB INIT
2250 WRITE LOCK (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=0310
2280 GOSUB WRAPUP
2290 EXIT 
2298 ! 
2299 ! 
2500 VALIDATE:
2510 ENTER A$,A{ALL},MSG$
2520 A$=PAD(A$,1632),MSG$=""
2990 EXIT 
2998 ! 
2999 ! 
9999 END 
10000 UPDATE_ALL_PATHS:
10010 ENTER EX0,EX0$,X3$,X4$,CREATE_TYPE$,PFX_NAME$
10015 FILENO=0; GOSUB INIT; EX1=FILENO ! ex1
10016 SERIAL PVX2ORA$+".log",ERR=*PROCEED; CLOG=HFN; OPEN LOCK (CLOG)PVX2ORA$+".log"
10017 MX=FN_LOG_IT("INFO",DIM(10,"=")+"Update All Paths - Action : "+CREATE_TYPE$+DIM(10,"="))
10020 IF CREATE_TYPE$="M" THEN {! map
10022 IF PFX_NAME$="" THEN PREFIX FILE ""
10025 PREFIXFILE$="PFX"+%C$; IF PFX_NAME$<>"" THEN PREFIXFILE$=PFX_NAME$
10027 ERASE PREFIXFILE$,ERR=*NEXT
10030 OPENERR=1; PFXNME=HFN; OPEN (PFXNME,ERR=*NEXT)PREFIXFILE$; OPENERR=0
10035 IF OPENERR THEN KEYED PREFIXFILE$,12,0,-5124; GOTO 10030
10040 IF PFX_NAME$="" THEN PREFIX FILE "PFX"+%C$ ! Make sure we are using the prefix
10050  }
10060 DDF=HFN; OPEN (DDF,IOL=*)"providex.ddf"
10070 DDF2=HFN; OPEN (DDF2,IOL=*)"providex.ddf"
10080 PB_T=NUM(FIN(DDF,"NUMREC")); GOSUB PROG_BAR_INIT ! Initialize progress bar
10090 READ (DDF,KEY="",DOM=*NEXT,KNO=1)
10095 KY$="",KY$=KEY(DDF,END=*NEXT)
10200 WHILE KY$<>""
10210 READ (DDF); DDF_K$=KEC(DDF,KNO=0) ! Get primary id
10220 IF IOPROGRAM$<>"" THEN IOPROGRAM$=""; WRITE (DDF2,KEY=DDF_K$) ! clear embedded io program
10260 GOSUB KEEP_IN_PVX ! Check if file will continue within pvx
10270 TABLE_NAME$=UCS(NAME$)
10280 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : "+TBL(KEEP_PVX,"Oracle","Providex"))
10290 ! IF POS("ICF_"=TABLE_NAME$)=0 THEN KEEP_PVX=1 ! TO BE DELETED
10300 IF NOT(KEEP_PVX) THEN {! 10450
10305 TF_DDF_K$=NAME$(1,3)+%C$,EX1_NAME$=PAD(UCS(NAME$),30)
10307 CALL "UPDEX1;READBYKEY",EX1,0,EX1_NAME$,SEG2$,SEG3$,SEG4$,SEG5$,EX1$,EX1{ALL},FOUNDEX1
10310 IF NOT(FOUNDEX1) THEN {
10311 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : EX1: Creating EX1 record")
10315 CALL "UPDEX1;CLEAR_FIELDS",EX1$,EX1{ALL}
10320 EX1$(1,30)=PAD(EX1_NAME$,30),EX1$(31,1)=EX0$(1,1),EX1$(32,60)=PAD(TABLE_NAME$,60),EX1$(92,40)=EX0$(122,40),EX1$(132,1)=EX0$(162,1)
10325 CALL "UPDEX1;UPDATE",EX1,EX1$,EX1{ALL},BUSY
10330 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : EX1: Done (Busy "+STR(BUSY)+")")
10340  } ! 10310
10380 IF CREATE_TYPE$="M" THEN {
10381 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : PFX: Updating PFX map entry")
10390 CALL "UPDEX1;UPDATE_FILE_PREFIX",DDE,PFXNME,TF_DDF_K$,DDF_K$,NAME$,EX0$(2,60),EX0$(62,60),EX0$(164,20),EX0$(184,20),TABLE_NAME$,EX0$(163,1)
10391 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : PFX: Done")
10392  }
10400 IF CREATE_TYPE$="T" THEN {! 10447
10401 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" :  DB: Create external database table and index objects")
10405 IF EX0$(163,1)="O" THEN CALL "EXGOR0",SQL_GEN$,ERR$,NAME$,"*providex.ddf","","SQL" ELSE CALL "*dict/gensql",SQL_GEN$,ERR$,NAME$,"*providex.ddf",""
10410 IF ERR$="" AND SQL_GEN$<>"" THEN {! 10445]
10411 MX=FN_LOG_IT("SQL ",PAD(NAME$,30)+" :  "); MX=FN_LOG_IT("",SQL_GEN$)
10415 CALL "SQLDET;GET_OBJ",EX1,EX0,EX0$(1,1),"",OOP_DB
10420 X=OOP_DB'GENSQL(SQL_GEN$)
10425 ! PRINT NAME$
10427 IF NOT(X) THEN MX=FN_LOG_IT("ERR ",PAD(NAME$,30)+" : "+OOP_DB'OSMSG$)
10435 DROP OBJECT OOP_DB
10445  } ! 10410
10447  } ! 10400
10450  } ! 10300S
10500 KY$="",KY$=KEY(DDF,END=*NEXT)
10505 PB_C++; PB_MSG$=NAME$; GOSUB PROG_BAR_UPDATE
10510 WEND 
10515 PB_C=PB_T; PB_MSG$="Process completed!"; GOSUB PROG_BAR_UPDATE
10516 MX=FN_LOG_IT("INFO",DIM(10,"=")+"Update All Paths - Done"+DIM(10,"="))
10520 CLOSE (DDF,ERR=*PROCEED); CLOSE (PFXNME,ERR=*PROCEED); CLOSE (DDF2,ERR=*PROCEED); CLOSE (CLOG,ERR=*PROCEED)
10570 GOSUB PROG_BAR_WRAPUP
10580 GOSUB WRAPUP
10590 EXIT 
10598 ! 
10599 ! 
14000 UPDATE_FILE_PREFIX:
14010 ENTER DDE,PFXNME,TF_DDF_K$,DDF_K$,DDF_NAME$,DATABASE_LOC$,DATABASE_NAME$,USER$,PASS$,TABLE_NAME$,DB_TYPE$
15020 DDE=HFN; OPEN (DDE)"providex.dde"
15110 READ (DDE,KEY=DDF_K$,DOM=*NEXT)
15160 PFX_ELM$="REC="
15170 TFDATE$="",END_OF_STRING=0
15180 DIM KEY_ELEMENT$[100,100],MAX_KEY_ELEMENT[100,1],MAX_KEY_NUMBER(100) ! max 100 key elements
15200 ! ^100 - Get Element Information
15210 GET_ELM:
15220 READ (DDE,END=ADD_PFX)IOL=15590
15230 DDE_K$=KEC(DDE)
15240 IF DDE_K$(1,6)<>DDF_K$ THEN GOTO ADD_PFX
15260 IF LEN(PFX_ELM$)=4 THEN GOTO 15320
15270 IF PREV_FORMAT$="L" OR PREV_FORMAT$="D" THEN PFX_ELM$+=", "; GOTO 15320
15280 IF PREV_CLASS$="DATE-KKMMDD" THEN PFX_ELM$+="+ "; GOTO 15320
15290 IF FORMAT$="S" THEN PFX_ELM$=PFX_ELM$+"+ "
15295 IF FORMAT$="P" THEN PFX_ELM$=PFX_ELM$+"+ "
15300 IF FORMAT$="L" THEN PFX_ELM$=PFX_ELM$+"+ "
15310 IF FORMAT$="D" THEN PFX_ELM$=PFX_ELM$+"+"
15320 TF_RAW_TYPE$=""; IF POS(MID(TABLE_NAME$,1,3)="ASJFS6GL2IC8",3)>0 AND "SEQ_NUM"=NAME$ THEN TF_RAW_TYPE$="B"
15321 IF DB_TYPE$="O" THEN IF CLASS$="DATE-KKMMDD" THEN PFX_ELM$=PFX_ELM$+NAME$+":D",TFDATE$+=STR(END_OF_STRING+1:"0000"),END_OF_STRING+=NUM(LEN$) ELSE PFX_ELM$=PFX_ELM$+NAME$+":"+TF_RAW_TYPE$+LEN$,END_OF_STRING+=NUM(LEN$) ! Oracle style dates "DD-MM-YY", 9 long
15322 ! IF DB_TYPE$="O" THEN IF CLASS$="DATE-KKMMDD" THEN PFX_ELM$=PFX_ELM$+NAME$,TFDATE$+=STR(END_OF_STRING+1:"0000"),END_OF_STRING+=10 ELSE PFX_ELM$=PFX_ELM$+NAME$,END_OF_STRING+=NUM(LEN$) ! Oracle style dates "DD-MM-YY", 9 long
15330 IF DB_TYPE$<>"O" THEN IF CLASS$="DATE-KKMMDD" THEN PFX_ELM$=PFX_ELM$+NAME$+":D9",TFDATE$+=STR(END_OF_STRING+1:"0000"),END_OF_STRING+=11 ELSE PFX_ELM$=PFX_ELM$+NAME$+":"+LEN$,END_OF_STRING+=NUM(LEN$) ! MySQL style dates YYYY-MM-DD 10 chars long
15340 PREV_CLASS$=CLASS$,PREV_FORMAT$=FORMAT$
15350 IF CVS(KEYDEF$,128)="" THEN GOTO GET_ELM
15355 KEYS$=KEYDEF$
15360 WHILE LEN(KEYS$)>0
15365 XP=POS(","=KEYS$); IF XP=0 THEN KEY2$="" ELSE KEY2$=KEYS$(XP+1),KEYS$=KEYS$(1,XP-1)
15367 XP=POS(":"=KEYS$); KEYNUMBER=NUM(KEYS$(1,XP-1)); KEYS$=KEYS$(XP+1)
15368 XP=POS(":"=KEYS$); KEYELEMENT=NUM(KEYS$(1,XP-1))
15375 KEY_ELEMENT$[KEYNUMBER,KEYELEMENT]=NAME$,MAX_KEY_ELEMENT(KEYNUMBER,0)=MAX(MAX_KEY_ELEMENT(KEYNUMBER,0),KEYELEMENT),MAX_KEY_NUMBER=MAX(MAX_KEY_NUMBER,KEYNUMBER)
15380 IF KEY2$="" THEN KEYS$="" ELSE KEYS$=KEY2$
15390 WEND 
15395 GOTO GET_ELM
15400 ADD_PFX:
15405 IF POS("["=DATABASE_NAME$)>0 THEN GOTO 15411 ! "Skip setting special command tag if one is specified explicitly
15410 PFX_FIL$="[oci]" ! IF DB_TYPE$="M" PFX_FIL$="[sql]" - for mysql - currently not known
15415 IF STP(DATABASE_NAME$,2)<>"" THEN PFX_FIL$=PFX_FIL$+STP(DATABASE_NAME$,2) ! oracle system id
15420 PFX_FIL$=PFX_FIL$+";"+STP(TABLE_NAME$,2)+";USER="+STP(USER$,2)+";PSWD="+STP(PASS$,2)+";"
15430 GOSUB BUILD_KEY
15450 PFX_KEY$=TMPKEY$+"; " ! PFX_KEY$ initialized above
15460 IF LEN(TFDATE$)>0 THEN TFDATE$="DATEFMT=KKMMDD; "
15470 WRITE (PFXNME,KEY=TF_DDF_K$)PFX_FIL$,TFDATE$+PFX_KEY$+PFX_ELM$+";NONULLS=P;EXTROPT=$ FOR UPDATE NOWAIT;"+TBL(POS(TABLE_NAME$(1,3)="ASJFS6GL2IC8",3)=0,"PREPARE=N;","PREPARE=Y;")+TBL(POS(TABLE_NAME$(1,3)="ASJFS6GL2IC1IC8",3)=0,"IOPROG=EXGNUL;","")
15471 ! WRITE (PFXNME,KEY=TF_DDF_K$)PFX_FIL$,TFDATE$+PFX_KEY$+PFX_ELM$+";PREPARE=Y,NONULLS=P"
15590 IOLIST IOLOBJ$,NAME$,DESC$,TYPE$,LEN$,OCC$,FORMAT$,VALID$,PRINT$,HELP$,NOTES$,KEYDEF$,QUERY$,CLASS$,FLAGS$,DFLT$,ALT_NAME$,USER_TAG$
15980 CLOSE (DDE)
15990 EXIT 
15998 ! 
15999 ! 
16000 GET_COUNT:
16010 ENTER CHANNEL,NUM_OF_REC
16015 IF TCB(29)>=7100000 AND CHANNEL>0 THEN {
16020 P$=PTH(CHANNEL,ERR=DONE)
16030 READ DATA FROM P$,SEP=";" TO DB$,TABLE$
16035 DB_CODE$="",TABLE_NAME$=PAD(TABLE$,30)
16037 EX0=0,EX1=0
16040 CALL "SQLDET;GET_OBJ",EX1,EX0,DB_CODE$,TABLE_NAME$,OOP_DB
16050 NUM_OF_REC=OOP_DB'GET_COUNT(TABLE$)
16080 DROP OBJECT OOP_DB
16485  } ! 16015
16490 DONE:
16495 EXIT 
17000 BUILD_KEY:
17010 TMPKEY$=""
17020 IF MAX_KEY_NUMBER>0 THEN {
17030 FOR KEYNUMS=1 TO MAX_KEY_NUMBER
17040 IF TMPKEY$="" THEN TMPKEY$="KEY=" ELSE TMPKEY$=TMPKEY$+";KEY="
17045 IF MAX_KEY_ELEMENT(KEYNUMS,0)>0 THEN {
17050 FOR E=1 TO MAX_KEY_ELEMENT(KEYNUMS,0)
17060 IF TMPKEY$(LEN(TMPKEY$)-3,4)="KEY=" THEN TMPKEY$+=KEY_ELEMENT$[KEYNUMS,E] ELSE TMPKEY$+=","+KEY_ELEMENT$[KEYNUMS,E]
17090 NEXT E
17100  } ! 17045
17140 NEXT KEYNUMS
17150  }
17190 RETURN 
20500 ! 
20510 UPDATE_DATA:
20520 ENTER EX0,EX0$,X3$,X4$,CONV_DIR$,LD_CMD$,ERR=*NEXT
20525 FILENO=0; GOSUB INIT; EX1=FILENO
20530 SERIAL PVX2ORA$+".log",ERR=*PROCEED; CLOG=HFN; OPEN LOCK (CLOG)PVX2ORA$+".log"
20532 MX=FN_LOG_IT("INFO",DIM(10,"=")+" Update Table data "+DIM(10,"="))
20533 MX=FN_LOG_IT("INFO",PAD("Conversion directory",30)+" : "+CONV_DIR$)
20534 MX=FN_LOG_IT("INFO",PAD("Load utlity command",30)+" : "+LD_CMD$)
20539 DDF=HFN; OPEN (DDF,IOL=*)"providex.ddf"
20540 PB_T=NUM(FIN(DDF,"NUMREC")); GOSUB PROG_BAR_INIT ! Initialize progress bar
20550 READ (DDF,KEY="",DOM=*NEXT,KNO=1)
20560 KY$="",KY$=KEY(DDF,END=*NEXT)
20570 WHILE KY$<>""
20580 READ (DDF); DDF_K$=KEC(DDF,KNO=0) ! Get primary id
20590 GOSUB KEEP_IN_PVX
20600 TABLE$=UCS(NAME$)
20605 ! IF POS("ICF_"=TABLE$)=0 THEN KEEP_PVX=1 ! TO BE DELETED
20610 IF NOT(KEEP_PVX) THEN {! 10450
20611 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" :")
20620 DUMPDIR$=STP(CONV_DIR$),CTLSQL$="",ORA_IOL$="",PVX_IOL$=""
20630 CALL "EXGOR0",CTLSQL$,ERRMSG$,TABLE$,"*providex.ddf","","CTL"
20640 SERIAL DUMPDIR$+TABLE$+".ctl",ERR=*NEXT
20650 CTLCHAN=HFN; OPEN PURGE (CTLCHAN)DUMPDIR$+TABLE$+".ctl"
20660 PRINT (CTLCHAN)SUB(CTLSQL$,"PVX2ORA",SUB(DUMPDIR$,"[wdx]",""))
20670 CLOSE (CTLCHAN)
20671 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : Created data load control file")
20680 PVXCHAN=HFN; OPEN (PVXCHAN,ERR=ERR_PVX_READ)%DATAPATH$+DLM+TABLE$(1,3)+%C$
20690 SERIAL DUMPDIR$+TABLE$+".txt",ERR=*NEXT
20700 TXTCHAN=HFN; OPEN PURGE (TXTCHAN)DUMPDIR$+TABLE$+".txt"
20710 CALL "EXGOR0",ORA_IOL$,ERRMSG$,TABLE$,"*providex.ddf","","IOL"
20720 CALL "ZZWIOL",PVXCHAN,"B",PVX_IOL$
20730 PVX_IOL$=CPL(PVX_IOL$)
20740 ORA_IOL$=CPL(ORA_IOL$)
20741 REC_COUNT=0; MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : Dumping Topform file data to import text file")
20750 READ (PVXCHAN,END=20831,ERR=ERR_PVX_READ)IOL=PVX_IOL$
20760 PRINT (TXTCHAN)IOL=ORA_IOL$
20761 REC_COUNT++
20770 GOTO 20750
20780 ! 
20790 ERR_PVX_READ:
20800 PVXERR=ERR
20810 IF PVXERR=81 OR PVXERR=26 THEN MX=FN_LOG_IT("ERR ",PAD(NAME$,30)+" : Table "+TABLE$+" : ERR "+STR(PVXERR)+" : Error reading data using embedded IOLIST! Skipping..."); GOTO 20831
20820 MX=FN_LOG_IT("ERR ",PAD(NAME$,30)+" : Table "+TABLE$+" : ERR "+STR(PVXERR)+" : Unknown error when reading data! Skipping..."); GOTO 20831
20830 ! 
20831 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : Dump data to text file... Done! Records:"+STR(REC_COUNT))
20840 CLOSE (TXTCHAN),(PVXCHAN)
20845 IF REC_COUNT=0 THEN MX=FN_LOG_IT("LOAD",PAD(NAME$,30)+" : Empty file... Skipping load"); GOTO 20879
20850 SQLLDR:
20851 MX=FN_LOG_IT("FILE",PAD(NAME$,30)+" : Invoking external database load utility")
20852 INVOKE_CMD$=STP(LD_CMD$)+" silent=all control="+SUB(DUMPDIR$,"[wdx]","")+TABLE$+".ctl"
20853 MX=FN_LOG_IT("LOAD",PAD(NAME$,30)+" : "+INVOKE_CMD$)
20860 INVOKE INVOKE_CMD$,ERR=*NEXT; GOTO 20866
20865 MX=FN_LOG_IT("ERR ",PAD(NAME$,30)+" : Error when invoking load"); GOTO 20871
20870 MX=FN_LOG_IT("INFO",PAD(NAME$,30)+" : Load file data... Done")
20880  } ! 10410
20890 KY$="",KY$=KEY(DDF,END=*NEXT)
20900 PB_C++; PB_MSG$=NAME$; GOSUB PROG_BAR_UPDATE
20910 WEND 
20920 PB_C=PB_T; PB_MSG$="Process completed!"; GOSUB PROG_BAR_UPDATE
20921 MX=FN_LOG_IT("INFO",DIM(10,"=")+" Update table data - All Tables Done "+DIM(10,"="))
20930 CLOSE (DDF); CLOSE (CLOG)
20940 GOSUB PROG_BAR_WRAPUP
20950 GOSUB WRAPUP
20960 EXIT 
20970 ! 
22000 UPGRADE_ALL_TABLES:
22010 ENTER EX0,EX0$,X3$,X4$,CR_TYPE$
22020 FILENO=0; GOSUB INIT; EX1=FILENO
22030 IOL_EX1:IOLIST EX1$
22040 IOL_PFX:IOLIST PFX1$,PFX2$
22050 IOL_TPFX:IOLIST TPFX1$,TPFX2$
22070 MAIN:GOSUB CREATE_TEMP_PREFIX_FILE
22090 CALL "SQLDET;GET_OBJ",EX1,EX0,EX0$(1,1),"",OOP_DB
22100 TPFX=HFN; OPEN (TPFX)TEMP_PFX$
22110 SERIAL TEMP_PFX$+".log"; CLOG=HFN; OPEN LOCK (CLOG)TEMP_PFX$+".log"
22120 OPFX=HFN; OPEN (OPFX)"PFX"+%C$
22130 READ (EX1,KEY="",DOM=*NEXT)
22140 ! 
22141 TBL_SEQ=0
22150 NEXT_EX1_REC:
22160 EX1_KEY$=KEY(EX1,END=END_UPDT); READ (EX1,KEY=EX1_KEY$)
22170 READ (TPFX,KEY=EX1_KEY$(1,3)+%C$,DOM=NO_OLD_PFX_ENTRY)IOL=IOL_TPFX
22180 READ (OPFX,KEY=EX1_KEY$(1,3)+%C$,DOM=NO_NEW_PFX_ENTRY)IOL=IOL_PFX
22190 TABLE$=STP(EX1_KEY$,2); ++TBL_SEQ
22200 IF PFX2$<>TPFX2$ THEN {
22210 MX=FN_LOG_IT("INFO",STR(TBL_SEQ)+": "+EX1_KEY$)
22220 GOSUB PROCESS_DIFFERENCES
22221 WRITE (OPFX,KEY=EX1_KEY$(1,3)+%C$,ERR=ERR_UPD_PFX_ENTRY)IOL=IOL_TPFX
22222 MX=FN_LOG_IT("INFO",STR(TBL_SEQ)+": "+EX1_KEY$+" - Updated prefix path entry")
22230  }
22240 GOTO NEXT_EX1_REC
22241 ! Error log messages
22250 NO_OLD_PFX_ENTRY: MX=FN_LOG_IT("ERR","No old prefix record for file: "+EX1_KEY$); GOTO NEXT_EX1_REC
22260 NO_NEW_PFX_ENTRY: MX=FN_LOG_IT("ERR","No new prefix record for file: "+EX1_KEY$); GOTO NEXT_EX1_REC
22270 ERR_UPD_PFX_ENTRY: MX=FN_LOG_IT("ERR","Error updating prefix record for file: "+EX1_KEY$); GOTO NEXT_EX1_REC
22280 ! 
22290 END_UPDT:CLOSE (OPFX),(TPFX),(CLOG)
22305 DROP OBJECT OOP_DB
22310 GOSUB WRAPUP
22320 EXIT 
22330 ! 
22340 REM "Create a temp prefix file
22350 CREATE_TEMP_PREFIX_FILE:
22360 IF TSEQ>9 THEN ESCAPE 12; REM "10 attempts to create a temp PFX file failed
22370 TEMP_PFX$="PFX"+DTE(JUL(DAY)+((TIM+(TCB(44)/3600))/24),*:"%Y%Mz%Dz%Hz%mz%sz")+STR(TSEQ++:"0")
22380 TPFX=HFN; OPEN (TPFX,ERR=*NEXT)TEMP_PFX$; CLOSE (TPFX); GOTO CREATE_TEMP_PREFIX_FILE
22390 CALL "UPDEX1;UPDATE_ALL_PATHS",EX0,EX0$,X3$,X4$,"M",TEMP_PFX$
22400 RETURN 
22410 ! 
22420 REM "Process differences found between old and new PFX entries
22430 PROCESS_DIFFERENCES:
22440 DIM KEYS$[2,10],COLS$[2,300,4]; NKEY1=0,NKEY2=0,NCOL1=0,NCOL2=0
22450 PFX_REC$=PFX2$
22460 NREC=1; GOSUB PARSE_PFX_REC; NKEY1=IDX,NCOL1=COL
22470 PFX_REC$=TPFX2$
22480 NREC=2; GOSUB PARSE_PFX_REC; NKEY2=IDX,NCOL2=COL
22490 ! 
22500 GOSUB COMP_COLS ! Mark cols with appropriate change code
22510 ! 
22520 IS_DIFFERENT=0
22530 FOR I=1 TO MAX(NCOL1,NCOL2) ! Iterate over cols
22540 DIM Y5$(100)
22550 IF NOT(NUL(COLS$[1,I,0])) AND COLS$[1,I,2]<>"N" THEN Y5$(12)=" <"+COLS$[1,I,2]+"< "+PAD(COLS$[1,I,0],18)+" : "+PAD(COLS$[1,I,1],4)+" : "+COLS$[1,I,3]
22560 IF NOT(NUL(COLS$[2,I,0])) AND COLS$[2,I,2]<>"N" THEN Y5$(50)=" >"+COLS$[2,I,2]+"> "+PAD(COLS$[2,I,0],18)+" : "+PAD(COLS$[2,I,1],4)+" : "+COLS$[2,I,3]
22570 IF NOT(NUL(Y5$)) THEN {
22580 Y5$(4,7)="Col "+STR(I:"##0"),Y5$(49,1)="|"; MX=FN_LOG_IT("INFO",Y5$)
22590 IS_DIFFERENT=1
22600  }
22610 NEXT I
22620 ! 
22630 REM "Tables are different, handle it
22640 IF IS_DIFFERENT THEN {
22650 FOR I=1 TO NKEY1 ! Drop all old keys, including primary key
22660 IF I=1 THEN {
22670 SQL$="ALTER TABLE "+TABLE$+" DROP CONSTRAINT KEY0_"+TABLE$+";"; GOSUB EXEC_SQL
22680  } ELSE {
22690 SQL$="DROP INDEX KEY"+STR(I-1)+"_"+TABLE$+";"; GOSUB EXEC_SQL
22700  }
22710 NEXT I
22720 ! 
22730 DEL_LIST$="" ! Delete cols from old table which are no longer present in new table
22740 FOR I=1 TO NCOL1
22750 IF COLS$[1,I,2]="D" THEN {
22760 IF NOT(NUL(DEL_LIST$)) THEN DEL_LIST$+=", "
22770 DEL_LIST$+=COLS$[1,I,0]
22780  }
22790 NEXT I
22800 ! IF NOT(NUL(DEL_LIST$)) THEN SQL$="ALTER TABLE "+TABLE$+" DROP ("+DEL_LIST$+");"; GOSUB EXEC_SQL
22810 ! 
22820 MOD_LIST$="" ! Add new cols in new table, modify existing cols which have changed
22830 FOR I=1 TO NCOL2
22840 IF COLS$[2,I,2]="M" THEN {
22850 MOD_LIST$+=$0A$+" MODIFY ("+COLS$[2,I,0]+" "+COLS$[2,I,3]+")"
22851 IF POS(COLS$[2,I,0]=KEYS$[1,1])=0 AND POS(COLS$[2,I,0]=KEYS$[2,1])<>0 THEN {! If col is now part of primary key in new table
22853 MX=FN_LOG_IT("INFO","Col "+COLS$[2,I,0]+" is part of primary key, ensure no nulls in table")
22854 SQL$="UPDATE "+TABLE$+" SET "+COLS$[2,I,0]+" ="+COLS$[2,I,4]+" WHERE "+COLS$[2,I,0]+" IS NULL;"; GOSUB EXEC_SQL
22856  }
22860  }
22861 IF COLS$[2,I,2]="A" THEN {
22870 MOD_LIST$+=$0A$+" ADD "+COLS$[2,I,0]+" "+COLS$[2,I,3]
22880  }
22890 NEXT I
22900 IF NOT(NUL(MOD_LIST$)) THEN SQL$="ALTER TABLE "+TABLE$+MOD_LIST$+";"; GOSUB EXEC_SQL
22910 ! 
22920 FOR I=1 TO NKEY2 ! Iterate over new keys - create new primary key and indexes
22930 IF I=1 THEN {
22940 SQL$="ALTER TABLE "+TABLE$+" ADD ( CONSTRAINT KEY0_"+TABLE$+" PRIMARY KEY ("+KEYS$[2,I]+"));"; GOSUB EXEC_SQL
22950  } ELSE {
22960 SQL$="CREATE INDEX KEY"+STR(I-1)+"_"+TABLE$+" ON "+TABLE$+" ("+KEYS$[2,I]+");"; GOSUB EXEC_SQL
22970  }
22980 NEXT I
22990  } ! END IS_DIFFERENT
23000 RETURN 
23010 ! 
23020 PARSE_PFX_REC:
23030 IDX=0
23040 NEXT_KEY: SKEY=MSK(PFX_REC$,"KEY=[^;]*;"); IF SKEY=0 THEN GOTO DONE_KEYS
23050 NEXT_KEY$=MID(PFX_REC$,SKEY+4,MSL-5,ERR=ERR_PARSE_REC); PFX_REC$=PFX_REC$(MSL+1)
23060 KEYS$[NREC,++IDX]=NEXT_KEY$
23070 GOTO NEXT_KEY
23080 DONE_KEYS:
23090 DATATYPE$=DIM(2),COL=0,COLMSK1$="REC=[^;]*;",COLMSK2$="[^,+;]*[,+;]"
23100 SCOL=MSK(PFX_REC$,COLMSK1$,ERR=ERR_PARSE_REC); IF SCOL=0 THEN GOTO DONE_COLS ELSE PFX_REC$=MID(PFX_REC$,SCOL+4,MSL-4)
23110 NEXT_COL: SCOL=MSK(PFX_REC$,COLMSK2$,ERR=ERR_PARSE_REC); IF SCOL=0 THEN GOTO DONE_COLS
23120 NEXT_COL$=MID(PFX_REC$,SCOL,MSL-1,ERR=ERR_PARSE_REC); DATATYPE$(1,1)=DATATYPE$(2,1); DATATYPE$(2,1)=MID(PFX_REC$,MSL,1); PFX_REC$=PFX_REC$(MSL+1)
23130 IF NOT(NUL(NEXT_COL$)) THEN {
23140 CPOS=POS(":"=NEXT_COL$); ++COL
23150 COLS$[NREC,COL,0]=STP(NEXT_COL$(1,CPOS-1),2)
23160 COLS$[NREC,COL,1]=SUB(STP(NEXT_COL$(CPOS+1),2),"B","")
23170 DTYPE$=STR(INT((POS(DATATYPE$="   + ;+;+++,,,,; ,",2)+1)/2))
23171 DEFAULT_STR$="",NOT_NULL$=" NOT NULL "
23180 SWITCH DTYPE$
23190 CASE "1","2","3","4","5","6"
23200 IF POS("D"=COLS$[NREC,COL,1])>0 THEN COLS$[NREC,COL,3]="DATE"; DEFAULT_STR$+=" SYSDATE" ELSE COLS$[NREC,COL,3]="VARCHAR2("+COLS$[NREC,COL,1]+")"; DEFAULT_STR$+=" '"+DIM(NUM(COLS$[NREC,COL,1]))+"'"
23210 BREAK
23220 CASE "7","8","9"
23230 COLS$[NREC,COL,3]="NUMBER("+SUB(COLS$[NREC,COL,1],".",",")+")"; DEFAULT_STR$+=" 0"
23240 BREAK
23250 DEFAULT:
23260 COLS$[NREC,COL,3]="UNKNOWN"
23270 BREAK
23280 END SWITCH 
23281 IF POS(COLS$[NREC,COL,0]=KEYS$[NREC,1])>0 THEN COLS$[NREC,COL,3]+=" DEFAULT "+DEFAULT_STR$+NOT_NULL$; COLS$[NREC,COL,4]=DEFAULT_STR$
23290  }
23300 GOTO NEXT_COL
23310 DONE_COLS:
23320 GOTO *RETURN
23330 ERR_PARSE_REC: MX=FN_LOG_IT("ERR","Error parsing PFX record for table:"+EX1_KEY$)
23340 RETURN 
23350 ! 
23360 COMP_COLS:
23370 FOR I=1 TO MAX(NCOL1,NCOL2) ! Iterate over cols in old table
23380 FOR J=1 TO NCOL2 ! Iterate over cols in new table
23390 IF COLS$[1,I,0]=COLS$[2,J,0] AND COLS$[1,I,1]=COLS$[2,J,1] THEN {! If old col still present in table...
23400 COLS$[1,I,2]="N",COLS$[2,J,2]="N"; REM "N = No Change
23410 BREAK
23420  } ELSE IF COLS$[1,I,0]=COLS$[2,J,0] AND COLS$[1,I,1]<>COLS$[2,J,1] THEN {! If old col still present in table, but type different...
23430 COLS$[1,I,2]="M",COLS$[2,J,2]="M"; REM "M = Modified, either col type or col length changed
23440 BREAK
23450  }
23460 NEXT J
23470 IF J>NCOL2 AND I<=NCOL1 THEN COLS$[1,I,2]="D"; REM "D = Deleted, No match found for old col in new table
23480 NEXT I
23490 FOR I=1 TO NCOL2
23491 IF NUL(COLS$[2,I,2]) THEN {
23492 COLS$[2,I,2]="A"; REM "A = Added, Mark unmarked cols in new table
23493  } ELSE {
23494 IF POS(COLS$[2,I,0]=KEYS$[1,1])=0 AND POS(COLS$[2,I,0]=KEYS$[2,1])<>0 THEN {
23495 COLS$[2,I,2]="M"; REM "M = Modified, not structurally, but because of participating in primary key
23496  }
23497  }
23498 NEXT I
23500 RETURN 
23510 ! 
23520 EXEC_SQL:
23530 SQLMSG$=""
23531 MX=FN_LOG_IT("SQL",SQL$)
23540 ! Execute SQL here
23545 X=OOP_DB'EXECSQL(STP(SQL$,2,";")); IF NOT(X) THEN MX=FN_LOG_IT("RESP",OOP_DB'OSMSG$)
23560 ! IF response, log that also
23570 IF NOT(NUL(SQLMSG$)) THEN MX=FN_LOG_IT("RESP",SQLMSG$)
23580 RETURN 
23590 ! 
23600 DEF FN_LOG_IT(LOCAL MSGTYPE$, LOCAL MSG$)
23610 PRINT (CLOG)DTE(0:"%Y:%Dz:%Mz-%Hz:%mz:%sz")+" [",PAD(MSGTYPE$,5),"] ",MSG$
23620 RETURN 0
23630 END DEF
23640 ! 
23650 KEEP_IN_PVX:
23660 KEEP_PVX=0
23663 IF POS("VIEW:"=UCS(NAME$))<>0 OR POS("{"=NAME$)<>0 THEN KEEP_PVX=1; GOTO *RETURN
23664 IF POS(UCS(NAME$(1,1))="Z")<>0 THEN KEEP_PVX=1; GOTO *RETURN
23665 IF POS(UCS(NAME$(1,2))="CCCEDBDRDTEXFRKTOEOFRWSSTFTK",2)<>0 THEN KEEP_PVX=1; GOTO *RETURN
23666 IF POS(UCS(NAME$(1,3))="APAAPCAPDAPGAPHAPJAPLAPRAPTAPZARBARCARRAS1ASBASDAT3AT4AT5AT6AT7OEX",3)<>0 THEN KEEP_PVX=1; GOTO *RETURN
23667 IF POS(UCS(NAME$(1,3))="EM5EM6EM8EMAEMBEMDFM6FS3FSAFSMFSNGL7GLWICAORDPO7POHVERWC0",3)<>0 THEN KEEP_PVX=1; GOTO *RETURN
23668 IF POS(UCS(NAME$(1,3))="FSBFSCGLFICLICMGL6POB",3)<>0 THEN KEEP_PVX=1; GOTO *RETURN
23670 RETURN 
23680 ! 
24000 ! 
24005 DEF FN_TFDATE$(LOCAL TFDATE$, LOCAL DATE_FORMAT$, LOCAL MODE)
24010 LOCAL RET_VAL$
24015 IF TFDATE$<>"" AND NUL(TFDATE$) THEN IF MODE=0 THEN RET_VAL$=TFDATE$; GOTO 24090 ELSE TFDATE$="G00101" ! If tfdate is "" or all spaces, then return the same number of spaces if not a key column else return "1960-01-01"
24020 RET_VAL$=FN%PRINT_DATETIME$(FN%GET_DATETIME(TFDATE$,0),DATE_FORMAT$)
24090 RETURN RET_VAL$
24095 END DEF
24100 ! 
26000 REM "Initialize Progress Bar
26010 PROG_BAR_INIT:
26020 MSG$=MSG("THERE_ARE")+" "+STR(PB_T:"####")+" "+MSG("REC_TO_P")
26030 PB_T0=INT(PB_T*.02); IF PB_T0<=1 THEN PB_T0=2
26040 CALL "*PROGBAR;init",MSG$,45,25,18
26050 REFRESH_FLG=1
26060 RETURN 
26070 REM "Destroy Progress Bar
26080 PROG_BAR_WRAPUP:
26085 WAIT 1
26090 CALL "*PROGBAR;WRAP_UP"
26100 ! MSGBOX MSG("PROC_C"),MSG("FYI"),"!,tim=5"
26110 REFRESH_FLG=1
26120 RETURN 
26130 REM "Update the Progress Bar graph
26140 PROG_BAR_UPDATE:
26150 IF PB_T<=0 THEN PB_T=1
26160 CALL "*PROGBAR;UPDATE_PERCENT",ERR=PROG_BAR_BREAK,PB_MSG$,PB_C/PB_T*100
26170 RETURN 
26200 REM "Interrupt process being tracked by this progress bar
26210 PROG_BAR_BREAK:EXITTO *NEXT
26215 CALL "*PROGBAR;WRAP_UP"
26220 EXIT 
56001 REM "202107-Oracle Database integration with TopForm                    
56002 REM "206056-Create process to allow Topform upgrade in Oracle  
