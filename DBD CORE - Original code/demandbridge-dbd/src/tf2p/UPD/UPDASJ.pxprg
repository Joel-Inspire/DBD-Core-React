0010 ! UPDASJ - File ASJ Maintenance
0035 REM "5.5 - 07/19/06 - 9.654166 - bam - SSP# 168612
0037 REM "168612-Need to add Bill as shipped orders to update the ASJ file   
0040 REM "Copyright 2006 TopForm Software Inc.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 ! FILENO - CHANNEL OF OPEN FILE
0051 ! KEYNO  - KEY NUMBER
0052 ! SEG1-SEG5$ : KEY SEGMENTS . CAN BE NULL
0053 ! A$ - RECORD A$
0054 ! FOUND - IF RECORD FOUND, THEN 1 ELSE 0
0055 ! BUSY - IF RECORD BUSY THEN 1 ELSE 0
0056 ! OK - IF RECORD ADDED OK=1 ELSE 0
0200 ! 
0210 ! UPDASJ r/w & i/o routines are copied and based upon the UPDxxx
0220 ! series of programs by jme.
0230 ! The NEW_ASJ_FROM_PO7 routine is mostly a copy and variable
0240 ! substitution from AR2DUN after line 1110.  Many comments
0250 ! identifying the fields have been added.
0260 ! 
0310 IOL_MAIN:IOLIST A$,A[0]
0500 INIT:
0505 DIM Z[255]; OPENED=0
0507 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,X5$,X0,X1,0
0510 IF POS("ASJ"=PTH(FILENO))=0 THEN Z$="01O ASJ...  "; CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; FILENO=Z[1],OPENED=1
0590 RETURN 
0598 ! 
0599 ! 
0600 WRAPUP:
0610 IF OPENED THEN CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
0690 RETURN 
0698 ! 
0699 ! 
0700 READ_PREP:
0710 FOUND=0
0720 GOSUB INIT
0724 GOSUB V_INIT
0725 CALL SELF$+"CLEAR_FIELDS",A$,A{ALL}
0749 XP=PRM('XI'); SET_PARAM 'XI'
0750 RETURN 
0760 READ_FIN:
0761 SET_PARAM 'XI'=XP
0780 GOSUB WRAPUP
0790 RETURN 
0798 ! 
0799 ! 
0800 V_INIT:
0810 SELF$="UPDASJ"
0820 IF MID(SELF$,-1)<>";" THEN SELF$+=";"
0830 PKEY_POS=1,PKEY_LEN=28
0836 ! 
0837 ! a_len value based upon AR2DUN line 3010 - dim f$(349).
0838 ! UT2FLD of ASJ implies 324 + 46 - 1 = 369.
0839 ! 
0840 A_LEN=349
0850 A_SUB_MAX=0 ! make sure this matches the iolist(s) !
0889 ! 
0890 RETURN 
0898 ! 
0899 ! 
1000 READBYKEY:
1010 ENTER FILENO,KEYNO,SEG1$,SEG2$,SEG3$,SEG4$,SEG5$,A$,A{ALL},FOUND
1020 GOSUB READ_PREP
1050 READ (FILENO,KNO=KEYNO,KEY=SEG1$+SEG2$+SEG3$+SEG4$+SEG5$,DOM=*NEXT)IOL=IOL_MAIN; FOUND=1
1080 GOSUB READ_FIN
1090 EXIT 
1098 ! 
1099 ! 
1100 READNEXT:
1110 ENTER FILENO,A$,A{ALL},FOUND
1120 GOSUB READ_PREP
1150 READ (FILENO,END=*NEXT)IOL=IOL_MAIN; FOUND=1
1180 GOSUB READ_FIN
1190 EXIT 
1198 ! 
1199 ! 
1200 READPREV:
1210 ENTER FILENO,A$,A{ALL},FOUND
1220 GOSUB READ_PREP
1250 PKEY$=KEP(FILENO,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=IOL_MAIN; FOUND=1
1280 GOSUB READ_FIN
1290 EXIT 
1298 ! 
1299 ! 
1300 READFIRST:
1310 ENTER FILENO,A$,A{ALL},FOUND
1320 GOSUB READ_PREP
1350 PKEY$=KEF(FILENO,KNO=0,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=IOL_MAIN; FOUND=1
1380 GOSUB READ_FIN
1390 EXIT 
1398 ! 
1399 ! 
1400 READLAST:
1410 ENTER FILENO,A$,A{ALL},FOUND
1420 GOSUB READ_PREP
1450 PKEY$=KEL(FILENO,ERR=*NEXT); READ (FILENO,KEY=PKEY$)IOL=IOL_MAIN; FOUND=1
1480 GOSUB READ_FIN
1490 EXIT 
1498 ! 
1499 ! 
1500 EXTRACTBYKEY:
1510 ENTER FILENO,KEYNO,SEG1$,SEG2$,SEG3$,SEG4$,SEG5$,A$,A{ALL},FOUND,BUSY
1515 FOUND=0,BUSY=0
1524 GOSUB V_INIT
1525 CALL SELF$+"CLEAR_FIELDS",A$,A{ALL}
1546 ! 
1547 ! Is 'if pos("ASJ"...' below in lieu of "gosub init"?
1548 ! 
1549 XP=PRM('XI'); SET_PARAM 'XI'
1550 IF POS("ASJ"=PTH(FILENO))=0 THEN BUSY=1 ELSE READ (FILENO,KNO=KEYNO,KEY=SEG1$+SEG2$+SEG3$+SEG4$+SEG5$,DOM=*NEXT)IOL=IOL_MAIN; FOUND=1,BUSY=1,PRIMEKEY$=KEC(FILENO,KNO=0); EXTRACT (FILENO,KEY=PRIMEKEY$,KNO=0,ERR=*NEXT); BUSY=0
1551 SET_PARAM 'XI'=XP
1590 EXIT 
1598 ! 
1599 ! 
1600 INSERT:
1610 ENTER FILENO,A$,A{ALL},OK
1614 GOSUB V_INIT
1615 OK=0,PRIMEKEY$=A$(PKEY_POS,PKEY_LEN)
1620 GOSUB INIT
1650 WRITE (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=IOL_MAIN; OK=1
1680 GOSUB WRAPUP
1690 EXIT 
1698 ! 
1699 ! 
1700 DELETE:
1710 ENTER FILENO,A$,A{ALL},FOUND,BUSY
1714 GOSUB V_INIT
1715 FOUND=0,BUSY=1,PRIMEKEY$=A$(PKEY_POS,PKEY_LEN)
1720 GOSUB INIT
1747 ! 
1748 ! why isn't dom=*next?
1749 ! 
1750 REMOVE (FILENO,KEY=PRIMEKEY$,DOM=DELETE_END,ERR=*NEXT); BUSY=0
1775 DELETE_END:
1780 GOSUB WRAPUP
1790 EXIT 
1798 ! 
1799 ! 
1800 CLEAR_FIELDS:
1810 ENTER A$,A{ALL}
1815 GOSUB V_INIT
1820 DIM A$(A_LEN),A[A_SUB_MAX]
1890 EXIT 
1898 ! 
1899 ! 
1900 UPDATE:
1910 ENTER FILENO,A$,A{ALL},BUSY
1914 GOSUB V_INIT
1915 BUSY=1,PRIMEKEY$=A$(PKEY_POS,PKEY_LEN)
1920 GOSUB INIT
1950 WRITE (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=IOL_MAIN; BUSY=0
1980 GOSUB WRAPUP
1990 EXIT 
1998 ! 
1999 ! 
2000 CLEAR_LOCK:
2010 ENTER FILENO
2020 GOSUB INIT
2050 READ (FILENO,KNO=0,KEY="",ERR=*NEXT)
2080 GOSUB WRAPUP
2090 EXIT 
2098 ! 
2099 ! 
2200 WRITELOCK:
2210 ENTER FILENO,A$,A{ALL}
2214 GOSUB V_INIT
2215 PRIMEKEY$=A$(PKEY_POS,PKEY_LEN)
2220 GOSUB INIT
2250 WRITE LOCK (FILENO,KEY=PRIMEKEY$,ERR=*NEXT)IOL=IOL_MAIN
2280 GOSUB WRAPUP
2290 EXIT 
2298 ! 
2299 ! 
2500 VALIDATE:
2510 ENTER A$,A{ALL},MSG$
2520 A$=PAD(A$,A_LEN),MSG$=""
2990 EXIT 
2998 ! 
2999 ! 
9999 END 
10000 ! 
11100 NEW_ASJ_FROM_PO7:
11102 ! 
11103 ! When called, make sure all files are open first.
11104 ! Most vars may be assumed as one-way, except for I$, which may map
11105 ! to BUF_FS1$.  G0 maps to G[0].
11106 ! 
11107 ENTER FLN_ASJ,FLN_FS1,FLN_FS2,FLN_PO3,FLN_FMP,X3$,X4$,RT_PARM$,HAS_DATA_REP,P1$,G$,G0,I$
11110 ! 
11112 ! 
11113 ! G0 is the 'receive now qty' (was 'bill now qty' for invoices).
11114 ! "EXTRACTs" are used here to keep folks from accessing the order from
11115 ! order entry while the update is running.
11116 ! 
11117 IF G0=0 THEN GOTO L1100
11120 IF G$(1,8)<>MID(I$,118,8) THEN CALL "UPDFS1;EXTRACTBYKEY",FLN_FS1,0,G$(1,8),"","","","",I$,I{ALL},FOUND_FS1,BUSY_FS1; IF NOT(FOUND_FS1) THEN GOTO L1100
11140 CALL "UPDFS2;EXTRACTBYKEY",FLN_FS2,0,G$(1,8),G$(20,3),"","","",B$,B{ALL},FOUND_FS2,BUSY_FS2; IF NOT(FOUND_FS2) THEN GOTO L1100
11142 ! 
11143 ! special shipping, shipto seq code.
11144 ! 
11145 IF B$(18,1)="Y" AND G$(23,1)=" " THEN GOTO L1100
11147 ! 
11148 ! Line type - message
11149 ! 
11150 IF B$(155,1)="M" THEN GOTO L1100
11157 ! 
11158 ! Line type - special - checks order history flag in FMP"X"
11159 ! 
11160 IF B$(155,1)="S" THEN GOSUB L2700; IF X$<>"Y" THEN GOTO L1100
11180 DIM X$(4); IF B$(18,1)="Y" THEN X$=G$(20,4)
11193 ! 
11194 ! C$(9,8)+" " -> G$(1,9) because Z[5]-PO3 & G$-PO7 should be
11195 ! the same family of indicies.
11196 ! 
11197 ! Except it appears that pos 9 of that key in PO3 is always blank!
11198 ! 
11200 ! CALL "UPDPO3;READBYKEY",FLN_PO3,0,G$(1,9),X$,"","","",E$,E{ALL},FOUND_PO3;
11201 CALL "UPDPO3;READBYKEY",FLN_PO3,0,G$(1,8)," ",X$,"","",E$,E{ALL},FOUND_PO3; IF NOT(FOUND_PO3) THEN GOTO L1100
11497 ! 
11498 ! build data for ASJ file, then write it.
11499 ! 
11500 GOSUB L3000
11600 ! 
11610 ! handle case where order qty is modified/raised
11620 ! and then repeatedly received :(
11630 ! 
11640 CALL "UPDASJ;READBYKEY",FLN_ASJ,0,A$(PKEY_POS,PKEY_LEN),"","","","",Q$,Q{ALL},FOUND_Q; IF NOT(FOUND_Q) THEN GOTO WRITE_ASJ
11650 A[0]+=Q[0]
11830 ! 
11840 WRITE_ASJ:
11850 CALL "UPDASJ;UPDATE",FLN_ASJ,A$,A{ALL},BUSY_ASJ
11855 IF RT_PARM$<>"" THEN CUST$=A$(1,10); CALL "RT2WOC",ERR=*NEXT,X3$,X4$,CUST$,"ASJ...","U",A$(1,28)
11990 GOTO L1100
11998 L1100:
11999 EXIT 
12000 REM 
12400 L2400:
12401 REM "Set Seq no for FS6 from FS2 line #
12410 F9=NUM(B$(6,3),ERR=*NEXT)
12415 IF F9>=90 THEN F9=F9+10
12420 IF F9>206 THEN F9=206
12425 IF HAS_DATA_REP AND CHR(F9+48)="\" THEN F9=206
12430 A$(19,1)=CHR(F9+48)
12440 RETURN 
12600 L2600:
12601 REM "Set T$ to type for FS6 records
12610 T$=" "
12620 ON POS(B$(155,1)=" CINS") GOTO L2690,L2630,L2640,L2650,L2660,L2670
12630 L2630: T$="B"; GOTO L2680
12640 L2640: T$="D"; GOTO L2680
12650 L2650: T$="F"; GOTO L2680
12660 L2660: T$="H"; GOTO L2680
12670 L2670: T$="J"; GOTO L2680
12680 L2680:
12685 IF P1$(196,1)="Y" AND B$(10,4)<>"    " AND B$(10,4)<"9000" THEN T$="B"; REM "For BFS
12690 L2690:
12691 RETURN 
12700 L2700:
12701 REM "Order History on Specials? <3.4>
12710 X$="Y"
12720 CALL "UPDFMP;READBYKEY",FLN_FMP,0,"X",B$(19,10),"","","",X$,X{ALL},FOUND_FMP; IF NOT(FOUND_FMP) THEN GOTO L2740
12730 X$=X$(59,1)
12740 L2740:RETURN 
13000 L3000:
13001 REM "Fill in record
13010 GOSUB V_INIT
13011 CALL SELF$+"CLEAR_FIELDS",A$,A{ALL}
13017 ! 
13018 ! l2400 - set a$(19,1)-seq; l2600 - set T$ -> a$(39,1)-order hist type.
13019 ! 
13020 GOSUB L2400; GOSUB L2600
13037 ! 
13038 ! customer code,  order #,         shipto seq,       invoice #
13039 ! 
13040 A$(1,10)=I$(6,10),A$(11,8)=G$(1,8),A$(20,1)=G$(23,1),A$(21,8)=DIM(8)
13047 ! 
13048 ! item code, order history type.
13049 ! 
13050 A$(29,10)=B$(19,10),A$(39,1)=T$
13057 ! 
13058 ! ship-to-code(loc_type+loc_code), ship-to-name(loc_desc).
13059 ! 
13060 A$(40,5)=E$(11,5),A$(45,35)=E$(225,35)
13077 ! 
13078 ! ship-to-attn, loc_addr_(n), ... FOB ... ship_with.
13079 ! 
13080 A$(80,150)=E$(16,150)
13097 ! 
13098 ! mark_for + ship_via_desc.
13099 ! 
13100 A$(230,50)=E$(175,50)
13110 ! 
13119 REM "skip if E$ is short
13120 IF LEN(E$)>=268 THEN A$(280,9)=E$(260,9) ! cost code
13121 ! 
13140 A$(289,6)=DIM(6) ! invoice date
13160 A$(295,6)=G$(39,6) ! receipt date (was 'date shipped' for invoices)
13200 A$(301,15)=E$(210,15) ! ship via description (why twice?)
13220 A$(316,4)=I$(89,4),A$(320,4)=I$(93,4) ! csr, sper_code (salesprsn)
13240 A[0]=G0 ! receive now qty (was 'bill now qty' for invoices)
13290 RETURN 
56000 REM "5.5 - 07/19/06 - 9.654166 - bam - SSP# 168612
56001 REM "168612-Need to add Bill as shipped orders to update the ASJ file   
