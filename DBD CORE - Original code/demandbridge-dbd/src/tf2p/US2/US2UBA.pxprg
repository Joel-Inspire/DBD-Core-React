0010 REM "<US2UBA> Import Management Software Processing for United only
0020 SETESC 9300; SETERR 9000
0035 REM "5.5 - 03/05/07 - 13.41 - mhe - SSP# 205703
0040 REM "Copyright 2007 TopForm Software Inc.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0085 REM "A string array is used to pass info back and forth between called pgms, it's maintained by the called pgms (READ,WRITE,etc), in this pgm it's called either READ${ALL} or WRITE${ALL}. It's DIM'd to 10 at this time, [1]=text file name, [2]=used in write methods to hold last record, [3]=used in IM2G03, [4]&[5]=used in IM2ST0, [10]=used to hold messages to be used in this pgm passed from one of the called pgms.  [1],[2],[10] should only be used for the purposes described here.  The others can be used depending on which pgms being called, each one added should be documented here.
0090 CLEAR ; SETERR 0100; ENTER X3$,X4$,Q0$,Q1$
0100 SETERR 9000
0110 X0$="US2UBA",X1$="Import Management Software Processing"
0120 DIM Z0$(80,"-"),FILE$[20]
0130 K0=20,K1=1
0135 C9=-1
0200 REM "
0240 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,X0,X1,X2; IF X1>0 THEN GOTO 9920
0245 IF X3$(66,1)>"2" THEN PRECISION NUM(X3$(66,1),ERR=0246)
0295 DIM Z0$(80,X3$(235,1)); Z0$=MNM('GS')+Z0$+MNM('GE')
0300 REM "IOLISTS
0320 IM0_IOLIST:IOLIST IM0$
0330 IM1_IOLIST:IOLIST IM1$
0340 IM2_IOLIST:IOLIST IM2$
0350 IM3_IOLIST:IOLIST IM3$
0370 IM4_IOLIST:IOLIST IM4$
0380 IM5_IOLIST:IOLIST IM5$
0390 ZA1_IOLIST:IOLIST ZA1$
0400 ZA0_IOLIST:IOLIST ZA0$,ZA0[0],ZA0[1]
0410 IM8_IOLIST:IOLIST IM8$
0420 IOLIST X3$,X4$,V1$,V3$,V2$,V0$
0430 IOLIST IM9$
0450 IOLIST IMA$
0500 REM "Files
0501 CLOSE (14); OPEN (14,ERR=0502)"IM7"+X3$(9,3); CLOSE (14); GOTO 0503
0502 SERIAL "IM7"+X3$(9,3),0,0
0503 ERASE "IM6"+X3$(9,3),ERR=0504
0504 SERIAL "IM6"+X3$(9,3),0,0
0505 DIM Z[NUM(X3$(60,3))]; GOSUB 7400; IF V0$(1,6)="IM2RAA" THEN Q1$="*"
0510 Z$="02O IM0... 03O IM1... 04O IM9... 05O IM3... 06O IM6... 07O IM4... 08O IM5... 09O ZA1... 10O ZA0... 11O IM8... 12O IM7... 13O ZZPARM  15O IMA...  "
0520 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; ON Z0 GOTO 0521,9900
0530 FID_6$=FN%FID$(Z[6]); CLOSE (Z[6]); OPEN LOCK (Z[6],OPT="TEXT")FID_6$(4,6) ! [205703]-changed FID() to FN%FID$()
0534 FID_12$=FN%FID$(Z[12]); CLOSE (Z[12]); OPEN LOCK (Z[12],OPT="TEXT")FID_12$(4,6) ! [205703]-changed FID() to FN%FID$()
0550 IF Q1$="*" THEN IMPORT_CODE$=V0$(73,10)
0555 FIND (Z[2],KEY=IMPORT_CODE$,DOM=0556)IOL=IM0_IOLIST; GOTO 0560
0556 IF Q1$<>"" THEN MESSAGE$="Specified Import Code "+IMPORT_CODE$+" was not found!"; GOTO EXIT_ERR ELSE PRINT @(0,3),'CE',; INPUT @(0,10),"Import Code to use: ",IMPORT_CODE$; IF CTL=4 THEN GOTO 9900 ELSE IMPORT_CODE$=PAD(UCS(IMPORT_CODE$),10); GOTO 0555
0560 LOGGING_LEVEL=0; LOGGING_LEVEL=NUM(IM0$(331,2),ERR=0561)
0570 MESS_LEVEL=0; MESSAGE$="Starting Import of code "+IM0$(1,10); GOSUB LOG_MESSAGE
0600 REM "
0610 GOSUB 6000
0640 IF Q1$="" THEN CALL "ZZPROM",".Y",X3$,Z,"PROCEED?","","",0; ON Z GOTO 0641,9900
0700 REM "Call Device to get started
0705 FIND (Z[5],KEY=IM0$(41,10),DOM=0706)IOL=IM3_IOLIST; GOTO 0710
0706 MESSAGE$="Device code: "+IM0$(41,10)+" not found!"; GOTO EXIT_ERR
0710 MESS_LEVEL=1,MESSAGE$="Executing Device Code: "+STP(IM0$(41,10),1)+"-"+IM3$(11,30); GOSUB LOG_MESSAGE; MESS_LEVEL=1,MESSAGE$=STP(IM3$(41,120),1); GOSUB LOG_MESSAGE
0715 IF IM3$(41,1)="!" THEN CALL "ZZ2CMD",X3$,X4$,STP(IM3$(42,119),1),"","IN",COMM_CODE,COMM_CODE$; GOTO DEVICE_CODE_DONE; REM "WO144867, call system command program 
0720 CLOSE (14); OPEN (14)"< "+STP(IM3$(41,120),1); REM "Use open with SHELL option to do system call so the output won't go to the screen
0721 READ (14,END=0722)TMP$; GOTO 0721
0722 CLOSE (14)
0724 DEVICE_CODE_DONE:
0725 MESS_LEVEL=1,MESSAGE$="Finished Device Code: "+IM0$(41,10); GOSUB LOG_MESSAGE
0750 REM "Get Read Method and open file to be sure it exists
0755 FIND (Z[7],KEY=IM0$(111,10),DOM=0756)IOL=IM4_IOLIST; GOTO 0760
0756 MESSAGE$="Read Method: "+IM0$(111,10)+" not found!"; GOTO EXIT_ERR
0760 READ_METHOD$=STP(IM4$(41,8),1),READ_OPTION$=STP(IM0$(121,60),1)
0800 REM "Load FIELDS$[] from IM1 records
0805 DIM FIELDS$[100]; FINDEX=0; READ (Z[3],KEY=IMPORT_CODE$,DOM=0806)
0810 READ (Z[3],END=0840)IOL=IM1_IOLIST; IF IM1$(1,LEN(IMPORT_CODE$))<>IMPORT_CODE$ THEN GOTO 0840
0815 FIELDS$[FINDEX]=IM1$; FINDEX=FINDEX+1
0835 GOTO 0810
0840 IF FINDEX=0 THEN MESSAGE$="No field definitions found!"; GOTO EXIT_ERR
0850 REM "Load Bert fields into BERT$[] and BERT_KEY$, pos (,20) in BERT_KEY$ gives index into BERT$[]
0855 DIM BERT$[100]; BERT_KEY$="",BINDEX=0; READ (Z[9],KEY=IM0$(311,20),DOM=0856)
0860 READ (Z[9],END=0890)IOL=ZA1_IOLIST; IF ZA1$(1,20)<>IM0$(311,20) THEN GOTO 0890
0865 BERT$[BINDEX]=ZA1$; BERT_KEY$=BERT_KEY$+ZA1$(21,20),BINDEX=BINDEX+1
0885 GOTO 0860
0890 REM "Get ZA0 info
0895 DIM ZA0[1]; READ (Z[10],KEY=IM0$(311,20),DOM=0896)IOL=ZA0_IOLIST; GOTO 0897
0896 MESSAGE$="Bert Database: "+IM0$(311,20)+" not found!"; GOTO EXIT_ERR
0900 REM "Get Write Method
0905 FIND (Z[11],KEY=IM0$(181,10),DOM=0906)IOL=IM8_IOLIST; GOTO 0910
0906 MESSAGE$="Write Method: "+IM0$(181,10)+" not found!"; GOTO EXIT_ERR
0910 WRITE_METHOD$=STP(IM8$(41,8),1),WRITE_OPTION$=STP(IM0$(191,60),1)
0929 REM "Open output file as TMP+fid(0)
0930 CALL WRITE_METHOD$,X3$,X4$,"O"+"TMP"+FID(0),WRITE_OPTION$,"",RET_CODE,WRITE${ALL}
0935 IF RET_CODE<>0 THEN MESS_LEVEL=0,MESSAGE$="Unable to open output file "+"TMP"+FID(0)+" due to error code "+STR(RET_CODE); GOTO EXIT_ERR
1000 REM "Get list of files to process
1002 I=0
1004 FILE_SPEC$=STP(IM0$(51,60),1)
1005 MESS_LEVEL=1,MESSAGE$="Checking for files using filename "+FILE_SPEC$; GOSUB LOG_MESSAGE
1010 CALL "ZZ2BLS","D0:"+FILE_SPEC$,"S",F$
1012 MESS_LEVEL=1,MESSAGE$="FILE LIST RETURNED: "+F$; GOSUB LOG_MESSAGE
1015 P=POS(":"=F$); IF P=0 THEN GOTO 5000
1020 F1$=F$(P+1); P1=POS(":"=F1$); IF P1>0 THEN F$=F1$(P1-2),F1$=F1$(1,P1-3) ELSE F$=""
1030 MESS_LEVEL=1,MESSAGE$="Processing file: "+F1$; GOSUB LOG_MESSAGE
1035 MESS_LEVEL=2,MESSAGE$="Call "+READ_METHOD$+" to open file: "+F1$+" with options: "+STP(IM0$(121,60),1); GOSUB LOG_MESSAGE
1036 CLOSE (Z[15]); OPEN (Z[15])"IMA"+X4$(1,3)
1040 GOSUB 8100
1050 CALL READ_METHOD$,X3$,X4$,"O"+F1$,READ_OPTION$,"",RET_CODE,READ${ALL}
1055 IF RET_CODE<>0 THEN MESS_LEVEL=0,MESSAGE$="Unable to open file "+F1$+" due to error code "+STR(RET_CODE); GOSUB LOG_MESSAGE; GOTO 1015
1100 REM "Read records in
1105 CALL READ_METHOD$,X3$,X4$,"R",READ_OPTION$,RECORD$,RET_CODE,READ${ALL}
1106 IF READ$[10]>"" AND RET_CODE>2 THEN MESS_LEVEL=1,MESSAGE$=READ$[10]; GOSUB LOG_MESSAGE; REM "Message coming back from READ pgm, possibly from a pgm called from READ pgm, need to record
1108 IF RET_CODE=2 THEN GOTO 1195; REM "if end of file go to next file
1109 MESS_LEVEL=9,MESSAGE$="GOT RECORD:"+RECORD$+"|"; GOSUB LOG_MESSAGE
1110 DIM OUTPUT$(ZA0[0]),OUT$[FINDEX],TMP_IM9$[40],ALT$[FINDEX]
1115 REC_INDEX=1,REJECT_RECORD=0
1120 DIM OUT$[FINDEX]
1121 L=1
1122 IF LEN(RECORD$)<137 THEN RECORD$=RECORD$+"                                         "
1123 C=C+1; IF MOD(C,T0)=1 THEN GOSUB 8150
1125 FOR I=1 TO FINDEX; REM "Build array from the record just read in. No formatting with be done to the array at this time.  It will look exactly like the record just read in
1126 FLD$=FIELDS$[I-1]
1128 IF LEN(RECORD$)<158 THEN RECORD$=RECORD$+"                           "
1130 OUT$[I]=RECORD$(L,NUM(FLD$(14,3)))
1135 L=L+NUM(FLD$(14,3))
1140 NEXT I
1145 REM "IF OUT$[2]= ALL " " THEN GOTO 01105
1150 REM "Field sep.  Look thru fields$[all] to see if any of the out$[all] nedds to have any field sep checks preformed on it.  This is the only thing done to the array out$ at this time.  If no field sep are used the file array will remain the same.
1160 FOR I=1 TO FINDEX
1165 FLD$=FIELDS$[I-1]
1170 IF STP(FLD$(14,3),3," ")="" OR FN%NMV(FLD$(14,3))=0 THEN GOSUB GET_ELEMENT_WITH_FS ELSE GOTO 1171
1175 MESS_LEVEL=10,MESSAGE$="Processing field# "+FLD$(11,3)+" "+FLD$; GOSUB LOG_MESSAGE
1180 NEXT I
1182 GOTO 2000
1195 GOTO 1015
2000 REM "Manipulate data in format field
2005 DIM IMA$(30)
2010 READ (Z[15],KEY=IM0$(1,10),DOM=2011)
2015 FOR I=1 TO 40
2020 K$=KEY(Z[15],END=2021); GOTO 2022
2021 EXITTO 3500
2030 IF K$(1,10)<>IM0$(1,10) THEN EXITTO 3500
2040 READ (Z[15],KEY=K$,DOM=2100)IOL=0450
2050 REM "Break up value in IMA$(24,40)
2060 FOR B=1 TO 40
2070 X=POS("+"=IMA$(24,40)); IF X=0 THEN TMP_VAL$=STP(IMA$(24,40),1) ELSE TMP_VAL$=IMA$(24,X-1); IMA$(24,40)=IMA$(24+X,40-X); IF X=0 THEN EXITTO 2100; REM "WAS 2095
2080 J=POS("$"=TMP_VAL$); IF J>0 THEN TMP_VAL$=OUT$[NUM(TMP_VAL$(2))]
2085 IF POS("#"=TMP_VAL$)=1 AND LEN(TMP_VAL$)=4 THEN CODE$=ALT$[NUM(TMP_VAL$(2))]; TMP_VAL$=ALT$[NUM(TMP_VAL$(2))]; REM "Was LET TMP_VAL$=OUT$[I], Changed WO91521
2090 K=POS("'"=TMP_VAL$); IF K>0 THEN TMP_VAL$=TMP_VAL$(2,LEN(TMP_VAL$)-2)
2094 REM "LET TMP_VAL$=TMP_VAL$+OUT$[NUM(IMA$(25,39))]
2095 VALUE$=VALUE$+TMP_VAL$; TMP_VAL$=""
2096 IF X=0 THEN EXITTO 2100
2098 NEXT B
2100 REM "Any formating that need to be done to the array will be done here. This is for the first format option
2110 READ (Z[8],KEY=IMA$(14,10),DOM=2190)IOL=0380
2120 FORMAT_METHOD$=STP(IM5$(41,8),1)
2125 MESS_LEVEL=10,MESSAGE$="FIELD# "+K$(11,3)+" VALUE IS "+VALUE$+"|"; GOSUB LOG_MESSAGE
2130 OLD_VALUE$=VALUE$
2135 OPTION$=CODE$
2140 EXECUTE "2141 CALL FORMAT_METHOD$,ERR=2142,X3$,X4$,OPTION$,OLD_VALUE$,VALUE$,A"+IMA$(11,3)+"_1$[ALL],RETURN_CODE$"
2141 CALL FORMAT_METHOD$,ERR=2142,X3$,X4$,OPTION$,OLD_VALUE$,VALUE$,A001_1${ALL},RETURN_CODE$
2143 MESS_LEVEL=10,MESSAGE$="Called "+STP(IMA$(14,10),1)+" with options:"+STP(FLD$(37,20),1)+"| old_value$="+OLD_VALUE$+"| new value="+VALUE$+"| Return code: "+STR(RETURN_CODE); GOSUB LOG_MESSAGE
2145 ALT$[I]=VALUE$,VALUE$=""
2160 NEXT I
2190 GOTO 3500
3500 REM "Get Bert info using BERT_KEY$ and BERT$[] and put field into OUTPUT$ if BERT field is blank then just skip it, the field is not being moved into OUTPUT$
3510 READ (Z[4],KEY=IM0$(1,10)+ZA0$(1,20),DOM=3511)
3515 K$=KEY(Z[4],END=3700)
3517 IF K$(1,10)<>IM0$(1,10) THEN GOTO 3700
3520 READ (Z[4],KEY=K$)IOL=0430
3525 READ (Z[9],KEY=K$(11,20)+K$(31,20),DOM=3700)TMP$
3526 REM "IF TMP$(21,20)="CLASSIFICATION CODES" THEN ESCAPE
3530 L=0; DIM TMP_IM9$[40]
3540 FOR I=1 TO 40
3550 X=POS("+"=IM9$(51,40)); IF X=0 THEN TMP_IM9$[I]=STP(IM9$(51,40),1) ELSE TMP_IM9$[I]=IM9$(51,X-1); IM9$(51,40)=IM9$(51+X,40-X); IF X=0 THEN EXITTO 4080
3554 IF X=0 THEN EXITTO 3580
3555 NEXT I
3600 REM "Build out file
3610 FOR I=1 TO 40
3620 IF POS("$"=TMP_IM9$[I])>0 THEN JL$=OUT$[NUM(TMP_IM9$[I](2))]; REM " ELSE LET JL$=JL$+TMP_IM9$[I]
3622 IF POS("#"=TMP_IM9$[I])>0 THEN JL$=ALT$[NUM(TMP_IM9$[I](2))]; REM "ELSE LET JL$=JL$+TMP_IM9$[I]
3623 IF POS("!"=TMP_IM9$[I])>0 THEN JL$=TMP_IM9$[I](2); IF JL$="SYSDATE" THEN JL$=X3$(21,6)
3625 IF POS("'"=TMP_IM9$[I])>0 THEN JL$=TMP_IM9$[I](2,LEN(TMP_IM9$[I])-2); REM "JL$(2,LEN(JL$)-2)
3626 JL_FORMAT$=JL_FORMAT$+JL$,JL$=""
3630 NEXT I
3635 OUTPUT$(NUM(TMP$(90,3)),NUM(TMP$(93,3)))=JL_FORMAT$
3637 JL_FORMAT$=""
3640 GOTO 3515
3700 REM "Build output file based on bert settings and arrays out$ and alt$
3730 MESS_LEVEL=10,MESSAGE$="Field# "+K$(11,3)+" value before BERT formatting is "+VALUE$+"|"; GOSUB LOG_MESSAGE
3740 REM "LET BINDEX=POS(FLD$(97,20)=BERT_KEY$,20); IF BINDEX=0 THEN LET REJECT_RECORD=1, MESSAGE$="FIELD "+FLD$(11,3)+" BERT FIELD:"+FLD$(97,20)+"| NOT FOUND"+"!"; GOSUB LOG_MESSAGE; GOTO 04190 ELSE LET BINDEX=(BINDEX-1)/20
3760 MESS_LEVEL=10,MESSAGE$="Field# "+K$(11,3)+" value after BERT formatting is "+VALUE$+"|"; GOSUB LOG_MESSAGE
3775 IF REJECT_RECORD THEN WRITE (Z[12])IMPORT_CODE$+RECORD$ ELSE CALL WRITE_METHOD$,X3$,X4$,"W",WRITE_OPTIONS$,OUTPUT$,RET_CODE,WRITE${ALL}
3790 GOTO 1105
4800 GET_ELEMENT_WITH_FS:REM "Given field sep string, find field, then increment REC_INDEX
4805 FS$=STP(FLD$(17,10),1); IF FS$(1,1)="$" THEN FS$=ATH(FS$(2),ERR=GET_ELEMENT_WITH_FS_END); REM "ssp#109441 if 1st char is $ then use rest as hex value, if any error then don't do.
4810 IF FLD$(11,1)="X" THEN GOTO GET_ELEMENT_WITH_FS_END
4811 FS_RECORD$=RECORD$(REC_INDEX)
4812 Q=POS(FS$=FS_RECORD$)
4813 IF Q=0 THEN OUT$[I]=FS_RECORD$; GOTO GET_ELEMENT_WITH_FS_END
4815 OUT$[I]=RECORD$(REC_INDEX,Q-1),REC_INDEX=REC_INDEX+Q
4890 GET_ELEMENT_WITH_FS_END:RETURN 
5000 REM "EOJ
5003 CALL WRITE_METHOD$,X3$,X4$,"C",WRITE_OPTION$,"",RET_CODE,WRITE${ALL}
5004 ERASE STP(IM0$(251,60),1),ERR=5005; GOTO 5004
5005 RENAME "TMP"+FID(0),STP(IM0$(251,60),1)
5010 PRINT @(0,15),'CE',
5015 C=T; GOSUB 8150
5020 IF Q1$="" THEN CALL "ZZPROM",".4",X3$,Z,"PROCESS COMPLETE!!","","",0
5030 IF Q1$="*" THEN Y4$="IM2RAA"
5035 PROCESSED$="Y"
5040 GOTO 9900
6000 REM "BACKGROUND
6005 PRINT (0,ERR=6016)'SB',
6020 PRINT @(0,3),'CE',@(10,5),"Import code: ",IMPORT_CODE$,@(23,6),IM0$(11,30),
6165 PRINT (0,ERR=6166)'SF',
6190 RETURN 
7400 REM "Read report selection parameters"
7410 Z$="12O ZZP     "
7420 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,0; ON Z0 GOTO 7421,9900
7430 Y3$=X3$(1,6),Y4$=X3$(178,7)
7450 READ (Z[12],KEY=X3$(1,8),DOM=7451)IOL=0420
7480 X3$(178,7)=Y4$,V0=NUM(V0$(71,1)),W3$=V0$(19,POS("   "=V0$(19,40)+"   ")-1)
7485 FOR U1=1 TO LEN(V1$); IF V1$(U1,1)=" " THEN V1$(U1,1)="."; NEXT U1 ELSE NEXT U1
7490 RETURN 
7500 REM "Convert date q$ into q0$
7501 REM "Q$ in YYYYMMDD format
7505 Q0$=""
7510 IF LEN(Q$)<8 THEN GOTO 7545 ELSE Q1$=Q$(7,2)
7515 IF Q1$<"50" THEN Q1$="20"+Q1$ ELSE Q1$="19"+Q1$
7520 Q0$=CHR(NUM(Q1$(1,3),ERR=7521)-125)+Q1$(4,1)+Q$(1,2)+Q$(4,2)
7545 RETURN 
7550 EXIT_ERR:REM "Log Serious Error, then leave
7555 MESSAGE$="**FATAL ERROR**"+MESSAGE$
7560 MESS_LEVEL=0; GOSUB LOG_MESSAGE
7595 EXIT_ERR_END:GOTO 9900
7600 LOG_MESSAGE:REM "Write a message to the log file IM6
7601 REM "only record MESS_LEVEL <= LOGGING_LEVEL from IM0, levels 0 are always logged. Clear message when done and set MESS_LEVEL to -1 to indicate it has not been set; MESS_LEVEL = -1 are not logged
7605 IF (MESS_LEVEL=0 OR MESS_LEVEL<=LOGGING_LEVEL) AND MESS_LEVEL<>-1 AND MESSAGE$<>"" THEN PRINT (Z[6])FN%CDS$+" "+STR(MESS_LEVEL:"00")+" "+MESSAGE$
7620 MESS_LEVEL=-1; MESSAGE$=""
7645 LOG_MESSAGE_END:RETURN 
8100 REM "GOSUB here, once at the beginning, after the background is set and before the Proceed? question.  Set T to total # to do (by calling ZZINFO) and T0 to the reporting interval (report every T0 number of records) this is typically 2% of total; This also prints a message (@8115), so adjust accordingly
8105 T=0
8110 CLOSE (Z[14]); OPEN LOCK (Z[14],OPT="TEXT")F1$
8113 REM "LET T$=KEY(Z[14],END=08125)
8115 READ (Z[14],END=8125)A$
8117 T=T+1
8119 GOTO 8113
8125 CLOSE (Z[14])
8126 PRINT @(0,9),"There are "+STR(T)+" records to process"
8129 REM "Set T0, we make sure T0>1, because later on we MOD and look for a value of 1.  If T0 is 1, then nothing would get reported.  We look for a result of 1 because this causes the first record to automatically start the reporting intead of waiting until the T0'th record to get the first report
8130 T0=INT(T*.02); IF T0<=1 THEN T0=2
8145 RETURN 
8150 REM "Call this each time to update the bar graph. Display horiz. bar graph given total #, T and current #,C, and time counter T1 (t1 is init'ed here and used here, just don't use it somewhere else)
8155 CALL "ZZBARG",X3$,"HG",19,10,50,T1,T,C
8195 RETURN 
9000 REM "ERROR PROCESSING
9005 IF ERR=69 THEN GOTO 9500
9010 Y5=ERR,Y6=TCB(5)
9015 SETERR 9016; Y8$=LST(PGM(Y6))
9016 SETERR 9000
9040 CALL "ZZERRM",Y8$,X0$,Y7$,X3$,Y5,Y6,Y7,Y8,0
9045 REM 
9050 ON Y7 GOTO 9060,9100,9800,9070,9090
9055 REM 
9060 RETRY 
9070 SETERR 9080
9075 EXECUTE Y7$
9080 SETERR 9000; RETRY 
9090 SETERR 0000; RETRY 
9100 REM " TRANSFER CONTROL
9180 GOTO 0990
9190 GOTO 9800
9300 SETESC 9350
9310 SETERR 9350
9315 IF X3$(47,1)="N" THEN RETURN ELSE SETESC 0000; RETURN 
9350 SETERR 9000; RETURN 
9500 REM "CTRL LOGIC
9510 SETERR 9000; GOSUB 6400
9520 ON C9 GOTO 1140,2040
9900 REM "END PROGRAM
9910 CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
9919 IF POS(" "<>V0$(92,8))>0 AND PROCESSED$="Y" THEN CALL V0$(92,8),ERR=9920,X3$,X4$,"",V0$(73,10),"",DATA_ARRAY${ALL},RET_CODE; IF RET_CODE=1 THEN RUN "ZMENU"
9930 SETERR 9940; IF Y4$<>"" THEN RUN Y4$
9940 SETESC 9350
9950 RUN "ZMENU"
9999 END 
56000 REM + Modification History
56002 REM "205703-Oracle - FID and FIB calls, replace with FN%FID$ and FN%FIB$
