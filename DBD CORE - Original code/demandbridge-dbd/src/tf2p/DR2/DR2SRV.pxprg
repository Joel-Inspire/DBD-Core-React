0010 ! <DR2SRV>Data Replication Server
0035 REM "5.7 - 02/23/21 - 15.407556 - crg - SSP# 307335
0037 REM "307335-DBD-156 - Suppress false error messages                     
0040 REM "Copyright 2021 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0100 BEGIN EXCEPT QUE_CODE,QUE_CODE$ ! 263785
0110 SETERR 9000
0120 IF NOT(BKG) AND NOT(GUI_MODE) THEN PRINT 'CS',
0129 ! Adding chan 6,7: memory files for filters - 223557
0130 CLOSE (1),(2),(3),(4),(5),(6),(7),(8)
0150 ! Open log
0151 FID0$=FID(0) ! 282624-To keep track of session id
0153 SERVER_NUM$="1",LOG_FILE$="DR2SRV"+SERVER_NUM$+"."+FN%PRINT_DATETIME$(0,"%Y%Mz%Dz") ! SSP#295220
0155 OPEN_LOG:SERIAL LOG_FILE$,ERR=*NEXT ! SSP#295220
0160 OPEN LOCK (3,ERR=*NEXT)LOG_FILE$; GOTO AFTER_OPEN ! SSP#295220
0165 IF ERR<>0 THEN GOTO 9900 ELSE SERVER_NUM$=STR(NUM(SERVER_NUM$,ERR=9900)+1,ERR=9900),LOG_FILE$="DR2SRV"+SERVER_NUM$+"."+FN%PRINT_DATETIME$(0,"%Y%Mz%Dz"); GOTO OPEN_LOG ! SSP#295220
0185 AFTER_OPEN:! log file is open now
0195 %DR_SUSPEND=1 ! Prevent any additions to datarep queue from within this process, only dequeing allowed
0200 ! Get Arguements
0210 FOR I=0 TO NAR
0215 TMP$=ARG(I)
0220 IF MSK(UCS(TMP$),"COMP=") THEN %C$=MID(TMP$,MSL+1); CONTINUE ! Set company
0225 IF MSK(UCS(TMP$),"DO_ERR_QUE") THEN DO_ERR_QUE=1; CONTINUE ! Process ERR que only
0230 IF MSK(UCS(TMP$),"CODE=") THEN QUE_CODE$=PAD(MID(TMP$,MSL+1),3,1); QUE_CODE=1; CONTINUE ! Do only one Que Code
0245 NEXT I
0249 ! 
0250 IF NOT(BKG) AND NOT(GUI_MODE) THEN IF QUE_CODE=0 AND DO_ERR_QUE=0 THEN INPUT "Enter Queue Code: ",QUE_CODE$; IF NOT(NUL(QUE_CODE$)) THEN QUE_CODE$=PAD(QUE_CODE$,3),QUE_CODE=1 ! 263785 - Allow user to provide queue code if running in CHUI and interactive mode (invoked from menu option D/R-P2, not command line invocation)
0270 IF QUE_CODE=0 AND DO_ERR_QUE=0 THEN QUE_CODE=1,QUE_CODE$=DIM(3) ! always set to do blank only
0275 IF NUL(PFX(-1)) THEN PREFIX FILE "PFX"+%C$,ERR=*NEXT
0300 FILE_NAME$="DR2SRV",KEY$="Company="+%C$,ACTION$="START"; DIM DR1$(500,"Y"); GOSUB 4200
0310 FILE_NAME$="DR2SRV",KEY$=PFX(-1),ACTION$="PREFIX"; DIM DR1$(500,"Y"); GOSUB 4200
0495 TMP_DRCAP$="Data Replication Server "+SERVER_NUM$+"; Log: "+PTH(3); IF NOT(NUL(QUE_CODE$)) THEN TMP_DRCAP$+="; Que: "+QUE_CODE$ END_IF ; IF DO_ERR_QUE THEN TMP_DRCAP$+=" (Err Que Mode)" END_IF ; PRINT (0,ERR=*NEXT)'CAPTION'(TMP_DRCAP$), ! 261127
0497 GOSUB UPDATE_STATUS ! Initial status update when datarep process is starting up
0500 ! Open files
0510 IF DO_ERR_QUE THEN OPEN (1)"DR3"+%C$ ELSE OPEN (1)"DR2"+%C$
0520 OPEN (2)"DR1"+%C$
0530 OPEN (4)"DR3"+%C$
0535 OPEN (5)"ZZPARM"
0536 DIM DR_PARM$(1024); FIND (5,KEY=%C$+"D/R",DOM=*NEXT)DR_PARM$
0538 RESET_AFTER_COUNT=10000; IF NOT(NUL(DR_PARM$(7,4))) THEN RESET_AFTER_COUNT=NUM(DR_PARM$(7,4),ERR=*NEXT)
0539 EXT_ERR_CMD$=STP(DR_PARM$(11,120),1)
0540 SYS_CONN_MAX_AGE=0; IF NOT(NUL(DR_PARM$(131,4))) THEN SYS_CONN_MAX_AGE=NUM(DR_PARM$(131,4),ERR=*NEXT) ! 255362-Maximum age of a connection in seconds, systemwide setting
0541 SERVER_MAX_AGE=0; IF NOT(NUL(DR_PARM$(135,4))) THEN SERVER_MAX_AGE=NUM(DR_PARM$(135,4),ERR=*NEXT); MX=TMR(0) ! 255362-Maximum age of a running server process in seconds, systemwide setting
0545 OPEN (6)"*MEMORY*" ! Target filters Enabled?
0546 OPEN (7)"*MEMORY*" ! Target specific filter field positions
0547 CALL "DRGQRF;GET_SUPPORTED_FIELDS",FFIELDS${ALL},FF_COUNT
0548 OPEN (8)"DRF"+%C$; DRF=8
0549 ! 
1000 ! Process Data Replication Queue
1001 IF SERVER_MAX_AGE THEN IF TMR(1)>SERVER_MAX_AGE THEN GOTO 0001 ! 255362-If server max age is set, and if age exceeded, reset server
1002 FIND (5,KEY=%C$+"DR2",DOM=*NEXT)FRZK$,FRZ_FID$,FRZ_TS$; GOSUB PAUSE_MODE ! Freeze mode, queue analyzer has created a pause record
1004 ! if que_code set, then only process then on que code else If doing error queue get next record, so we don't reprocess the same record if we got another error on it (new additions had better be later in time and date) else always get first key
1005 IF QUE_CODE THEN READ (1,KEY=QUE_CODE$,DOM=*PROCEED); K$=KEY(1,END=NEXT_REC); IF MID(K$,1,LEN(QUE_CODE$))<>QUE_CODE$ THEN GOTO NEXT_REC END_IF ELSE IF DO_ERR_QUE THEN K$=KEY(1,END=NEXT_REC) ELSE K$=KEF(1,END=NEXT_REC)
1010 EXTRACT RECORD (1,KEY=K$,DOM=1005,BSY=*NEXT,TIM=0)ORIG$; A$=ORIG$; GOTO GOT_RECORD
1012 K$=KEN(1,END=1315); GOTO 1010
1015 GOT_RECORD: IDLE_COUNT=0; RECORD_COUNT+=1; IF RECORD_COUNT=RESET_AFTER_COUNT THEN IF NOT(GUI_MODE) THEN GOTO 0001 ELSE RECORD_COUNT=0; LIST_BOX LOAD LB_LINE.CTL,0,""; GOTO 0110 ! 222352-Idle seconds counter
1017 ERR_ON_REC=0; DEF MSG(-1) DELETE ! 304440
1020 SPOS=POS(SEP=A$); IF SPOS=0 THEN GOTO DONE ELSE QUE_KEY$=MID(A$,1,SPOS-1),A$=MID(A$,SPOS+1)
1022 IF DO_ERR_QUE THEN SPOS=POS(SEP=A$); IF SPOS=0 THEN GOTO DONE ELSE OLD_ERROR$=MID(A$,1,SPOS-1),A$=MID(A$,SPOS+1) ! If processing error que remove old error message
1025 SPOS=POS(SEP=A$); IF SPOS=0 THEN GOTO DONE ELSE ACTION$=MID(A$,1,SPOS-1),A$=MID(A$,SPOS+1)
1055 SPOS=POS(SEP=A$); IF SPOS=0 THEN GOTO DONE ELSE FILE_NAME$=MID(A$,1,SPOS-1),A$=MID(A$,SPOS+1) ! get filename
1060 SPOS=POS(SEP=A$); IF SPOS=0 THEN GOTO DONE ELSE KEY$=A$(1,SPOS-1),A$=MID(A$,SPOS+1) ! get filename
1090 ! begin processing
1095 GOSUB OPEN_REP_FILE; IF OUTPUT_PORT=0 THEN ERR_MSG$="Error on open of output port: "+STR(OPEN_ERR)+" | "+DR1$; GOSUB LOG_ACTIVITY; GOTO DONE
1110 IF DR1$(301,1)<>"Y" THEN ACTION$="S"; GOSUB LOG_ACTIVITY; GOTO DONE ! replication may have been turned off, if so skip now
1120 FILTERED=0; GOSUB APPLY_FILTERS; IF FILTERED THEN ACTION$="F"; GOSUB LOG_ACTIVITY; GOTO DONE ! 223557
1150 SWITCH ACTION$
1160 CASE "W"; GOSUB WRITE_COMMAND; BREAK
1170 CASE "D"; GOSUB DELETE_COMMAND; BREAK
1195 END SWITCH 
1300 DONE:! remove record now
1305 IF DO_ERR_QUE AND ERR_ON_REC THEN GOTO *NEXT ELSE REMOVE (1,KEY=K$,DOM=*NEXT) ! If doing err que & err on rec, leave in, otherwise remove it
1310 GOTO 1000
1315 ! End of file reached
1320 NEXT_REC:IF DO_ERR_QUE THEN WAIT 10 ELSE WAIT 1 ! let other processes do some work, wait more if doing err que so we don't waste a lot of effort on them.
1325 IDLE_COUNT+=1; IF IDLE_COUNT>60 OR (DO_ERR_QUE AND IDLE_COUNT>6) THEN IDLE_COUNT=0; PRINT "DR2SRV"+"|"+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+"|"+"IDLE"+"|"; GOSUB UPDATE_STATUS ! 222352-Display idle seconds counter,239718; Periodically update status when idle
1330 GOTO 1000
1400 WRITE_COMMAND:! ^100 Determine file name & open Global file if needed, on channel DR_filename_PORT, file name opened is "DR_filename", prefix path should already be setup to point to external database
1402 ! example of external database info needed:  OPEN (%EIO_PORT,IOL=*,OPT="KEY=GL_ACCT;REC=GL_ACCT:12+GL_ACCT_DESC:35+ACCT_TYPE:1+SUB_LEDGER:1+COST_CODE_TYPE:1+GL1_UNUSED_1:1")"[wdx][odb]test;GL1500"
1500 ! Write out record to the database
1505 ! Only supports keyed files, if sort, index, or serial then extra work needed, Strip off trailing $00$ from a write record or we get error 1
1510 A_OUT$=SUB(A$,$00$,"") ! Remove all nulls or we get error 1
1520 PROCESS_DATES:! Replace TopForm dates (class DATE-KKMMDD) with oracle formatted dates
1525 DSTR$=FNOPT$(OUTPUT_PORT,"TFDATE=","",ERR=ERR_IN_ACTION)
1530 WHILE DSTR$<>""
1532 DPOS=NUM(MID(DSTR$,1,4),ERR=NEXT_DPOS)
1535 IF POS($8A$=MID(A_OUT$,DPOS,6))<>0 THEN GOTO NEXT_DPOS ! Obvious problem, so skip this date
1536 DSEP$=SEP; IF MID(A_OUT$,DPOS+6,1)=SEP THEN DSEP$="" ! If last field then we won't add an additional separator
1537 IF POS(DR1$(347,1)="M ")<>0 THEN IF STP(MID(A_OUT$,DPOS,6))="" THEN A_OUT$=MID(A_OUT$,1,DPOS-1)+DIM(10)+DSEP$+MID(A_OUT$,DPOS+6) ELSE A_OUT$=MID(A_OUT$,1,DPOS-1)+UCS(FNDR_FMT_TFDATE$(MID(A_OUT$,DPOS,6),"%Y-%Mz-%Dz"))+DSEP$+MID(A_OUT$,DPOS+6) ! IF DATE_ERR THEN ERR_MSG$="DATE FORMAT ERROR["+MID(A_OUT$,DPOS,10)+"]" ! MySQL style dates, YYYY-MM-DD
1538 IF DR1$(347,1)="O" THEN IF STP(MID(A_OUT$,DPOS,6))="" THEN A_OUT$=MID(A_OUT$,1,DPOS-1)+DIM(9)+DSEP$+MID(A_OUT$,DPOS+6) ELSE A_OUT$=MID(A_OUT$,1,DPOS-1)+UCS(FNDR_FMT_TFDATE$(MID(A_OUT$,DPOS,6),"%Dz-%Ms-%Yz"))+DSEP$+MID(A_OUT$,DPOS+6) ! IF DATE_ERR THEN ERR_MSG$="DATE FORMAT ERROR["+MID(A_OUT$,DPOS,9)+"]" ! Oracle style date "DD-MM-YY"
1540 NEXT_DPOS: DSTR$=MID(DSTR$,5)
1545 WEND 
1547 IF POS(DR1$(347,1)="M")<>0 THEN A_OUT$=STP(A_OUT$,3,$5C$)
1548 ! IF %C$="101" AND MID(FILE_NAME$,1,3)="FMZ" THEN IF NUL(A_OUT$(26,9)) THEN A_OUT$(26,9)="01-JAN-70" END_IF ; IF NUL(A_OUT$(200,9)) THEN A_OUT$(200,9)="01-JAN-70" END_IF ; IF NUL(A_OUT$(149,9)) THEN A_OUT$(149,9)="01-JAN-70" END_IF  ! 298341
1549 IF POS(DR1$(347,1)="M ")<>0 AND MID(FILE_NAME$,1,3)="ECD" THEN A_OUT$=STP(STP(A_OUT$,1,$8A$),1)
1550 WRITE (OUTPUT_PORT,ERR=*NEXT)A_OUT$; GOSUB LOG_ACTIVITY; GOTO AFTER_WRITE_ERR_CODE
1555 ERR_MSG$="WRITE ERR: "+STR(ERR)+" LINE: "+STR(TCB(5))+" SQL:"; ERR_MSG$+=MSG(-1)+" "+KEN(OUTPUT_PORT,ERR=*NEXT)
1557 GOSUB LOG_ACTIVITY
1560 AFTER_WRITE_ERR_CODE:! Continue normal processing
1595 RETURN 
1599 ! 
1600 DELETE_COMMAND:! Delete the record from the database
1610 PROCESS_KEY_DATES:! Replace TopForm dates (class DATE-KKMMDD) with oracle formatted dates
1612 NEW_KEY$=KEY$; DSTR$=FNOPT$(OUTPUT_PORT,"TFDATE=","",ERR=ERR_IN_ACTION)
1614 WHILE DSTR$<>""
1616 DPOS=NUM(MID(DSTR$,1,4),ERR=NEXT_KEY_DPOS)
1618 IF DPOS+5>LEN(NEW_KEY$) THEN BREAK ! issues with SM0 & SM4 where key is not first part of data and a date field falls in that part of the record
1620 IF POS(DR1$(347,1)="M ")<>0 THEN IF STP(MID(NEW_KEY$,DPOS,6))="" THEN NEW_KEY$=MID(NEW_KEY$,1,DPOS-1)+DIM(10)+MID(NEW_KEY$,DPOS+6) ELSE NEW_KEY$=MID(NEW_KEY$,1,DPOS-1)+UCS(FNDR_FMT_TFDATE$(MID(NEW_KEY$,DPOS,6),"%Y-%Mz-%Dz"))+MID(NEW_KEY$,DPOS+6) ! IF DATE_ERR THEN ERR_MSG$="DATE FORMAT ERROR["+MID(A_OUT$,DPOS,10)+"]"
1622 IF DR1$(347,1)="O" THEN IF STP(MID(NEW_KEY$,DPOS,6))="" THEN NEW_KEY$=MID(NEW_KEY$,1,DPOS-1)+DIM(9)+MID(NEW_KEY$,DPOS+6) ELSE NEW_KEY$=MID(NEW_KEY$,1,DPOS-1)+UCS(FNDR_FMT_TFDATE$(MID(NEW_KEY$,DPOS,6),"%Dz-%Ms-%Yz"))+MID(NEW_KEY$,DPOS+6) ! IF DATE_ERR THEN ERR_MSG$="DATE FORMAT ERROR["+MID(A_OUT$,DPOS,9)+"]" ! Oracle style date "DD-MM-YY"
1624 NEXT_KEY_DPOS: DSTR$=MID(DSTR$,5)
1626 WEND 
1650 REMOVE (OUTPUT_PORT,KEY=NEW_KEY$,DOM=AFTER_REMOVE_ERR_CODE,ERR=*NEXT); GOSUB LOG_ACTIVITY; GOTO AFTER_REMOVE_ERR_CODE
1655 ERR_MSG$="REMOVE ERR: "+STR(ERR)+" LINE: "+STR(TCB(5))+" SQL: ",ERR_MSG$+=MSG(-1)+" "+KEN(OUTPUT_PORT,ERR=*NEXT)
1656 GOSUB LOG_ACTIVITY
1660 AFTER_REMOVE_ERR_CODE:! resume normal processing
1695 RETURN 
1699 ! 
4000 OPEN_REP_FILE:! Set variables to id replication file & open it, get infoand set log flag
4003 ! IF MID(FILE_NAME$,1,3)="FMP" THEN FILE_NAME$="FMP"+MID(KEY$,1,1)+MID(FILE_NAME$,4) ! If FMP, then add 1 char record type to name
4005 DR_FILE_NAME$=FILE_NAME$,OUTPUT_PORT=0,OPEN_ERR=0; V_FILE_NAME$=STP(FILE_NAME$(1,8))+"_"+STP(FILE_NAME$(9,2))
4010 OUTPUT_PORT_NAME$="DR_"+V_FILE_NAME$+"_PORT"; DATA_REP_FILE_NAME$="DR_"+V_FILE_NAME$,DR1_NAME$="DR_"+V_FILE_NAME$+"_DR1$"
4020 IF EVN(OUTPUT_PORT_NAME$,ERR=ORF_DONE)<>0 THEN {; REM SSP 183647
4025 OUTPUT_PORT=EVN(OUTPUT_PORT_NAME$); DR1$=EVS(DR1_NAME$)
4035 TEMPDSTR$=FNOPT$(OUTPUT_PORT,"TFDATE=","",ERR=4050) ! 228363
4040 IF SYS_CONN_MAX_AGE THEN GOSUB CHECK_CONN_AGE; IF IS_CONN_EXPIRED OR OUTPUT_PORT=0 THEN GOTO 4050 ! 255362-Check connection age; if it is past expiry then open new connection (it will have been closed during the max age check)
4045  } ELSE {
4050 REM OUTPUT_PORT=HFN; OPEN (OUTPUT_PORT,IOL=*,ERR=*NEXT)DATA_REP_FILE_NAME$; VIA OUTPUT_PORT_NAME$=OUTPUT_PORT
4051 OUTPUT_PORT=HFN; OPEN (OUTPUT_PORT,IOL=*,OPT="NONULLS=P",ERR=*NEXT)DATA_REP_FILE_NAME$; VIA OUTPUT_PORT_NAME$=OUTPUT_PORT; GOTO 4055; REM Added for 080 when they had trouble doing data rep on version 7 pvx
4052 OUTPUT_PORT=0 ! If here then there was an error opening channel
4055 IF OUTPUT_PORT=0 THEN OPEN_ERR=ERR ELSE MNEMONIC (OUTPUT_PORT)'OD'=STR(JUL(0,0,0)); MNEMONIC (OUTPUT_PORT)'OT'=STR(NUM(DTE(0:"%Hz"))*60*60+NUM(DTE(0:"%mz"))*60+NUM(DTE(0:"%sz"))) ! Record error if there is an issue opening connection, else record day when connection was opened, in Julian form and time connection was opened, in secs, measured from midnight-255362
4059 ! Get DR1 data and put into %DR_filename_DR1$
4060 TMP=HFN; OPEN (TMP)"DR1"+%C$
4065 DIM DR1$(500); FIND (TMP,ERR=*NEXT,KEY=PAD(DR_FILE_NAME$,10))DR1$
4070 VIA DR1_NAME$=DR1$
4075 CLOSE (TMP)
4080  }
4090 ORF_DONE:! Open rep done 159723
4095 RETURN 
4099 ! 
4200 LOG_ACTIVITY:! log success or failure if logging is active, iF ERR_MSG$="" then success, else failure, msg in ERR_MSG$
4202 MSG_MINUS_1$=MSG(-1); LAST_ERR=ERR ! 245713
4204 LOCAL SEP$; SEP$="|"
4210 IF POS(MID(DR1$,346,1)="YA")>0 OR NOT(NUL(ERR_MSG$)) THEN {
4215 PRINT (3)FILE_NAME$+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+ACTION$+SEP$+KEY$+SEP$+ERR_MSG$+SEP$+STR(RECORD_COUNT)+SEP$+TBL(MID(DR1$,346,1)="A" AND ACTION$="W","",SUB(A_OUT$,$8A$,"|"))
4235  }
4241 IF NOT(GUI_MODE) THEN {
4243 IF MOD(RECORD_COUNT,50)=1 OR NOT(NUL(ERR_MSG$)) OR FILE_NAME$="DR2SRV" THEN PRINT FILE_NAME$+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+ACTION$+SEP$+KEY$+SEP$+ERR_MSG$+SEP$+STR(RECORD_COUNT)+SEP$
4245 IF MOD(RECORD_COUNT,50)=1 THEN GOSUB UPDATE_STATUS
4249  }
4250 IF NOT(NUL(ERR_MSG$)) THEN {
4252 ERR_ON_REC=1
4255 E$=QUE_KEY$+SEP+MID(ERR_MSG$,1,256)+SEP+ACTION$+SEP+FILE_NAME$+SEP+KEY$+SEP+STP(A$,2,$00$); WRITE (4,KEY=QUE_KEY$)E$ ! Write to DR3 file
4260 GOSUB DO_EXT_ERR_CMD ! process external error command if needed
4265  }
4270 RESET_SERVER:IF (LAST_ERR=14 AND NOT(NUL(ERR_MSG$))) OR POS("ORA-03113"=ERR_MSG$) OR POS("ORA-03114"=ERR_MSG$) OR POS("ORA-03135"=ERR_MSG$) OR POS("communication link failure"=LCS(ERR_MSG$)) THEN RECORD_COUNT=RESET_AFTER_COUNT-1; WAIT 1 ! ssp212765, 245713
4275 ERR_MSG$="" ! Clear err_msg since we will continue running
4276 DATE_ERR=0
4290 LOG_DONE:
4292 MSG_MINUS_1$=""; LAST_ERR=-1 ! 245713
4295 RETURN 
4299 ! 
4300 ERR_IN_ACTION:! Got an error in doing an ACTION on other than file i/o, get error info, logit, and then RETURN
4305 ERR_MSG$="ERR "+STR(ERR)+" LINE "+STR(TCB(5)); IF ERR=15 THEN ERR_MSG$+=" "+MSG(-1)
4320 GOSUB LOG_ACTIVITY
4345 RETURN 
4349 ! 
4400 DO_EXT_ERR_CMD:! Do process EXT_ERR_CMD and substitute data and invoke
4405 IF NOT(NUL(EXT_ERR_CMD$)) THEN {
4410 CMD$=EXT_ERR_CMD$
4412 CMD$=SUB(CMD$,"&QUE_KEY",QUE_KEY$)
4414 CMD$=SUB(CMD$,"&QUE_COMMAND",ACTION$)
4416 CMD$=SUB(CMD$,"&TABLE_NAME",FILE_NAME$)
4418 CMD$=SUB(CMD$,"&DATA_KEY",KEY$)
4420 CMD$=SUB(CMD$,"&DATA_VALUE",A$)
4422 CMD$=SUB(CMD$,"&ERR_MSG",ERR_MSG$)
4450 INVOKE CMD$,ERR=*NEXT
4485  }
4495 RETURN 
4499 ! 
4500 CHECK_CONN_AGE:! 255362 - Connection max age check, expired connections will be closed
4505 CONN_MAX_AGE=SYS_CONN_MAX_AGE
4510 IS_CONN_EXPIRED=0; IF CONN_MAX_AGE=0 THEN RETURN 
4515 LOCAL SEP$; SEP$="|"
4520 CURR_DAY_JUL=JUL(0,0,0) ! Today, in Julian form
4530 CURR_TIME_SEC=NUM(DTE(0:"%Hz"))*60*60+NUM(DTE(0:"%mz"))*60+NUM(DTE(0:"%sz")) ! Current time, in secs, measured from midnight
4540 CONN_DAY_JUL=NUM(MNM('OD',OUTPUT_PORT))
4550 CONN_TIME_SEC=NUM(MNM('OT',OUTPUT_PORT))
4560 IF CURR_DAY_JUL=CONN_DAY_JUL THEN IF (CURR_TIME_SEC-CONN_TIME_SEC)>=CONN_MAX_AGE THEN IS_CONN_EXPIRED=1 END_IF ELSE IF CURR_DAY_JUL>CONN_DAY_JUL THEN IF ((86400-CONN_TIME_SEC)+CURR_TIME_SEC)>=CONN_MAX_AGE THEN IS_CONN_EXPIRED=1
4580 IF IS_CONN_EXPIRED THEN CLOSE (OUTPUT_PORT,ERR=*PROCEED); OUTPUT_PORT=0
4590 IF IS_CONN_EXPIRED OR (%LOG_LEVEL=%LOG_DEBUG) THEN PRINT (3)"CONNECTION"+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+FILE_NAME$+SEP$+"MAX AGE CHECK"+SEP$+STR(CONN_MAX_AGE)+SEP$+"OPENED"+SEP$+STR(CONN_DAY_JUL)+SEP$+STR(CONN_TIME_SEC)+SEP$+"NOW"+SEP$+STR(CURR_DAY_JUL)+SEP$+STR(CURR_TIME_SEC)+SEP$+TBL(IS_CONN_EXPIRED,"","EXPIRED")+SEP$ ! Log connection max age check event and result
4595 RETURN 
4599 ! 
5000 ! 5000 - Get option
5010 DEF FNOPT$(LOCAL FILE_CHAN, LOCAL O$, LOCAL D$)
5020 LOCAL X$,O
5030 X$=FIN(FILE_CHAN,"FILENAME"); O=POS(";"=X$); IF O=0 THEN X$="" ELSE X$=X$(O)
5040 X$=X$+";"+OPT(FILE_CHAN)+";"
5050 O=POS(";"+UCS(O$)=UCS(X$))
5060 IF O=0 THEN RETURN D$
5070 X$=X$(O+1+LEN(O$))
5080 RETURN X$(1,POS(";"=X$)-1)
5090 END DEF
6000 ! ^1000 DR_GET_DATETIME given: Date in either format(MM/DD/YYYY), TopForm YYMMDD format or "" for bogus date, Time in TIM format hour.fractional part of hour RETURN a number representing the Julian day.partial part of the day
6005 DEF FNDR_GET_DATETIME(LOCAL DATE_IN$, LOCAL TIME_IN)
6010 LOCAL RET_VAL,CURR_P
6015 ! default ret_val to Jan 1, 1800 to cover any errors, if DATE_IN$ is 6 long assume TopForm format, if 10 long then assume MM/DD/YYYY format, if 8 long assume MM/DD/YY format
6020 RET_VAL=JUL(1800,1,1),DATE_ERR=1
6025 IF LEN(DATE_IN$)=6 THEN {! TopForm date format
6030 RET_VAL=JUL((ASC(DATE_IN$(1,1),ERR=*NEXT)+125)*10+NUM(DATE_IN$(2,1),ERR=*NEXT),NUM(DATE_IN$(3,2),ERR=*NEXT),NUM(DATE_IN$(5,2),ERR=*NEXT),ERR=*NEXT); DATE_ERR=0
6035  } ELSE {
6040 IF LEN(DATE_IN$)=8 OR LEN(DATE_IN$)=10 THEN {! In MM/DD/YY or MM/DD/YYYY format
6045 RET_VAL=JUL(NUM(DATE_IN$(7),ERR=*NEXT),NUM(DATE_IN$(1,2),ERR=*NEXT),NUM(DATE_IN$(4,2),ERR=*NEXT),ERR=*NEXT); DATE_ERR=0
6050  }
6055  }
6060 ! Add time NOTE: if date before 1/1/1970 then it will be negative, so subtract time
6065 CURR_P=PRC; PRECISION 14; IF TIME_IN=0 OR TIME_IN>=24 THEN RET_VAL=RET_VAL+SGN(RET_VAL)*(TIM/24) ELSE RET_VAL=RET_VAL+SGN(RET_VAL)*(TIME_IN/24) END_IF ; PRECISION CURR_P
6070 RETURN RET_VAL
6075 END DEF ! DR_GET_DATETIME
6099 ! 
6100 ! DR_FMT_TFDATE$ given: TF format date, ""=current date, return stringusing DATE_FORMAT$ where DATE_FORMAT$ follows DTE date format mask --- note should use date only, time not given
6110 DEF FNDR_FMT_TFDATE$(LOCAL TFDATE$, LOCAL DATE_FORMAT$)
6120 LOCAL RET_VAL$
6130 RET_VAL$=FN%PRINT_DATETIME$(FNDR_GET_DATETIME(TFDATE$,0),DATE_FORMAT$)
6140 RETURN RET_VAL$
6150 END DEF ! DR_FMT_TFDATE$
6160 ! 
9000 ! Errors
9005 ERR_MSG$="ERR "+STR(ERR)+" LINE "+STR(TCB(5)); IF ERR=15 THEN ERR_MSG$+=" "+MSG(-1)
9007 SEP$="|"
9010 ERROR$=QUO+FILE_NAME$+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+ACTION$+SEP$+KEY$+SEP$+ERR_MSG$+SEP$+QUO+" "
9011 IF ERROR$<>"" THEN PRINT (3)ERROR$
9020 GOTO 9900
9900 REM "end
9930 FILE_NAME$="DR2SRV",KEY$="Company="+%C$,ACTION$="STOP"; DIM DR1$(500,"Y"); GOSUB 4200
9950 IF BKG THEN RELEASE 
9965 END_PROG:
9970 CLOSE (1),(2),(3),(4),(5),(6),(7),(8)
9975 EXIT 
9999 END 
10000 REM "All filter related logic is here
10005 APPLY_FILTERS:
10006 LOCAL SEP$; SEP$="|"
10010 DR_TARGET$=DR1$(41,20),DR_TABLE$=DR1$(314,32),IS_ENABLED=0,FILTERED=0,FOUND_FIELD=0,FOUND_MATCH=0
10015 CHECK_FILTERS_ENABLED:
10019 IF DR1$(352,1)="Y" THEN GOTO DONE_AF ! 266976 - Table is set to bypass filters so no need to perform any other checks
10020 TARGET_FILTER$="N"; FIND (6,KEY=DR_TARGET$,DOM=*NEXT)TARGET_FILTER$; IF TARGET_FILTER$<>"Y" THEN GOTO DONE_AF ELSE IS_ENABLED=1; GOTO FILTER_ENABLED
10025 CALL "DRGQRF;IS_TARGET_FILTERED",DR_TARGET$,TARGET_FILTER$
10030 WRITE (6,KEY=DR_TARGET$)TARGET_FILTER$
10035 PRINT (3)"FILTER"+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+"CHECK"+SEP$+DR_TARGET$+SEP$+TARGET_FILTER$+SEP$
10040 GOTO CHECK_FILTERS_ENABLED
10045 FILTER_ENABLED:
10050 IF NOT(IS_ENABLED) THEN GOTO DONE_AF
10055 FOR I=0 TO FF_COUNT-1
10060 FFIELD$=PAD(FFIELDS$[I,0],30),FFIELD_LEN=NUM(FFIELDS$[I,1])
10065 FIND_FIELD_POS:
10070 FIELD_POS=0; FIND (7,KEY=DR_TARGET$+FFIELD$+DR_TABLE$,DOM=*NEXT)FIELD_POS; IF FIELD_POS=0 THEN GOTO DONE_FIELD ELSE GOTO CHECK_FIELD
10075 CALL "DRGQRF;GET_FIELD_POS",(DR_TABLE$),FFIELD$,FIELD_POS
10080 WRITE (7,KEY=DR_TARGET$+FFIELD$+DR_TABLE$)FIELD_POS
10085 PRINT (3)"FILTER"+SEP$+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+SEP$+FID0$+SEP$+"FIELD POSITION"+SEP$+DR_TARGET$+SEP$+FFIELD$+SEP$+DR_TABLE$+SEP$+STR(FIELD_POS)+SEP$
10090 GOTO FIND_FIELD_POS
10095 CHECK_FIELD:
10100 IF FIELD_POS=0 THEN GOTO DONE_FIELD
10105 FOUND_FIELD=1
10110 IF NUL(MID(KEY$,FIELD_POS,FFIELD_LEN)) THEN FOUND_MATCH=1 ELSE FIND (DRF,KEY=DR_TARGET$+FFIELD$+PAD(MID(KEY$,FIELD_POS,FFIELD_LEN),30),DOM=*NEXT); FOUND_MATCH=1
10115 DONE_FIELD:
10120 NEXT I
10125 IF NOT(FOUND_FIELD) OR (FOUND_FIELD AND FOUND_MATCH) THEN FILTERED=0 ELSE FILTERED=1
10190 DONE_AF:
10195 RETURN 
10199 ! 
10200 REM "Update process status information to SV0 file
10205 UPDATE_STATUS:
10260 CALL "UPDSV0;UPDATE_STATUS",ERR=*NEXT,"DATAREP","DATAREP "+QUE_CODE$,"","Data Rep Processor - "+QUE_CODE$,"DR2SRV",STR(TCB(89))
10295 RETURN 
10299 ! 
10300 PAUSE_MODE:
10310 PAUSE_COUNT=0
10320 FIND (5,KEY=%C$+"DR2",DOM=*RETURN)FRZK$,FRZ_FID$,FRZ_TS$ ! Continue in freeze mode until pause record is gone
10330 WAIT 1
10375 PAUSE_COUNT+=1; IF PAUSE_COUNT>60 THEN PAUSE_COUNT=0; PRINT "DR2SRV"+"|"+FN%PRINT_DATETIME$(0,"%Y-%Mz-%Dz %Hz:%mz:%sz")+"|"+FID(0)+"|"+"PAUSED"+"|"+FRZ_FID$+"|"+FRZ_TS$+"|"; GOSUB UPDATE_STATUS ! 286759-Display paused seconds counter; Periodically update status when paused
10380 GOTO 10320
10395 RETURN 
10399 ! 
56000 REM "SSP 185523 Make FMP file data replicate
56002 REM "209252-Modify Data Rep to allow output to multiple database
56003 REM "212761-Issue with datarep server using cached ext. db. channels
56004 REM "222352-Datarep sessions getting terminated, suspect inactivity
56005 REM "223557-Modify Data Replication with the ability to designate ranges
56006 REM "228363-Issue with MySQL and datarep connectivity: errors on screen
56007 REM "239718-Datarep error que process IDLE timeout message interval
56008 REM "245713-Data rep keeps getting an error 14, if Mark turns it off
56009 REM "255362-Ability to set max age for a database connection
56010 REM "261127-Modify EC Monitor and Datarep Server programs to display
56011 REM "266976-Ability to disable filtering at the table level if target
56012 REM "282624-Record the FID, extended rec details in log entries
56013 REM "286759-Improve Data Replication module  
56014 REM "286759-Datarep Improvements - Error queue analysis and handling    
56015 REM "295220-We keep losing Data Rep queue RS4.                          
56016 REM "298341-Re-sync the WMBI sqlserver database.                        
56017 REM "307335-DBD-156 - Suppress false error messages                     
