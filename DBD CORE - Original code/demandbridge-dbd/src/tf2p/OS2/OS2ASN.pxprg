0010 REM "<OS2ASN> TEXT ASN Import from United Stationers
0020 SETESC 9300; SETERR 9000
0035 REM "5.7 - 07/14/17 - 15.190833 - tma - SSP# 293244
0037 REM "293244-WARNING: Program Exception has occurred (047, OS2ASN-2116)  
0040 REM "Copyright 2017 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0090 CLEAR ; SETERR 0100; ENTER X3$,X4$,Q0$,Q1$
0100 IF %GUI=0 THEN SETERR 9000
0110 X0$="OS2ASN",X1$="ASN Import From United Stationers"
0120 DIM Z0$(80,"-"),FILE$[150]
0130 K0=20,K1=1
0135 C9=-1
0170 IF POS("MS"=UCS(SYS)) THEN ISWIN=1 ELSE ISWIN=0
0200 REM "
0240 IF %GUI=0 THEN CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,X0,X1,X2; IF X1>0 THEN GOTO 9920
0245 IF X3$(66,1)>"2" THEN PRECISION NUM(X3$(66,1),ERR=0246)
0295 DIM Z0$(80,X3$(235,1)); Z0$=MNM('GS')+Z0$+MNM('GE')
0299 IF %GUI=0 THEN CALL "ZZ2PRP","OS",RESULT$,DATE$; IF RESULT$<>"Y" THEN CALL "SSPROM",".4",X3$,Z,"Access Denied! the Office Supply Interface System is not an installed module.","","",0; RUN "ZMENU"
0300 REM "IOLISTS
0310 IOLIST A$; REM "EM1
0320 IOLIST B$
0330 IOLIST C$
0340 IOLIST FS1$,FS1[0],FS1[1],FS1[2],FS1[3],FS1[4],FS1[5],FS1[6],FS1[7],FS1[8],FS1[9],FS1[10],FS1[11],FS1[12],FS1[13]
0350 IOLIST FS2$,FS2[0],FS2[1],FS2[2],FS2[3],FS2[4],FS2[5],FS2[6],FS2[7],FS2[8],FS2[9],FS2[10],FS2[11],FS2[12],FS2[13],FS2[14],FS2[15],FS2[16],FS2[17],FS2[18],FS2[19],FS2[20],FS2[21],FS2[22],FS2[23],FS2[24],FS2[25],FS2[26],FS2[27],FS2[28],FS2[29]
0420 IOLIST I$
0450 IOLIST SM4$,SM4[0],SM4[1],SM4[2],SM4[3],SM4[4],SM4[5],SM4[6],SM4[7],SM4[8],SM4[9],SM4[10],SM4[11],SM4[12],SM4[13],SM4[14],SM4[15] ! SSP 257952
0500 REM "FILES
0505 DIM Z[NUM(X3$(60,3))]
0509 REM "Slot 1 used for ED0 file opened in 1000's, slot 2 used for text file created in 700's to write to
0510 Z$="13O ZZPARM  20O FS2...  21O FS1...  22O FMP...  25O OSD...  26O SM4...  27O OSB...  "
0520 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; ON Z0 GOTO 0521,9900
0600 REM "
0610 IF %GUI=0 THEN GOSUB 6000
0620 PARM$=X3$(9,3)+"OSP"
0640 IF Q1$="" AND %GUI=0 THEN CALL "ZZPROM",".Y",X3$,Z,"PROCEED?","","",0; ON Z GOTO 0641,9900
0800 REM "Set Prefix
0900 REM "Read ZZPARM file for DIRectory and hex codes
0910 DIM I$(512); READ (Z[13],KEY=PARM$,DOM=9900)IOL=0420 ! ssp#226811
0915 ELEMENT_SEPARATOR$=ATH("2A"),SEGMENT_TERMINATOR$=ATH("5E"); REM "Setup for original values:  * and ^ respectively
0920 REM "IF I$(309,2)<>"  " THEN ELEMENT_SEPARATOR$=ATH(I$(309,2))
0925 REM "IF I$(311,2)<>"  " THEN SEGMENT_TERMINATOR$=ATH(I$(311,2))
1000 REM "Get list of .exp files to process
1005 I=-1,J=0
1010 IMPORT_PATH$=STP(I$(68,30),1)
1015 SELECT AT$ FROM IMPORT_PATH$
1030 IF AT$<>"." AND AT$<>".." AND POS("ASN"=AT$)<>0 AND MID(AT$,4,3)<>%C$ THEN FILE$[I+1]=IMPORT_PATH$+AT$; I=I+1; REM " ONLY PICK ONES WITH ASN IN THE NAME!SSP#226811 ASN is a VALID demandbridge file name do not use if includes company cd 4,3
1035 NEXT RECORD 
1036 SLOT=UNT
1060 CLOSE (SLOT); OPEN LOCK (SLOT,OPT="TEXT",ERR=1985)FILE$[J]; REM "Open for reading raw file!ssp#226811 - if fails on open try next file do not erase may not be text file
1065 CLOSE (13); OPEN (13)"ZZPARM"; REM "Re-open ZZPARM closed in ZZ2BLS
1075 IF %GUI=0 THEN PRINT @(15,15),'CE',"Processing: "+FILE$[J]
1080 GOSUB 8100; GOSUB 8150
1100 REM "Process the file
1102 DIM INV_REC$(240); INV_REC$=PAD(INV_REC$,240)
1105 C=0,SEGMENT$=""
1110 READ (SLOT,END=1900)SEGMENT$
1120 C=C+1; IF MOD(C,T0)=1 THEN GOSUB 8150
1150 ON CSE(MID(SEGMENT$,56,2),"1A","1B","1C","1D","2A","2B","2C") GOSUB 1800,2000,2100,2200,2300,2400,2500,2600,2700 ! SSP#226811 handle empty file
1160 GOTO 1110
1800 REM "
1899 RETURN 
1900 REM "End of file
1930 REM "Remove the file
1931 CLOSE (SLOT,ERR=1932)
1935 IF ISWIN THEN S2$="copy "+FILE$[J]+" "+HWD+DLM+"editmp"+DLM; CALL "ZZ2CMD",X3$,X4$,S2$,"","IN",COMM_CODE,COMM_CODE$; GOTO 1950; REM "SSP146619, If NT call command processor so command will happen on server 
1940 S2$="cp "+FILE$[J]+" "+HWD+DLM+"editmp"+DLM; INVOKE S2$
1945 ERASE FILE$[J],ERR=1946
1985 J=J+1; IF J<=I AND STP(FILE$[J])<>"" THEN GOTO 1060 ! SSP#226811
1995 GOTO 5000
2000 REM 1A
2002 FILE_CREATE_DATE$=SEGMENT$(111,8)
2004 FILE_CREATE_TIME$=SEGMENT$(119,4)
2006 ORIGINAL_ORDER_DATE$=SEGMENT$(123,8)
2008 HOME_FACILITY_NUMBER$=SEGMENT$(131,3)
2010 TOTAL_ORDER_WEIGHT_QTY$=SEGMENT$(134,9)
2012 ORDER_WEIGHT_QTY_TOTAL$=SEGMENT$(143,9)
2014 FILL_FACILITY$=SEGMENT$(152,3)
2016 SHIP_TO_CITY_1A$=SEGMENT$(155,30)
2018 SHIP_TO_STATE_1A$=SEGMENT$(185,2)
2020 SHIP_TO_POSTAL_CODE_1A$=SEGMENT$(187,15)
2022 NUMBER_OF_TRACKING_NUMBERS$=SEGMENT$(202,5)
2024 BILL_TO_CUST$=SEGMENT$(1,9)
2026 CLIENT_PO$=SEGMENT$(10,22); CLIENT_PO$=STP(CLIENT_PO$,3,"-")
2028 USSCO_ORDER_NUMBER$=SEGMENT$(32,7)
2030 SHIPMENT_DATE$=SEGMENT$(39,8)
2032 SHIPMENT_TIME$=SEGMENT$(47,4)
2099 RETURN 
2100 REM "1B
2102 SHIP_TO_NAME$=SEGMENT$(111,60)
2104 SHIP_TO_ADDRESS_1$=SEGMENT$(171,60)
2106 SHIP_TO_ADDRESS_2$=SEGMENT$(231,55)
2108 SHIP_TO_ADDRESS_3$=SEGMENT$(286,55)
2110 SHIP_TO_CITY_1B$=SEGMENT$(341,30)
2112 SHIP_TO_STATE_1B$=SEGMENT$(317,2)
2114 SHIP_TO_POSTAL_CODE_1B$=SEGMENT$(373,15)
2116 SHIP_TO_COUNTRY$=MID(SEGMENT$,388,3) ! SSP#293244
2199 RETURN 
2200 REM "1C
2202 ORDE_LEVEL_INST$=MID(SEGMENT$,111,40) ! SSP#293244
2299 RETURN 
2300 REM 1D
2302 TRACKING_NUMBER$=SEGMENT$(111,30)
2304 PACKAGE_WEIGHT_QTY$=SEGMENT$(141,4)
2306 PACKAGE_WEIGHT_QTY_TOT$=SEGMENT$(145,5)
2308 CARRIER_SHIPPER$=SEGMENT$(150,4)
2310 SERVICE_TYPE_CODE$=SEGMENT$(154,2)
2320 CARRIER_CHARGE$=SEGMENT$(156,7)
2350 GOSUB 8200
2399 RETURN 
2400 REM 2A
2402 ORDERED_ITEM_NUMBER$=SEGMENT$(111,22)
2404 SHIPPED_ITEM_NUMBER$=SEGMENT$(133,22)
2406 CLIENT_ITEM_NUMBER$=SEGMENT$(155,22)
2408 MANUFACTURER_ITEM_NUMBER$=SEGMENT$(177,22)
2410 SHIPPED_QTY$=SEGMENT$(199,9)
2412 SHIPPED_UOM$=SEGMENT$(208,2)
2414 ORDERED_QTY$=SEGMENT$(210,7)
2416 ORDERED_UOM$=SEGMENT$(217,2)
2418 ITEM_DESC$=SEGMENT$(219,80)
2420 LINE_NUMBER_INBOUND_PO$=SEGMENT$(299,6)
2499 RETURN 
2500 REM 2B
2502 LINE_LEVEL_SPECIAL_INST$=MID(SEGMENT$,111,78) ! SSP#293244
2599 RETURN 
2600 REM 2C
2602 ITEM_SERIAL_NUMBER$=MID(SEGMENT$,111,30) ! SSP#293244
2699 RETURN 
3034 USSCO_SUB_ORDER_SEQUENCE$=SEGMENT$(51,5)
3036 RECORD_TYPE$=SEGMENT$(56,2)
3038 ORDER_LINE_NUMBER$=SEGMENT$(58,9)
3040 ORDER_TXT_TYPE$=SEGMENT$(67,3)
3042 ORDER_TXT_SEQ$=SEGMENT$(70,3)
3044 ORDER_TYPE_CODE$=SEGMENT$(73,1)
3046 EDI_USAGE_CODE$=SEGMENT$(74,1)
3048 EDI_FORMAT_CODE$=SEGMENT$(75,1)
3050 SHIP_TO_CUST_NUM$=SEGMENT$(78,9)
5000 REM "EOJ
5015 C=T; GOSUB 8150
5040 GOTO 9900
6000 REM "BACKGROUND
6001 IF %GUI<>0 THEN GOTO 6190
6005 PRINT (0,ERR=6016)'SB',
6020 PRINT @(0,4),"Translating Incoming Text ASN from United Stationers"
6165 PRINT (0,ERR=6166)'SF',
6190 RETURN 
7500 REM "Convert date q$ into q0$
7501 REM "Q$ in YYYYMMDD format or YYMMDD
7505 Q0$=""
7506 IF STP(Q$,3," ")="" THEN GOTO 7545
7510 IF LEN(Q$)=8 THEN GOTO 7520 ELSE IF LEN(Q$)=6 THEN D1$=STR(NUM(Q$(1,2)):"00") ELSE GOTO 7545
7515 IF D1$<"50" THEN Q$="20"+Q$ ELSE Q$="19"+Q$
7520 Q0$=CHR(NUM(Q$(1,3),ERR=7521)-125)+Q$(4,1)+Q$(5,2)+Q$(7,2)
7545 RETURN 
7600 REM ITEM CODE CROSS REFERENCE LOOK-UP
7610 REM =================================
7615 DIM C$(168)
7620 K$=KEY(Z[5],END=7700)
7630 READ (Z[5],KEY=K$,DOM=7700)
7640 IF K$(1,10)<>VEND$ THEN GOTO 7620
7645 IF K$(15,20)<>ITEM_CODE$ THEN GOTO 7620
7660 READ (Z[20],KEY=PO_NUM$+"   ",DOM=7620)IOL=0330
7670 IF C$(101,10)<>K$(45,10) THEN GOTO 7660
7680 PO_LINE$=PAD(C$(7,3),3,0,"0")
7700 IF PO_LINE$="   " THEN PO_LINE$=PAD(ELEMENT$[2],3,0,"0")
7710 RETURN 
8100 REM "GOSUB here, once, at the beginning, after the background is set and before the Proceed? question. Set T to total # to do (by calling ZZINFO) and T0 to the reporting interval (report every T0 number of records) this is typically 2% of total; This also prints a message (@8115),so adjust accordingly
8110 T=0; CALL "ZZ2FNC;SERIALRECCNT",SLOT,T
8115 IF %GUI=0 THEN PRINT @(0,7),"There are "+STR(T)+" records to process"
8129 REM "Set T0, we make sure T0 is > 1, because later on we MOD and look for avalue of 1. IF T0 is 1, then nothing would get reported. We look for a result of 1 because this causes the first record to automatically start the reporting instead of waiting until the T0'th record to get the first report
8130 T0=INT(T*.02); IF T0<=1 THEN T0=2
8145 RETURN 
8150 REM "Call this each time to update the bar graph. Display horiz. bar graph given total #, T and current #, C, and time counter T1 (T1 is init'ed here and used here, just don't use it somewhere else)
8155 CALL "ZZBARG",X3$,"H",19,10,50,T1,T,C
8195 RETURN 
8200 REM " SET UP AND WRITE RECORDS
8201 DIM FS1$(350); READ (Z[21],KEY=CLIENT_PO$(1,8),DOM=8599)FS1$
8210 DIM SM4$(700),SM4[15] ! SSP 257952
8220 SM4$(1,9)=CLIENT_PO$; REM "P/O
8230 SM4$(10,3)=LINE_NUMBER_INBOUND_PO$; REM " P/O Line Number
8240 REM "SM4$(13,1)= SHIP TO CODE
8250 Q$=SHIPMENT_DATE$; GOSUB 7500; SM4$(15,6)=Q0$; REM " Shipped on date
8260 SM4$(21,4)=SHIPMENT_TIME$; REM " Shipped on time
8270 REM SM4$(25,6)= ESTIMATED ARRIVAL
8280 DIM OSB$(128); READ (Z[27],KEY=SERVICE_TYPE_CODE$,DOM=8300)OSB$
8282 READ (Z[22],KEY="S"+OSB$(34,1),DOM=8300)FMP$
8290 REM "SM4$(37,12)=OSB$(33,1); REM "CARRIER ID
8300 REM "SM4$(37,12)=CARRIER_SHIPPER$+DIM(8); REM " CARRIER NAME
8304 SM4$(31,1)=FMP$(2,1); REM " Get carrier ID/Ship via code ssp#239076
8305 SM4$(37,12)=FMP$(3,15); REM GET CARRIER NAME FROM SHIP VIA
8306 IF TRACKING_NUMBER$=DIM(30) THEN GOTO 8599; REM SSP 207764
8310 SM4$(383,60)=MID(TRACKING_NUMBER$,1,30); REM " TRACKING NUMBER;!SSP 257952
8320 REM SM4$(69,16)=PICKUP NUMBER
8330 SM4$(85,9)=SHIP_TO_POSTAL_CODE_1B$(1,9); REM " ZIP CODE
8340 REM SM4$(93,4)=ZONE
8350 SM4$(97,3)="NNN"; REM "order updated? & PO received? & don't bill
8400 SM4[2]=NUM(ORDER_WEIGHT_QTY_TOTAL$,ERR=8401); REM " WEIGHT
8401 SM4[1]=NUM(PACKAGE_WEIGHT_QTY$,ERR=8402)/10; REM " WEIGHT
8405 REM "SM4$(127,3)=STR(NUM(PACKAGE_WEIGHT_QTY_TOT$):"000")
8410 SM4[3]=NUM(CARRIER_CHARGE$)/100; REM " TOTAL FREIGHT
8450 WRITE_SEQ$=STR(1:"000")
8454 CALL "SM2SM4",ERR=*NEXT,X3$,X4$,SM4$,SM4{ALL}
8455 SM4$(124,3)=WRITE_SEQ$; REM " BOX NUMBER PART OF KEY
8460 WRITE (Z[26],KEY=SM4$(1,13)+WRITE_SEQ$,DOM=8470)IOL=0450; GOTO 8490
8470 IF WRITE_SEQ$="999" THEN ESCAPE ELSE WRITE_SEQ$=STR(NUM(WRITE_SEQ$)+1:"000"); GOTO 8455
8480 GOTO 8460
8599 RETURN 
8950 DEF FNS$(Z9$)=Z9$(1,POS("     "=Z9$+"     ")-1)
9000 REM "ERROR PROCESSING
9005 IF ERR=69 THEN GOTO 9500
9010 Y5=ERR,Y6=TCB(5)
9015 SETERR 9016; Y8$=LST(PGM(Y6))
9016 SETERR 9000
9040 CALL "ZZERRM",Y8$,X0$,Y7$,X3$,Y5,Y6,Y7,Y8,0
9045 REM 
9050 ON Y7 GOTO 9060,9100,9800,9070,9090
9055 REM 
9060 RETRY 
9070 SETERR 9080
9075 EXECUTE Y7$
9080 SETERR 9000; RETRY 
9090 SETERR 0000; RETRY 
9100 REM " TRANSFER CONTROL
9180 GOTO 0990
9190 GOTO 9800
9300 SETESC 9350
9310 SETERR 9350
9315 IF X3$(47,1)="N" THEN RETURN ELSE SETESC 0000; RETURN 
9350 SETERR 9000; RETURN 
9500 REM "CTRL LOGIC
9510 SETERR 9000; GOSUB 6400
9520 ON C9 GOTO 1140,2040
9900 REM "END PROGRAM
9910 CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
9920 IF %GUI THEN GOTO PROCESS_END
9930 SETERR 9940; Q1$=A1$
9940 SETESC 9350
9950 RUN "ZMENU"
9999 END 
20000 ! 100 - Initialization
20010 INIT:
20015 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,-1,X1,X2; IF X1>0 THEN CMD_STR$="END"; GOSUB WRAPUP; GOTO *RETURN
20020 _SV_KR=PRM('KR'); SET_PARAM 'KR'=0 ! Ensure native handling of KEP()
20030 GOSUB SETUP_LIBRARY; IF %FLMAINT_MSG$<>"" THEN MESSAGE_LIB %FLMAINT_MSG$
20055 CALL "ZZ2PRP","OS",RESULT$,DATE$; IF RESULT$<>"Y" THEN MSGBOX "","TOPS Module is not installed"; CMD_STR$="END"; GOSUB WRAPUP; GOTO *RETURN
20082 DIM Z[NUM(X3$(60,3))]
20090 RETURN 
20100 OPEN_ERR: MSGBOX _MSG_FILOPNERR1$+QUO+_FILE_NAME$+QUO+SEP+_MSG_DIRECTORY$+LWD+SEP+_MSG_PREFIX$+PFX,MSG(ERR),"!"
20110 CMD_STR$="END"
20120 RETURN 
20130 ! 300 - Set up the message library
20140 SETUP_LIBRARY:
20150 _SV_MSGLIB$=MSG(*)
20160 _LANG$=LCS(%NOMAD_DEF_SFX$); IF _LANG$="" THEN _LANG$=LCS(ENV("PVXLANG")); IF _LANG$="" THEN _LANG$=LCS(ENV("LANG")); IF _LANG$="" THEN _LANG$="en"
20170 MESSAGE_LIB "*tfmsglib."+_LANG$,ERR=*NEXT; GOTO 20190
20180 MESSAGE_LIB "*tfmsglib.en"
20190 SET_MSG:GOSUB SETUP_MESSAGES
20200 RETURN 
20210 ! 400 - Set up key information
20220 SETUP_KEYS:
20230 _NUMKEYS=1
20240 DIM _KEYS$[1:1]; _KEYS$[1]="ERROR_CODE$"
20250 _KEY1=1
20260 RETURN 
20270 ! 500 - Main panel post_display logic
20280 MAIN_POST_DISPLAY:
20290 MESSAGE_LIB _SV_MSGLIB$
20300 GOSUB CLEAR_REC
20310 IF ARG_1$="" THEN _ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS; GOTO *RETURN
20320 _KEY$=ARG_1$; READ (_FIL_NO,KEY=_KEY$,ERR=NEXT_REC)
20330 _ENABLE_FLG=-1; GOSUB PROCESS_READ; GOSUB DISP_REC
20340 RETURN 
20350 ! 900 - Wrapup
20360 WRAPUP:
20400 MESSAGE_LIB _SV_MSGLIB$
20410 SET_PARAM 'KR'=_SV_KR
20420 RETURN 
20430 ! 1000 - Start of maintenance only code - Find/Add/Delete/Clear record
20440 FIND_REC:
20450 CHANGE_FLG=0; IF POS(_EOM$=$000102090D$)=0 THEN RETURN ELSE GOSUB GET_CURKEY; IF _EOM$=$00$ THEN IF QRY_VAL$<>"" AND QRY_VAL$=EVS(_KEYS$[_CURKEY]) THEN QRY_VAL$="" ELSE RETURN 
20460 IF _ENABLE_FLG<0 THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1
20470 IF _ENABLE_FLG THEN IF _KCNT<_NUMKEYS THEN _KCNT=_CURKEY+1,_ENABLE_FLG=_KCNT; GOSUB ENABLE_GROUPS; RETURN ! If multiple key segments, enable the _KCNT segment
20480 READ DATA FROM REC(IOL(_FIL_NO:KEY,ERR=*NEXT)) TO _KEY$
20490 IF NUL(STP(_KEY$,1,$00$)) THEN NEXT_ID=_FIRST_KEY; RETURN 
20500 READ (_FIL_NO,KEY=_KEY$,DOM=NEW_RECORD,ERR=CHK_ERR_NXT)
20510 GOSUB PROCESS_READ
20520 GOSUB NUM_TO_STR
20530 CHANGE_FLG=0,REFRESH_FLG=1,NEXT_ID=_FIRST_FIELD
20540 EXIT 
20550 ! 1200 - New RECORD check
20560 NEW_RECORD:
20570 _CLR_FLG$="F"; GOSUB CLEAR_FIELDS
20580 IF _ENABLE_FLG THEN _KCNT=0,_ENABLE_FLG=-1; GOSUB ENABLE_GROUPS
20590 CHANGE_FLG=0,REFRESH_FLG=1,NEXT_ID=_FIRST_FIELD
20600 RETURN 
20610 ! 1400 - Add RECORD
20620 WRITE_REC:
20630 GOSUB STR_TO_NUM
20640 GOSUB CHECK_REQD_FLDS; IF _W_FLG=0 THEN IGNORE_EXIT=1; EXIT 
20650 GOSUB REVIEW_WRITE
20660 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20670 CHANGE_FLG=0
20680 NEXT_ID=_FIRST_KEY
20690 EXIT 
20700 ! 1600 - Delete
20710 DELETE_REC:
20720 READ DATA FROM REC(IOL(_FIL_NO:KEY,ERR=*NEXT)) TO _KEY$
20730 _R_KEY$=_KEY$; TRANSLATE _R_KEY$," ",$00$
20740 MSGBOX _MSG_REC_VFYDEL1$+_R_KEY$+_MSG_REC_VFYDEL2$,_MSG_JUST_CHECK$,"?,YESNO",_X$
20750 IF _X$<>"YES" THEN RETURN 
20760 REMOVE (_FIL_NO,KEY=_KEY$,ERR=NO_SUCH)
20770 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20780 CHANGE_FLG=0
20790 NEXT_ID=_FIRST_KEY
20800 EXIT 
20810 NO_SUCH: MSGBOX _MSG_REC_NOTFND$,_FYI$,"!"; EXIT 
20820 ! 1800 - Clear record
20830 CLEAR_REC:
20840 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
20850 _CLR_FLG$="R"; GOSUB CLEAR_FIELDS
20860 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20870 CHANGE_FLG=0
20880 RETURN 
20890 ! 2000 - Browsing mode
20900 ! - Next
20910 NEXT_REC:
20920 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
20930 _KEY$=KEY(_FIL_NO,END=END_OF_FILE)
20940 READ (_FIL_NO,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
20950 CHK_ERR_NXT:IF ERR<>0 THEN EXIT ERR
20960 _D$=_MSG_NEXT$; GOSUB BUSY_CHK
20970 _KEY$=KEN(_FIL_NO,KEY=_KEY$,END=END_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
20980 END_OF_FILE: MSGBOX _MSG_END_OF_FIL$,_FYI$,"!"; EXIT 
20990 ! 2200 - Prior record
21000 PRIOR_REC:
21010 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21020 _KEY$=KEP(_FIL_NO,END=START_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
21030 CHK_ERR_PRE:IF ERR<>0 THEN EXIT ERR
21040 _D$=_MSG_PRECEDING$; GOSUB BUSY_CHK
21050 _KEY$=KEP(_FIL_NO,KEY=_KEY$,END=START_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
21060 START_OF_FILE: MSGBOX _MSG_START_FILE$,_FYI$,"!"; EXIT 
21070 ! 2400 - First record
21080 FIRST_REC:
21090 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21100 _KEY$=KEF(_FIL_NO,ERR=NO_FIRST)
21110 READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
21120 NO_FIRST: MSGBOX _MSG_REC_NO_1ST$,_FYI$,"!"; EXIT 
21130 ! 2600 - Last record
21140 LAST_REC:
21150 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21160 _KEY$=KEL(_FIL_NO,ERR=NO_LAST)
21170 READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
21180 NO_LAST: MSGBOX _MSG_REC_NO_LST$,_FYI$,"!"; EXIT 
21190 ! 3000 - Subroutines
21200 ! Processing required by READ
21210 PROCESS_READ:
21220 READ DATA FROM _KEY$ TO IOL=IOL(_FIL_NO:KEY,ERR=*NEXT) ! load fields from external key
21230 IF _ENABLE_FLG THEN _KCNT=_KEY1-1,_ENABLE_FLG=-1; GOSUB ENABLE_GROUPS
21240 READ DATA FROM REC(IOL(_FIL_NO,ERR=*NEXT)),REC=_ORIG$ TO IOL=IOL(_FIL_NO) ! Save record for review
21250 CHANGE_FLG=0
21260 RETURN 
21270 ! 3200 - Review record for changes before WRITE
21280 REVIEW_WRITE:
21290 _CHG1$="",_CHG2$=""
21300 READ (_CUR_FN,KEY=KEC(_FIL_NO),DOM=WRT)
21310 GOSUB DETERMINE_CHGS
21320 IF _CHG1$="" AND _CHG2$="" THEN GOTO WRT
21330 IF _CHG1$="" THEN GOTO CHK2
21340 MSGBOX _MSG_UPD_SAME$+SEP+_CHG1$+SEP+SEP+_MSG_OVRWRT_CHG$,_MSG_WARNING$,"Yesno,1,!",_YESNO$
21350 IF _YESNO$="NO" THEN GOTO *RETURN
21360 IF _CHG2$="" THEN GOTO WRT
21370 CHK2:IF _CHG2$<>"" THEN MSGBOX _MSG_UPD_OTHER1$+SEP+_CHG2$+SEP+SEP+_MSG_UPD_OTHER2$,_FYI$,"!"
21380 GOSUB INCORPORATE_CHGS
21390 WRT:WRITE (_FIL_NO,KEY=_KEY$,ERR=WRITE_ERROR)
21400 READ DATA FROM REC(IOL(_FIL_NO,ERR=*NEXT)),REC=_ORIG$ TO IOL=IOL(_FIL_NO) ! Save record for review
21410 GOSUB NUM_TO_STR
21420 REFRESH_FLG=1
21430 RETURN 
21440 WRITE_ERROR:
21450 IF ERR=11 THEN MSGBOX _MSG_DUP_UNIQUE$,_MSG_CANNOT_WRITE$ ELSE MSGBOX MSG(ERR),_MSG_CANNOT_WRITE$
21460 RETURN 
21470 ! 3500 - Display a record
21480 DISP_REC:
21490 GOSUB NUM_TO_STR
21500 REFRESH_FLG=1
21510 RETURN 
21520 ! 3600 - Busy Record display
21530 BUSY_CHK:
21540 MSGBOX _MSG_REC_LOCKED$+SEP+SEP+_MSG_REC_VIEW1$+_D$+_MSG_REC_VIEW2$,_MSG_REC_ACCESS$,"YESNO,!",_D$
21550 IF _D$="NO" THEN EXIT 
21560 RETURN 
21570 ! 3790 - See if changes are to be written
21580 CHECK_CHANGES:
21590 IF _FIRST_KEY=0 THEN _FIRST_KEY=ERROR_CODE.CTL,_FIRST_FIELD=DESC_1.CTL
21600 IF CHANGE_FLG=0 THEN IF _ENABLE_FLG THEN GOTO CC ELSE GOTO *RETURN
21610 MSGBOX _MSG_REC_ALTERD$,_MSG_UPDATE$,"?,Yesno",_YESNO$
21620 IF _YESNO$="YES" THEN GOTO WRITE_REC
21630 CHANGE_FLG=0
21640 CC: _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
21650 RETURN 
21660 ! 4000 - Get the current key segment number
21670 GET_CURKEY:
21680 FOR _CURKEY=1 TO _NUMKEYS
21690 IF _KEYS$[_CURKEY]=ID$+"$" OR _KEYS$[_CURKEY]=ID$ THEN EXITTO *RETURN
21700 NEXT _CURKEY
21710 RETURN 
21720 ! 9000 - Retrieve messages from the *msglib.xxx library
21730 SETUP_MESSAGES:
21740 _FYI$=MSG("FYI"),_ERROR$=MSG("ERROR")
21750 _MSG_DIRECTORY$=MSG("DIRECTORY")
21760 _MSG_END_OF_FIL$=MSG("END_OF_FIL")
21770 _MSG_FILOPNERR1$=MSG("FILOPNERR1")
21780 _MSG_JUST_CHECK$=MSG("JUST_CHECK")
21790 _MSG_MANDATORY$=MSG("MANDATORY")
21800 _MSG_NEXT$=MSG("NEXT")
21810 _MSG_NON_NUMER$=MSG("NON_NUMER")
21820 _MSG_NOT_FOUND$=MSG("NOT_FOUND")
21830 _MSG_OVRWRT_CHG$=MSG("OVRWRT_CHG")
21840 _MSG_PRECEDING$=MSG("PRECEDING")
21850 _MSG_PREFIX$=MSG("PREFIX")
21860 _MSG_REC_ACCESS$=MSG("REC_ACCESS")
21870 _MSG_REC_ALTERD$=MSG("REC_ALTERD")
21880 _MSG_REC_CR_NEW$=MSG("REC_CR_NEW")
21890 _MSG_REC_LOCKED$=MSG("REC_LOCKED")
21900 _MSG_X$=MSG("REC_MISS","^"),P=POS("^"=_MSG_X$),_MSG_REC_MISS1$=_MSG_X$(1,P-1),_MSG_REC_MISS2$=_MSG_X$(P+1)
21910 _MSG_REC_NOTFND$=MSG("REC_NOTFND")
21920 _MSG_REC_NO_1ST$=MSG("REC_NO_1ST")
21930 _MSG_REC_NO_LST$=MSG("REC_NO_LST")
21940 _MSG_REC_REMOVE$=MSG("REC_REMOVE")
21950 _MSG_REC_UPDADD$=MSG("REC_UPDADD")
21960 _MSG_X$=MSG("REC_VFYDEL","^"),P=POS("^"=_MSG_X$),_MSG_REC_VFYDEL1$=_MSG_X$(1,P-1),_MSG_REC_VFYDEL2$=_MSG_X$(P+1)
21970 _MSG_X$=MSG("REC_VIEW","^"),P=POS("^"=_MSG_X$),_MSG_REC_VIEW1$=_MSG_X$(1,P-1),_MSG_REC_VIEW2$=_MSG_X$(P+1)
21980 _MSG_REQ_FIELDS$=MSG("REQ_FIELDS")
21990 _MSG_START_FILE$=MSG("START_FILE")
22000 _MSG_UPDATE$=MSG("UPDATE")
22010 _MSG_UPD_OTHER1$=MSG("UPD_OTHER1")
22020 _MSG_UPD_OTHER2$=MSG("UPD_OTHER2")
22030 _MSG_UPD_SAME$=MSG("UPD_SAME")
22040 _MSG_WARNING$=MSG("WARNING")
22050 _MSG_CANNOT_WRITE$=MSG("CANT_WRITE")
22060 _MSG_DUP_UNIQUE$=MSG("DUP_UNIQUE")
22070 RETURN 
30000 ! 10000 - Convert numeric values to string
30010 NUM_TO_STR:
30020 RETURN 
31000 ! 11000 - Convert numeric strings to number
31010 STR_TO_NUM:
31020 RETURN 
31030 NON_NUMERIC: MSGBOX _MSG_NON_NUMER$+_X$,_ERROR$,"!"
31040 NEXT_ID=_X
31050 EXIT 
32000 ! 12000 - Check if the required fields have data
32010 CHECK_REQD_FLDS:
32020 _W_FLG=1
32030 RETURN 
33000 ! 13000 - Clear the record fields
33010 CLEAR_FIELDS:
33020 IF _CLR_FLG$="R" THEN ERROR_CODE$=""
33030 DESC_1$=""
33040 DESC_2$=""
33050 ERROR_TYPE$=""
33060 OS3_UNUSED_1$=""
33070 GOSUB NUM_TO_STR
33080 REFRESH_FLG=1
33090 RETURN 
34000 ! 14000 - Enable/Disable groups - _ENABLE_FLG: 0=don't!, >1=corresponding key segment on, others off, -1=buttons and non-key fields on
34010 ENABLE_GROUPS:
34020 IF _ENABLE_FLG=0 THEN GOTO *RETURN
34030 IF _ENABLE_FLG>0 THEN CALL "*wingrp;Disable",FIELDS.GRP$; CALL "*wingrp;Disable",BUTTONS.GRP$
34040 IF _ENABLE_FLG<0 THEN CALL "*wingrp;Enable",FIELDS.GRP$; CALL "*wingrp;Enable",BUTTONS.GRP$
34050 RETURN 
35000 ! 15000 - Determine the changes that have been made before writing
35010 DETERMINE_CHGS:
35020 DIM _CHG_VAR$(5,"N")
35030 IF _ORIG.ERROR_CODE$=_CUR.ERROR_CODE$ OR ERROR_CODE$=_CUR.ERROR_CODE$ THEN GOTO *NEXT ELSE IF _ORIG.ERROR_CODE$=ERROR_CODE$ THEN _CHG2$=_CHG2$+SEP+MSG("ERROR_CODE")+" = "+_CUR.ERROR_CODE$,_CHG_VAR$(1,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("ERROR_CODE")+" = "+_CUR.ERROR_CODE$
35040 IF _ORIG.DESC_1$=_CUR.DESC_1$ OR DESC_1$=_CUR.DESC_1$ THEN GOTO *NEXT ELSE IF _ORIG.DESC_1$=DESC_1$ THEN _CHG2$=_CHG2$+SEP+MSG("DESC")+" = "+_CUR.DESC_1$,_CHG_VAR$(2,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("DESC")+" = "+_CUR.DESC_1$
35050 IF _ORIG.DESC_2$=_CUR.DESC_2$ OR DESC_2$=_CUR.DESC_2$ THEN GOTO *NEXT ELSE IF _ORIG.DESC_2$=DESC_2$ THEN _CHG2$=_CHG2$+SEP+MSG("DESC")+" = "+_CUR.DESC_2$,_CHG_VAR$(3,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("DESC")+" = "+_CUR.DESC_2$
35060 IF _ORIG.ERROR_TYPE$=_CUR.ERROR_TYPE$ OR ERROR_TYPE$=_CUR.ERROR_TYPE$ THEN GOTO *NEXT ELSE IF _ORIG.ERROR_TYPE$=ERROR_TYPE$ THEN _CHG2$=_CHG2$+SEP+MSG("ERR_TYPE")+" = "+_CUR.ERROR_TYPE$,_CHG_VAR$(4,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("ERR_TYPE")+" = "+_CUR.ERROR_TYPE$
35070 IF _ORIG.OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$ OR OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$ THEN GOTO *NEXT ELSE IF _ORIG.OS3_UNUSED_1$=OS3_UNUSED_1$ THEN _CHG2$=_CHG2$+SEP+MSG("UNUSED")+" = "+_CUR.OS3_UNUSED_1$,_CHG_VAR$(5,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("UNUSED")+" = "+_CUR.OS3_UNUSED_1$
35080 RETURN 
36000 ! 16000 - Incorporate changes made by another user into the record
36010 INCORPORATE_CHGS:
36020 IF _CHG_VAR$(1,1)="Y" THEN ERROR_CODE$=_CUR.ERROR_CODE$
36030 IF _CHG_VAR$(2,1)="Y" THEN DESC_1$=_CUR.DESC_1$
36040 IF _CHG_VAR$(3,1)="Y" THEN DESC_2$=_CUR.DESC_2$
36050 IF _CHG_VAR$(4,1)="Y" THEN ERROR_TYPE$=_CUR.ERROR_TYPE$
36060 IF _CHG_VAR$(5,1)="Y" THEN OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$
36070 RETURN 
36100 PROCESS:
36120 GOTO 0100
36150 PROCESS_END:
36160 GOSUB WRAPUP
36180 CMD_STR$="END"
36190 RETURN 
56000 REM "207764-Tracking information from United ASN's is showing blank 
56001 REM "226811-Getting file not found ASN when in invoice entry.           
56002 REM "239076-UPS tracking link for United orders                         
56003 REM "257952-Need larger tracking number field to replace 20 character   
56004 REM "293244-WARNING: Program Exception has occurred (047, OS2ASN-2116)  
