0010 REM "<OS2INV> TEXT Purchase Order Import
0020 SETESC 9300; SETERR 9000
0035 REM "5.7 - 09/03/19 - 9.137222 - jvv - SSP# 307191
0037 REM "307191-United Invoice text file conversion to RP1 does not create  
0040 REM "Copyright 2019 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0090 CLEAR ; SETERR 0100; ENTER X3$,X4$,Q0$,Q1$
0100 IF %GUI=0 THEN SETERR 9000
0110 X0$="OS2INV",X1$="TEXT Purchase Order Import"
0120 DIM Z0$(80,"-"),FILE$[150]
0130 K0=20,K1=1
0135 C9=-1
0170 IF POS("MS"=UCS(SYS)) THEN ISWIN=1 ELSE ISWIN=0
0200 REM "
0240 IF %GUI=0 THEN CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,X0,X1,X2; IF X1>0 THEN GOTO 9920
0245 IF X3$(66,1)>"2" THEN PRECISION NUM(X3$(66,1),ERR=0246)
0295 DIM Z0$(80,X3$(235,1)); Z0$=MNM('GS')+Z0$+MNM('GE')
0299 IF %GUI=0 THEN CALL "ZZ2PRP","OS",RESULT$,DATE$; IF RESULT$<>"Y" THEN CALL "SSPROM",".4",X3$,Z,"Access Denied! the Office Supply Interface System is not an installed module.","","",0; RUN "ZMENU"
0300 REM "IOLISTS
0310 IOLIST A$; REM "EM1
0320 IOLIST B$
0330 IOLIST C$
0340 IOLIST FS1$,FS1[0],FS1[1],FS1[2],FS1[3],FS1[4],FS1[5],FS1[6],FS1[7],FS1[8],FS1[9],FS1[10],FS1[11],FS1[12],FS1[13]
0350 IOLIST FS2$,FS2[0],FS2[1],FS2[2],FS2[3],FS2[4],FS2[5],FS2[6],FS2[7],FS2[8],FS2[9],FS2[10],FS2[11],FS2[12],FS2[13],FS2[14],FS2[15],FS2[16],FS2[17],FS2[18],FS2[19],FS2[20],FS2[21],FS2[22],FS2[23],FS2[24],FS2[25],FS2[26],FS2[27],FS2[28],FS2[29]
0420 IOLIST I$
0500 REM "FILES
0505 DIM Z[NUM(X3$(60,3))]
0509 REM "Slot 1 used for ED0 file opened in 1000's, slot 2 used for text file created in 700's to write to
0510 Z$="13O ZZPARM  20O FS2...  21O FS1...  22O FMP...  25O OSD...  26O ASQ...  27O AR4...  "
0520 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; ON Z0 GOTO 0521,9900
0600 REM "
0610 IF %GUI=0 THEN GOSUB 6000
0620 PARM$=X3$(9,3)+"OSP"
0640 IF Q1$="" AND %GUI=0 THEN CALL "ZZPROM",".Y",X3$,Z,"Proceed?","","",0; ON Z GOTO 0641,9900
0700 NAME_1$="RP1.",EXT_1=1
0705 TEXT$=%DATAPATH$+DLM+NAME_1$+STR(EXT_1:"000")
0710 SERIAL TEXT$,0,0,ERR=0711; GOTO 0712; REM "Create text file to write to
0711 EXT_1=EXT_1+1; GOTO 0705
0720 Z$="02CU 02O "+TEXT$+" "
0730 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; ON Z0 GOTO 0731,9900
0740 CLOSE (Z[2]); OPEN LOCK (Z[2],OPT="TEXT")TEXT$; REM "Re-open as a text file
0800 REM "Set Prefix
0900 REM "Read ZZPARM file for DIRectory and hex codes
0910 READ (Z[13],KEY=PARM$,DOM=0911)IOL=0420
0911 READ (Z[13],KEY=X3$(9,3)+"A/R",DOM=0912)AR_PARM$
0912 READ (Z[13],KEY=X3$(9,3)+"F/M",DOM=0913)FM_PARM$
0913 READ (Z[13],KEY=X3$(9,3)+"AR1",DOM=9900)ARPARM2$
0915 ELEMENT_SEPARATOR$=ATH("2A"),SEGMENT_TERMINATOR$=ATH("5E"); REM "Setup for original values:  * and ^ respectively
0920 REM "IF I$(309,2)<>"  " THEN ELEMENT_SEPARATOR$=ATH(I$(309,2))
0925 REM "IF I$(311,2)<>"  " THEN SEGMENT_TERMINATOR$=ATH(I$(311,2))
0950 INV_FF=0; IF I$(649,1)="Y" THEN INV_FF=1 ! WO237030
1000 REM "Get list of .exp files to process
1001 %OS2INV$="YES"
1002 %OS2INV=1; REM SET so it won't display in FM2ODZ
1005 I=-1,J=0
1010 IMPORT_PATH$=STP(I$(68,30),1)
1015 SELECT AT$ FROM IMPORT_PATH$
1030 IF AT$<>"." AND AT$<>".." AND POS("INV"=AT$)<>0 THEN FILE$[I+1]=AT$; I=I+1
1035 NEXT RECORD 
1036 SLOT=UNT
1060 CLOSE (SLOT); OPEN LOCK (SLOT,OPT="TEXT",ERR=1900)IMPORT_PATH$+FILE$[J]; REM "Open for reading raw file
1065 CLOSE (13); OPEN (13)"ZZPARM"; REM "Re-open ZZPARM closed in ZZ2BLS
1075 IF %GUI=0 THEN PRINT @(15,15),'CE',"Processing: "+FILE$[J]
1080 GOSUB 8100; GOSUB 8150
1100 REM "Process the file
1102 DIM INV_REC$(240); INV_REC$=PAD(INV_REC$,240)
1105 C=1,SEGMENT$=""
1110 READ (SLOT,END=1900)SEGMENT$
1120 C=C+1; GOSUB 8150
1130 IF SEGMENT$(1,3)="EOF" THEN GOTO 1100
1150 ON CSE(SEGMENT$(1,2),"1 ","1A","2 ","2B","3 ") GOSUB 2000,2010,2300,2500,2700,2800
1160 GOTO 1110
1900 REM "End of file
1902 C=T; GOSUB 8150
1930 REM "Remove the file
1931 CLOSE (SLOT,ERR=1932)
1932 IF STP(FILE$[J],3)="" THEN GOTO 5000
1935 REM "IF ISWIN THEN S2$="copy "+FILE$[J]+" "+HWD+DLM+"editmp"+DLM; CALL "ZZ2CMD",X3$,X4$,S2$,"","IN",COMM_CODE,COMM_CODE$; GOTO 1950; REM "SSP146619, If NT call command processor so command will happen on server 
1939 OUT$="."+DTE(0:"%Y%Mz%Dz%Hz%mz%sz"); PRECISION 2
1940 RENAME IMPORT_PATH$+FILE$[J] TO HWD+DLM+"editmp"+DLM+FILE$[J]+OUT$
1945 ERASE IMPORT_PATH$+FILE$[J],ERR=1946
1985 J=J+1
1995 GOTO 1060
2000 REM NOT AVAILABLE
2001 REM =============
2002 RETURN 
2003 REM 
2010 REM TEXT INVOICE HEADER
2020 REM ===================
2030 REM 
2040 DIM INV_NUM$(10),INV_DATE$(8),PO_NUM$(9),SOURCE$(3),VER$(3)
2042 REM 
2044 REM "IF ISWIN THEN S2$="copy "+HWD+DLM+"import"+DLM+FILE$[J]+" "+HWD+DLM+"editmp"+DLM; CALL "ZZCMD",X3$,X4$,S2$,"","IN",COMM_CODE,COMM_CODE$; GOTO 2050
2046 REM "RENAME IMPORT_PATH$+DLM+FILE$[J] TO HWD+DLM+"editmp"+DLM
2050 REM 
2055 SOURCE$="EXT"; VER$="100"
2060 INV_NUM$=PAD(SEGMENT$(13,7),10)
2070 PO_NUM$=SEGMENT$(30,22); INV_DATE$=SEGMENT$(4,8)
2073 PO_NUM$=STP(PO_NUM$,1," ")
2075 PO_NUM$=PAD(STP(PO_NUM$,3,"-"),9,0,"0")
2080 REM 
2090 INV_REC$(1,3)=SOURCE$; INV_REC$(4,3)=VER$
2100 INV_REC$(7,9)=PO_NUM$; INV_REC$(25,10)=INV_NUM$
2101 INV_REC$(57,10)=INV_NUM$; REM SSP194096 - default Vendor Job to vendor invoice number
2102 INV_REC$(69,8)=INV_DATE$; REM SSP 194096 default Job Dat to Vendor Invoice date
2110 INV_REC$(35,8)=INV_DATE$
2120 REM 
2130 REM "PRINT (Z[2])INV_REC$
2300 REM 
2310 REM INVOICE HEADER NOTES
2320 REM ====================
2330 REM 
2340 RETURN 
2500 REM SSP 307191
2510 REM INVOICE DETAIL          
2520 REM ==============
2522 ITEM$=SEGMENT$(28,15)
2524 ESS_LINENUM$=PAD(STP(SEGMENT$(4,5),1),3,0,"0")
2526 ST_LINE$=""
2530 READ (Z[25],KEY=ITEM$,DOM=*NEXT)
2535 OSD_KEY$=KEY(Z[25],END=*NEXT)
2538 IF OSD_KEY$(1,LEN(ITEM$))<>ITEM$ THEN GOTO NOT_FOUND
2540 TF_ITEM$=OSD_KEY$(22,10)
2542 READ (Z[20],KEY=PO_NUM$(1,8),DOM=*NEXT)
2545 READ_NEXT:
2548 FS2_KEY$=KEY(Z[20],END=NOT_FOUND)
2550 IF FS2_KEY$(1,8)<>PO_NUM$(1,8) THEN GOTO NOT_FOUND
2552 READ (Z[20],KEY=FS2_KEY$)FS2$
2554 IF FS2$(19,10)<>TF_ITEM$ THEN GOTO READ_NEXT ELSE ST_LINE$=FS2_KEY$(9,3)
2556 IF FS2_KEY$(9,3)=ESS_LINENUM$ THEN GOTO VALID_REC
2558 GOTO READ_NEXT
2560 VALID_REC:
2562 PO_LINENUM$=FS2_KEY$(9,3); UM$=FS2$(124,4); GOTO REC_SETUP
2565 NOT_FOUND:
2566 UM$=DIM(4); IF ST_LINE$="" THEN PO_LINENUM$=PAD(STP(SEGMENT$(10,3),1),3,0,"0") ELSE PO_LINENUM$=ST_LINE$; REM "UM$=FS2$(124,4)
2568 IF PAD(SEGMENT$(25,2),4)="DZ" THEN UM$="DZ  "
2570 REC_SETUP:
2572 QTY_REC=NUM(SEGMENT$(17,7)); UNIT_COST=NUM(SEGMENT$(105,8))
2575 IF QTY_REC=0 THEN GOTO 2650
2576 ! IF UM$="DZ  " THEN QTY_REC=QTY_REC*12; !SSP307191
2577 UM$=""
2580 EXT_COST=QTY_REC*UNIT_COST
2590 REM 
2600 INV_REC$(16,3)=PO_LINENUM$; INV_REC$(98,7)=PAD(STR(QTY_REC),7,0,"0")
2602 REM "INV_REC$(16,3)=PO_LINENUM$; INV_REC$(87,4)=UM$; INV_REC$(98,7)=PAD(STR(QTY_REC),7,0,"0")
2608 REM IF UM$<>DIM(4) THEN INV_REC$(87,4)=UM$; REM SSP
2610 INV_REC$(127,10)=PAD(STR(UNIT_COST),10,0,"0"); INV_REC$(137,10)=PAD(STR(EXT_COST),10,0,"0")
2620 INV_REC$(223,8)=INV_DATE$
2630 PRINT (Z[2])INV_REC$
2640 REM 
2650 RETURN 
2700 REM 
2710 REM INVOICE DETAIL NOTES
2720 REM ====================
2730 REM 
2740 RETURN 
2800 REM 
2801 PRICE=0
2802 DIM FS1[13]
2804 READ (Z[21],KEY=PO_NUM$(1,8),DOM=4999)IOL=0340
2805 EXTRACT (Z[21],KEY=PO_NUM$(1,8))IOL=0340; REM "EXTRACT ORDER HEADER
2810 REM INVOICE TRAILER
2825 GOSUB 8800
2830 REM 
2831 PRICE$=""
2835 IF POS(X3$(9,3)="092088500118")=0 THEN GOTO 2850; REM If the Freight Markup Table is set to 00, the price of the freight imported from the vendor invoice will always be set to zero
2840 DIM FMPD[1]; READ (Z[22],KEY="D"+FS1$(6,10),DOM=2850)FMPD$,FMPD[0]; REM SSP FOR 118 WP237030
2842 IF FMPD$(50,2)="00" THEN PRICE$="NO"; REM this is the freight markup table from the customer defaults
2850 FRT_CHARGE=0; REM SSP 184766
2870 FRT_CHARGE=NUM(SEGMENT$(48,8))
2871 IF POS(X3$(9,3)="092132088499500118487601")<>0 AND FS1[6]<50 THEN PRICE=FRT_CHARGE; REM common practice if order total is less than $50, then they pay for freight
2872 IF PRICE$="NO" THEN PRICE=0; REM 
2875 IF FRT_CHARGE<>0 THEN CODE$=I$(237,10); AMOUNT=FRT_CHARGE
2876 IF AMOUNT<>0 THEN GOSUB 8400
2877 REM FS1[8]=FRT_CHARGE; WRITE (Z[21],KEY=PO_NUM$(1,8))IOL=0340
2878 FRT_CHARGE=0; REM ,PRICE=0
2880 DROP_CHARGE=NUM(SEGMENT$(57,6)); AMOUNT=DROP_CHARGE
2882 IF DROP_CHARGE<>0 THEN CODE$=I$(247,10)
2884 IF AMOUNT<>0 THEN GOSUB 8400
2890 WRAP_AND_LABEL=NUM(SEGMENT$(64,8))
2892 IF WRAP_AND_LABEL<>0 THEN CODE$=I$(257,10); AMOUNT=WRAP_AND_LABEL
2894 IF AMOUNT<>0 THEN GOSUB 8400
2900 MIN_CHARGE=NUM(SEGMENT$(73,6))
2902 IF MIN_CHARGE<>0 THEN CODE$=I$(267,10); AMOUNT=MIN_CHARGE
2904 IF AMOUNT<>0 THEN GOSUB 8400
2910 TAX=NUM(SEGMENT$(80,8))
2912 IF TAX<>0 THEN CODE$=I$(277,10); AMOUNT=TAX
2914 IF AMOUNT<>0 THEN GOSUB 8400
2920 DESK_TOP=NUM(SEGMENT$(97,8))
2922 IF DESK_TOP<>0 THEN CODE$=I$(287,10); AMOUNT=DESK_TOP
2924 IF AMOUNT<>0 THEN GOSUB 8400
2930 GIFT_WRAP=NUM(SEGMENT$(106,8))
2932 IF GIFT_WRAP<>0 THEN CODE$=I$(297,10); AMOUNT=GIFT_WRAP
2934 IF AMOUNT<>0 THEN GOSUB 8400
2940 INSIDE=NUM(SEGMENT$(115,8))
2942 IF INSIDE<>0 THEN CODE$=I$(307,10); AMOUNT=INSIDE
2944 IF AMOUNT<>0 THEN GOSUB 8400
2950 STENCIL=NUM(SEGMENT$(124,8))
2952 IF STENCIL<>0 THEN CODE$=I$(317,10); AMOUNT=STENCIL
2960 SHRINK=NUM(SEGMENT$(133,8)) ! ssp 307187
2962 IF SHRINK<>0 THEN CODE$=I$(327,10); AMOUNT=SHRINK
2964 IF AMOUNT<>0 THEN GOSUB 8400
2970 ADD_CHG1=NUM(SEGMENT$(142,8))
2972 IF ADD_CHG1<>0 THEN CODE$=I$(337,10); AMOUNT=ADD_CHG1
2974 IF AMOUNT<>0 THEN GOSUB 8400
2980 ADD_CHG2=NUM(SEGMENT$(151,8))
2982 IF ADD_CHG2<>0 THEN CODE$=I$(347,10); AMOUNT=ADD_CHG2
2984 IF AMOUNT<>0 THEN GOSUB 8400
2990 ADD_CHG3=NUM(SEGMENT$(160,8))
2992 IF ADD_CHG3<>0 THEN CODE$=I$(357,10); AMOUNT=ADD_CHG3
2994 IF AMOUNT<>0 THEN GOSUB 8400
3000 ADD_CHG4=NUM(SEGMENT$(169,8))
3002 IF ADD_CHG4<>0 THEN CODE$=I$(367,10); AMOUNT=ADD_CHG4
3004 IF AMOUNT<>0 THEN GOSUB 8400
3010 ADD_CHG5=NUM(SEGMENT$(178,8))
3012 IF ADD_CHG5<>0 THEN CODE$=I$(377,10); AMOUNT=ADD_CHG5
3014 IF AMOUNT<>0 THEN GOSUB 8400
3050 REM "CALL "FM2ODH",X3$,1,FS1$,FS1{ALL}; REM "Update line effects->145487 moved
3840 AMT_SUB_DISC=NUM(SEGMENT$(15,10))
3841 IF AMT_SUB_DISC<>0 THEN AMOUNT=AMT_SUB_DISC; LINE$="D01"; GOSUB 8500
3850 DISC_AMT_DUE=NUM(SEGMENT$(26,10))
3851 IF DISC_AMT_DUE<>0 THEN AMOUNT=DISC_AMT_DUE; LINE$="D02"; GOSUB 8500
3860 TERMS_DISCOUNT_AMT=NUM(SEGMENT$(37,10))
3861 IF TERMS_DISCOUNT_AMT<>0 THEN AMOUNT=TERMS_DISCOUNT_AMT; LINE$="D03"; GOSUB 8500
3889 FS1$(232,5)="DB"
3900 CALL "FM2ODH",X3$,1,FS1$,FS1{ALL},"OS"; REM "Update line effects->145487 moved ; !SSP 307192
4999 RETURN 
5000 REM "EOJ
5001 REM "XFD$=FN%XFD$(Z[2],0),TOT_REC=DEC(XFD$(38,4))
5003 CLOSE (Z[2],ERR=5004)
5004 REM IF TOT_REC=0 THEN ERASE TEXT$; GOTO 5012
5005 NAME_2$="FO1.",EXT_2=1
5007 REM "GOR$=NAME_2$+STR(EXT_2:"000")
5010 REM RENAME TEXT$,GOR$,ERR=5011; GOTO 5012; REM "Rename the ED1 file we wrote to, to an FO1 file to be used in the Order Requisition Gateway
5011 REM EXT_2=EXT_2+1; GOTO 5007
5015 C=T; GOSUB 8150
5020 REM "IF Q1$="" THEN CALL "ZZPROM",".4",X3$,Z,"PROCESS COMPLETE!!","","",0
5040 GOTO 9900
6000 REM "BACKGROUND
6005 PRINT (0,ERR=6016)'SB',
6020 PRINT @(10,7),"Translating Incoming Text Invoice from Office Supply Vendor"
6165 PRINT (0,ERR=6166)'SF',
6190 RETURN 
7500 REM "Convert date q$ into q0$
7501 REM "Q$ in YYYYMMDD format or YYMMDD
7505 Q0$=""
7506 IF STP(Q$,3," ")="" THEN GOTO 7545
7510 IF LEN(Q$)=8 THEN GOTO 7520 ELSE IF LEN(Q$)=6 THEN D1$=STR(NUM(Q$(1,2)):"00") ELSE GOTO 7545
7515 IF D1$<"50" THEN Q$="20"+Q$ ELSE Q$="19"+Q$
7520 Q0$=CHR(NUM(Q$(1,3),ERR=7521)-125)+Q$(4,1)+Q$(5,2)+Q$(7,2)
7545 RETURN 
7600 REM ITEM CODE CROSS REFERENCE LOOK-UP
7610 REM =================================
7615 DIM C$(168)
7620 K$=KEY(Z[5],END=7700)
7630 READ (Z[5],KEY=K$,DOM=7700)
7640 IF K$(1,10)<>VEND$ THEN GOTO 7620
7645 IF K$(15,20)<>ITEM_CODE$ THEN GOTO 7620
7660 READ (Z[20],KEY=PO_NUM$+"   ",DOM=7620)IOL=0330
7670 IF C$(101,10)<>K$(45,10) THEN GOTO 7660
7680 PO_LINE$=PAD(C$(7,3),3,0,"0")
7700 IF PO_LINE$="   " THEN PO_LINE$=PAD(ELEMENT$[2],3,0,"0")
7701 PO_LINE$=PAD(ELEMENT$[2],3,0,"0"); REM TEST
7710 RETURN 
7800 REM Set Commission Code
7810 FS2$(128,5)=FS1$(97,5)
7815 IF ARPARM2$(122,1)="Y" THEN FIND (Z[26],KEY=FS1$(93,4)+FS2$(29,3),DOM=*NEXT)ASQ$; FS2$(128,5)=ASQ$(8,5); REM " Substitute commission code by productcode by salesperson.
7822 DIM FMPT$(48); READ (Z[22],KEY="T"+FS2$(29,3),DOM=*NEXT)FMPT$
7823 C3$=FS2$(9,1)+FS2$(155,1)+X3$(9,3)+FS1$(97,5)
7824 CALL "AR2COM","DEFAULT",C3$,FS2{ALL},Z[13],0,0
7826 IF C3$<>DIM(5) THEN FS2$(128,5)=C3$
7828 IF FM_PARM$(186,1)="Y" AND POS(" "<>MID(FMPT$,38,5))>0 THEN FS2$(128,5)=FMPT$(38,5); REM "Commission code 
7840 RETURN 
8100 REM "GOSUB here, once, at the beginning, after the background is set and before the Proceed? question. Set T to total # to do (by calling ZZINFO) and T0 to the reporting interval (report every T0 number of records) this is typically 2% of total; This also prints a message (@8115),so adjust accordingly
8110 T=0; CALL "ZZ2FNC;SERIALRECCNT",SLOT,T
8115 IF %GUI=0 THEN PRINT @(0,7),"There are "+STR(T)+" records to process"
8129 REM "Set T0, we make sure T0 is > 1, because later on we MOD and look for avalue of 1. IF T0 is 1, then nothing would get reported. We look for a result of 1 because this causes the first record to automatically start the reporting instead of waiting until the T0'th record to get the first report
8130 T0=INT(T*.02); IF T0<=1 THEN T0=2
8145 RETURN 
8150 REM "Call this each time to update the bar graph. Display horiz. bar graph given total #, T and current #, C, and time counter T1 (T1 is init'ed here and used here, just don't use it somewhere else)
8155 IF %GUI THEN CALL "ZZBARG",X3$,"HG",6.5,7,25,T1,T,C ELSE CALL "ZZBARG",X3$,"H",19,10,50,T1,T,C
8195 RETURN 
8400 REM "READ FMP FILE FOR SPECIAL CHARGE
8401 FS1$(232,5)="DB"
8402 CALL "FM2ODH",X3$,-1,FS1$,FS1{ALL},"OS"; REM "Update line effects->145487 moved; !SSP 307192
8405 DIM FS2$(356),FS2[29]
8410 DIM FMP[3]; READ (Z[22],KEY="X"+CODE$,DOM=8799)FMP$,FMP[0],FMP[1],FMP[2]
8412 FS2$(147,8)=PO_NUM$(1,8); REM " ORDER NUMBER
8414 FS2$(3,1)="Y"; REM "ORDER COMPLETE?
8416 FS2$(4,1)="Y"; REM " FIXED PRICE
8418 FS2$(5,1)=" "; REM "CUSTOMER FORM LINE TYPE
8420 FS2$(6,3)=LINE$; REM " ORDER LINE NUMBER
8422 FS2$(9,1)=PO_NUM$(9,1); REM " PO NUMBER
8423 FS2$(14,1)="N"
8424 FS2$(18,1)="N"; REM " SPECIAL SHIPPING
8426 FS2$(19,10)=CODE$; REM " SPECIAL CODE
8428 FS2$(156,5)="SI"; REM " PRINT FLAGS
8430 FS2$(161,10)=DIM(10); REM " CUSTOMER FOR CUSTOMER SPECIFIC INVENTORY
8431 Q$=INV_DT$; GOSUB 7500
8432 FS2$(171,12)=DIM(12); FS2$(183,6)=Q0$; REM "VENDOR JOB NUMBER AND DATE                        
8434 FS2$(155,1)="S"; REM "SPECIAL 
8436 FS2$(136,1)=FS1$(86,1); REM " LINE TAXABLE
8437 FS2$(94,10)=I$(58,10); REM " VENDOR
8439 FS2$(120,4)=FMP$(55,4); REM "UOM
8440 FS2$(4,1)="Y"; REM " FIXED PRICE
8441 FS2$(124,4)=FMP$(55,4); REM " UOM
8442 FS2$(14,1)=""; REM " CUSTOM
8444 FS2$(18,1)="N"; REM " SPECIAL SHIPPING
8446 REM "FS2$(10,4)="0001"; REM " LAST WAREHOUSE
8448 FS2$(50,40)=FMP$(12,40); REM " SPECIAL CHARGE DESCRIPTION
8450 FS2$(29,3)=FMP$(52,3); REM " PRODUCT CODE
8452 FS2$(133,1)=FMP$(59,1); REM " KEEP ORDER HISTORY
8453 GOSUB 7800; REM "Set Commission Code
8454 FS2[0]=0,FS2[10]=0; REM " CLEAR OPEN AND ORIGINAL QTY
8456 FS2[2]=1,FS2[5]=1,FS2[6]=0
8457 FS2[6]=PRICE
8458 FS2[3]=AMOUNT,FS2[1]=0
8459 IF INV_FF THEN IF STP(MID(FMPD$,13,10),2)<>"" THEN FS2$(135,1)=FMPD$(12,1),FS2$(137,10)=FMPD$(13,10),FS2[11]=FMPD[0] ! WO237030
8460 WRITE (Z[20],KEY=FS2$(147,8)+FS2$(6,3),DOM=8470)IOL=0350; GOTO 8490
8470 FS2$(6,3)=STR(NUM(FS2$(6,3))+1:"000")
8475 LINE$=FS2$(6,3)
8480 GOTO 8460
8490 REM "LINE$=STR(NUM(FS2$(6,3))+1:"000")
8500 REM " WRITE OUT THE CIG PLUS RECORD
8510 DIM INV_REC$(240); INV_REC$=PAD(INV_REC$,240)
8520 INV_REC$(1,3)=SOURCE$; INV_REC$(4,3)=VER$
8530 INV_REC$(7,9)=PO_NUM$; INV_REC$(25,10)=INV_NUM$
8540 INV_REC$(35,8)=INV_DATE$
8543 FS2$(233,1)="Y"; REM "LINE CREATED FROM INCOMING UNITED INVOICE - WILL BE USED TO DETERMINE IF TOPS TYPE OR OTHER WHEN WRITING TO THE NEW FREIGHT FILE
8550 INV_REC$(16,3)=LINE$; INV_REC$(98,7)=PAD(STR(1),7,0,"0")
8551 REM "INV_REC$(16,3)=LINE$; INV_REC$(87,4)=UM$; INV_REC$(98,7)=PAD(STR(1),7,0,"0")
8552 REM "IF UM$<>DIM(4) THEN INV_REC$(87,4)=UM$; REM SSP
8555 REM "INV_REC$(98,7)=PAD(STR(1),7,0,"0")
8560 INV_REC$(127,10)=PAD(STR(AMOUNT),10,0,"0"); INV_REC$(137,10)=PAD(STR(AMOUNT),10,0,"0")
8570 INV_REC$(86,1)="N"; REM Set to complete
8575 INV_REC$(223,8)=INV_DATE$
8600 PRINT (Z[2])INV_REC$
8610 AMOUNT=0
8650 IF LINE$(1,1)="D" THEN LINE$=""; GOTO 8799
8798 LINE$=STR(NUM(FS2$(6,3))+1:"000")
8799 RETURN 
8800 REM " FIND NEXT ORDER LINE
8810 READ (Z[20],KEY=PO_NUM$(1,8),DOM=8811)
8815 Q7$=""
8820 Q6$=KEY(Z[20],END=8830); READ (Z[20])
8825 IF MID(Q6$,1,8)=MID(PO_NUM$,1,8) THEN Q7$=Q6$; GOTO 8820
8830 IF Q7$="" THEN LINE$="001" ELSE LINE$=STR(NUM(Q7$(9,3))+1:"000")
8899 RETURN 
8950 DEF FNS$(Z9$)=Z9$(1,POS("     "=Z9$+"     ")-1)
9000 REM "ERROR PROCESSING
9005 IF ERR=69 THEN GOTO 9500
9010 Y5=ERR,Y6=TCB(5)
9015 SETERR 9016; Y8$=LST(PGM(Y6))
9016 SETERR 9000
9040 CALL "ZZERRM",Y8$,X0$,Y7$,X3$,Y5,Y6,Y7,Y8,0
9045 REM 
9050 ON Y7 GOTO 9060,9100,9800,9070,9090
9055 REM 
9060 RETRY 
9070 SETERR 9080
9075 EXECUTE Y7$
9080 SETERR 9000; RETRY 
9090 SETERR 0000; RETRY 
9100 REM " TRANSFER CONTROL
9180 GOTO 0990
9190 GOTO 9800
9300 SETESC 9350
9310 SETERR 9350
9315 IF X3$(47,1)="N" THEN RETURN ELSE SETESC 0000; RETURN 
9350 SETERR 9000; RETURN 
9500 REM "CTRL LOGIC
9510 SETERR 9000; GOSUB 6400
9520 ON C9 GOTO 1140,2040
9900 REM "END PROGRAM
9901 %OS2INV$=""
9902 %OS2INV=0
9910 CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
9920 IF %GUI THEN GOTO PROCESS_END
9930 SETERR 9940; Q1$=A1$
9940 SETESC 9350
9950 RUN "ZMENU"
9999 END 
20000 ! 100 - Initialization
20010 INIT:
20012 %OS2INV$="YES"
20015 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,-1,X1,X2; IF X1>0 THEN CMD_STR$="END"; GOSUB WRAPUP; GOTO *RETURN
20020 _SV_KR=PRM('KR'); SET_PARAM 'KR'=0 ! Ensure native handling of KEP()
20030 GOSUB SETUP_LIBRARY; IF %FLMAINT_MSG$<>"" THEN MESSAGE_LIB %FLMAINT_MSG$
20055 CALL "ZZ2PRP","OS",RESULT$,DATE$; IF RESULT$<>"Y" THEN MSGBOX "","TOPS Module is not installed"; CMD_STR$="END"; GOSUB WRAPUP; GOTO *RETURN
20082 DIM Z[NUM(X3$(60,3))]
20090 RETURN 
20100 OPEN_ERR: MSGBOX _MSG_FILOPNERR1$+QUO+_FILE_NAME$+QUO+SEP+_MSG_DIRECTORY$+LWD+SEP+_MSG_PREFIX$+PFX,MSG(ERR),"!"
20110 CMD_STR$="END"
20120 RETURN 
20130 ! 300 - Set up the message library
20140 SETUP_LIBRARY:
20150 _SV_MSGLIB$=MSG(*)
20160 _LANG$=LCS(%NOMAD_DEF_SFX$); IF _LANG$="" THEN _LANG$=LCS(ENV("PVXLANG")); IF _LANG$="" THEN _LANG$=LCS(ENV("LANG")); IF _LANG$="" THEN _LANG$="en"
20170 MESSAGE_LIB "*tfmsglib."+_LANG$,ERR=*NEXT; GOTO 20190
20180 MESSAGE_LIB "*tfmsglib.en"
20190 SET_MSG:GOSUB SETUP_MESSAGES
20200 RETURN 
20210 ! 400 - Set up key information
20220 SETUP_KEYS:
20230 _NUMKEYS=1
20240 DIM _KEYS$[1:1]; _KEYS$[1]="ERROR_CODE$"
20250 _KEY1=1
20260 RETURN 
20270 ! 500 - Main panel post_display logic
20280 MAIN_POST_DISPLAY:
20290 MESSAGE_LIB _SV_MSGLIB$
20300 GOSUB CLEAR_REC
20310 IF ARG_1$="" THEN _ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS; GOTO *RETURN
20320 _KEY$=ARG_1$; READ (_FIL_NO,KEY=_KEY$,ERR=NEXT_REC)
20330 _ENABLE_FLG=-1; GOSUB PROCESS_READ; GOSUB DISP_REC
20340 RETURN 
20350 ! 900 - Wrapup
20360 WRAPUP:
20361 %OS2INV$=""
20400 MESSAGE_LIB _SV_MSGLIB$
20410 SET_PARAM 'KR'=_SV_KR
20420 RETURN 
20430 ! 1000 - Start of maintenance only code - Find/Add/Delete/Clear record
20440 FIND_REC:
20450 CHANGE_FLG=0; IF POS(_EOM$=$000102090D$)=0 THEN RETURN ELSE GOSUB GET_CURKEY; IF _EOM$=$00$ THEN IF QRY_VAL$<>"" AND QRY_VAL$=EVS(_KEYS$[_CURKEY]) THEN QRY_VAL$="" ELSE RETURN 
20460 IF _ENABLE_FLG<0 THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1
20470 IF _ENABLE_FLG THEN IF _KCNT<_NUMKEYS THEN _KCNT=_CURKEY+1,_ENABLE_FLG=_KCNT; GOSUB ENABLE_GROUPS; RETURN ! If multiple key segments, enable the _KCNT segment
20480 READ DATA FROM REC(IOL(_FIL_NO:KEY,ERR=*NEXT)) TO _KEY$
20490 IF NUL(STP(_KEY$,1,$00$)) THEN NEXT_ID=_FIRST_KEY; RETURN 
20500 READ (_FIL_NO,KEY=_KEY$,DOM=NEW_RECORD,ERR=CHK_ERR_NXT)
20510 GOSUB PROCESS_READ
20520 GOSUB NUM_TO_STR
20530 CHANGE_FLG=0,REFRESH_FLG=1,NEXT_ID=_FIRST_FIELD
20540 EXIT 
20550 ! 1200 - New RECORD check
20560 NEW_RECORD:
20570 _CLR_FLG$="F"; GOSUB CLEAR_FIELDS
20580 IF _ENABLE_FLG THEN _KCNT=0,_ENABLE_FLG=-1; GOSUB ENABLE_GROUPS
20590 CHANGE_FLG=0,REFRESH_FLG=1,NEXT_ID=_FIRST_FIELD
20600 RETURN 
20610 ! 1400 - Add RECORD
20620 WRITE_REC:
20630 GOSUB STR_TO_NUM
20640 GOSUB CHECK_REQD_FLDS; IF _W_FLG=0 THEN IGNORE_EXIT=1; EXIT 
20650 GOSUB REVIEW_WRITE
20660 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20670 CHANGE_FLG=0
20680 NEXT_ID=_FIRST_KEY
20690 EXIT 
20700 ! 1600 - Delete
20710 DELETE_REC:
20720 READ DATA FROM REC(IOL(_FIL_NO:KEY,ERR=*NEXT)) TO _KEY$
20730 _R_KEY$=_KEY$; TRANSLATE _R_KEY$," ",$00$
20740 MSGBOX _MSG_REC_VFYDEL1$+_R_KEY$+_MSG_REC_VFYDEL2$,_MSG_JUST_CHECK$,"?,YESNO",_X$
20750 IF _X$<>"YES" THEN RETURN 
20760 REMOVE (_FIL_NO,KEY=_KEY$,ERR=NO_SUCH)
20770 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20780 CHANGE_FLG=0
20790 NEXT_ID=_FIRST_KEY
20800 EXIT 
20810 NO_SUCH: MSGBOX _MSG_REC_NOTFND$,_FYI$,"!"; EXIT 
20820 ! 1800 - Clear record
20830 CLEAR_REC:
20840 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
20850 _CLR_FLG$="R"; GOSUB CLEAR_FIELDS
20860 IF _ENABLE_FLG THEN _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
20870 CHANGE_FLG=0
20880 RETURN 
20890 ! 2000 - Browsing mode
20900 ! - Next
20910 NEXT_REC:
20920 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
20930 _KEY$=KEY(_FIL_NO,END=END_OF_FILE)
20940 READ (_FIL_NO,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
20950 CHK_ERR_NXT:IF ERR<>0 THEN EXIT ERR
20960 _D$=_MSG_NEXT$; GOSUB BUSY_CHK
20970 _KEY$=KEN(_FIL_NO,KEY=_KEY$,END=END_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
20980 END_OF_FILE: MSGBOX _MSG_END_OF_FIL$,_FYI$,"!"; EXIT 
20990 ! 2200 - Prior record
21000 PRIOR_REC:
21010 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21020 _KEY$=KEP(_FIL_NO,END=START_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
21030 CHK_ERR_PRE:IF ERR<>0 THEN EXIT ERR
21040 _D$=_MSG_PRECEDING$; GOSUB BUSY_CHK
21050 _KEY$=KEP(_FIL_NO,KEY=_KEY$,END=START_OF_FILE); READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
21060 START_OF_FILE: MSGBOX _MSG_START_FILE$,_FYI$,"!"; EXIT 
21070 ! 2400 - First record
21080 FIRST_REC:
21090 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21100 _KEY$=KEF(_FIL_NO,ERR=NO_FIRST)
21110 READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
21120 NO_FIRST: MSGBOX _MSG_REC_NO_1ST$,_FYI$,"!"; EXIT 
21130 ! 2600 - Last record
21140 LAST_REC:
21150 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
21160 _KEY$=KEL(_FIL_NO,ERR=NO_LAST)
21170 READ (_FIL_NO,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
21180 NO_LAST: MSGBOX _MSG_REC_NO_LST$,_FYI$,"!"; EXIT 
21190 ! 3000 - Subroutines
21200 ! Processing required by READ
21210 PROCESS_READ:
21220 READ DATA FROM _KEY$ TO IOL=IOL(_FIL_NO:KEY,ERR=*NEXT) ! load fields from external key
21230 IF _ENABLE_FLG THEN _KCNT=_KEY1-1,_ENABLE_FLG=-1; GOSUB ENABLE_GROUPS
21240 READ DATA FROM REC(IOL(_FIL_NO,ERR=*NEXT)),REC=_ORIG$ TO IOL=IOL(_FIL_NO) ! Save record for review
21250 CHANGE_FLG=0
21260 RETURN 
21270 ! 3200 - Review record for changes before WRITE
21280 REVIEW_WRITE:
21290 _CHG1$="",_CHG2$=""
21300 READ (_CUR_FN,KEY=KEC(_FIL_NO),DOM=WRT)
21310 GOSUB DETERMINE_CHGS
21320 IF _CHG1$="" AND _CHG2$="" THEN GOTO WRT
21330 IF _CHG1$="" THEN GOTO CHK2
21340 MSGBOX _MSG_UPD_SAME$+SEP+_CHG1$+SEP+SEP+_MSG_OVRWRT_CHG$,_MSG_WARNING$,"Yesno,1,!",_YESNO$
21350 IF _YESNO$="NO" THEN GOTO *RETURN
21360 IF _CHG2$="" THEN GOTO WRT
21370 CHK2:IF _CHG2$<>"" THEN MSGBOX _MSG_UPD_OTHER1$+SEP+_CHG2$+SEP+SEP+_MSG_UPD_OTHER2$,_FYI$,"!"
21380 GOSUB INCORPORATE_CHGS
21390 WRT:WRITE (_FIL_NO,KEY=_KEY$,ERR=WRITE_ERROR)
21400 READ DATA FROM REC(IOL(_FIL_NO,ERR=*NEXT)),REC=_ORIG$ TO IOL=IOL(_FIL_NO) ! Save record for review
21410 GOSUB NUM_TO_STR
21420 REFRESH_FLG=1
21430 RETURN 
21440 WRITE_ERROR:
21450 IF ERR=11 THEN MSGBOX _MSG_DUP_UNIQUE$,_MSG_CANNOT_WRITE$ ELSE MSGBOX MSG(ERR),_MSG_CANNOT_WRITE$
21460 RETURN 
21470 ! 3500 - Display a record
21480 DISP_REC:
21490 GOSUB NUM_TO_STR
21500 REFRESH_FLG=1
21510 RETURN 
21520 ! 3600 - Busy Record display
21530 BUSY_CHK:
21540 MSGBOX _MSG_REC_LOCKED$+SEP+SEP+_MSG_REC_VIEW1$+_D$+_MSG_REC_VIEW2$,_MSG_REC_ACCESS$,"YESNO,!",_D$
21550 IF _D$="NO" THEN EXIT 
21560 RETURN 
21570 ! 3790 - See if changes are to be written
21580 CHECK_CHANGES:
21590 IF _FIRST_KEY=0 THEN _FIRST_KEY=ERROR_CODE.CTL,_FIRST_FIELD=DESC_1.CTL
21600 IF CHANGE_FLG=0 THEN IF _ENABLE_FLG THEN GOTO CC ELSE GOTO *RETURN
21610 MSGBOX _MSG_REC_ALTERD$,_MSG_UPDATE$,"?,Yesno",_YESNO$
21620 IF _YESNO$="YES" THEN GOTO WRITE_REC
21630 CHANGE_FLG=0
21640 CC: _KCNT=_KEY1,_ENABLE_FLG=_KEY1; GOSUB ENABLE_GROUPS
21650 RETURN 
21660 ! 4000 - Get the current key segment number
21670 GET_CURKEY:
21680 FOR _CURKEY=1 TO _NUMKEYS
21690 IF _KEYS$[_CURKEY]=ID$+"$" OR _KEYS$[_CURKEY]=ID$ THEN EXITTO *RETURN
21700 NEXT _CURKEY
21710 RETURN 
21720 ! 9000 - Retrieve messages from the *msglib.xxx library
21730 SETUP_MESSAGES:
21740 _FYI$=MSG("FYI"),_ERROR$=MSG("ERROR")
21750 _MSG_DIRECTORY$=MSG("DIRECTORY")
21760 _MSG_END_OF_FIL$=MSG("END_OF_FIL")
21770 _MSG_FILOPNERR1$=MSG("FILOPNERR1")
21780 _MSG_JUST_CHECK$=MSG("JUST_CHECK")
21790 _MSG_MANDATORY$=MSG("MANDATORY")
21800 _MSG_NEXT$=MSG("NEXT")
21810 _MSG_NON_NUMER$=MSG("NON_NUMER")
21820 _MSG_NOT_FOUND$=MSG("NOT_FOUND")
21830 _MSG_OVRWRT_CHG$=MSG("OVRWRT_CHG")
21840 _MSG_PRECEDING$=MSG("PRECEDING")
21850 _MSG_PREFIX$=MSG("PREFIX")
21860 _MSG_REC_ACCESS$=MSG("REC_ACCESS")
21870 _MSG_REC_ALTERD$=MSG("REC_ALTERD")
21880 _MSG_REC_CR_NEW$=MSG("REC_CR_NEW")
21890 _MSG_REC_LOCKED$=MSG("REC_LOCKED")
21900 _MSG_X$=MSG("REC_MISS","^"),P=POS("^"=_MSG_X$),_MSG_REC_MISS1$=_MSG_X$(1,P-1),_MSG_REC_MISS2$=_MSG_X$(P+1)
21910 _MSG_REC_NOTFND$=MSG("REC_NOTFND")
21920 _MSG_REC_NO_1ST$=MSG("REC_NO_1ST")
21930 _MSG_REC_NO_LST$=MSG("REC_NO_LST")
21940 _MSG_REC_REMOVE$=MSG("REC_REMOVE")
21950 _MSG_REC_UPDADD$=MSG("REC_UPDADD")
21960 _MSG_X$=MSG("REC_VFYDEL","^"),P=POS("^"=_MSG_X$),_MSG_REC_VFYDEL1$=_MSG_X$(1,P-1),_MSG_REC_VFYDEL2$=_MSG_X$(P+1)
21970 _MSG_X$=MSG("REC_VIEW","^"),P=POS("^"=_MSG_X$),_MSG_REC_VIEW1$=_MSG_X$(1,P-1),_MSG_REC_VIEW2$=_MSG_X$(P+1)
21980 _MSG_REQ_FIELDS$=MSG("REQ_FIELDS")
21990 _MSG_START_FILE$=MSG("START_FILE")
22000 _MSG_UPDATE$=MSG("UPDATE")
22010 _MSG_UPD_OTHER1$=MSG("UPD_OTHER1")
22020 _MSG_UPD_OTHER2$=MSG("UPD_OTHER2")
22030 _MSG_UPD_SAME$=MSG("UPD_SAME")
22040 _MSG_WARNING$=MSG("WARNING")
22050 _MSG_CANNOT_WRITE$=MSG("CANT_WRITE")
22060 _MSG_DUP_UNIQUE$=MSG("DUP_UNIQUE")
22070 RETURN 
30000 ! 10000 - Convert numeric values to string
30010 NUM_TO_STR:
30020 RETURN 
31000 ! 11000 - Convert numeric strings to number
31010 STR_TO_NUM:
31020 RETURN 
31030 NON_NUMERIC: MSGBOX _MSG_NON_NUMER$+_X$,_ERROR$,"!"
31040 NEXT_ID=_X
31050 EXIT 
32000 ! 12000 - Check if the required fields have data
32010 CHECK_REQD_FLDS:
32020 _W_FLG=1
32030 RETURN 
33000 ! 13000 - Clear the record fields
33010 CLEAR_FIELDS:
33020 IF _CLR_FLG$="R" THEN ERROR_CODE$=""
33030 DESC_1$=""
33040 DESC_2$=""
33050 ERROR_TYPE$=""
33060 OS3_UNUSED_1$=""
33070 GOSUB NUM_TO_STR
33080 REFRESH_FLG=1
33090 RETURN 
34000 ! 14000 - Enable/Disable groups - _ENABLE_FLG: 0=don't!, >1=corresponding key segment on, others off, -1=buttons and non-key fields on
34010 ENABLE_GROUPS:
34020 IF _ENABLE_FLG=0 THEN GOTO *RETURN
34030 IF _ENABLE_FLG>0 THEN CALL "*wingrp;Disable",FIELDS.GRP$; CALL "*wingrp;Disable",BUTTONS.GRP$
34040 IF _ENABLE_FLG<0 THEN CALL "*wingrp;Enable",FIELDS.GRP$; CALL "*wingrp;Enable",BUTTONS.GRP$
34050 RETURN 
35000 ! 15000 - Determine the changes that have been made before writing
35010 DETERMINE_CHGS:
35020 DIM _CHG_VAR$(5,"N")
35030 IF _ORIG.ERROR_CODE$=_CUR.ERROR_CODE$ OR ERROR_CODE$=_CUR.ERROR_CODE$ THEN GOTO *NEXT ELSE IF _ORIG.ERROR_CODE$=ERROR_CODE$ THEN _CHG2$=_CHG2$+SEP+MSG("ERROR_CODE")+" = "+_CUR.ERROR_CODE$,_CHG_VAR$(1,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("ERROR_CODE")+" = "+_CUR.ERROR_CODE$
35040 IF _ORIG.DESC_1$=_CUR.DESC_1$ OR DESC_1$=_CUR.DESC_1$ THEN GOTO *NEXT ELSE IF _ORIG.DESC_1$=DESC_1$ THEN _CHG2$=_CHG2$+SEP+MSG("DESC")+" = "+_CUR.DESC_1$,_CHG_VAR$(2,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("DESC")+" = "+_CUR.DESC_1$
35050 IF _ORIG.DESC_2$=_CUR.DESC_2$ OR DESC_2$=_CUR.DESC_2$ THEN GOTO *NEXT ELSE IF _ORIG.DESC_2$=DESC_2$ THEN _CHG2$=_CHG2$+SEP+MSG("DESC")+" = "+_CUR.DESC_2$,_CHG_VAR$(3,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("DESC")+" = "+_CUR.DESC_2$
35060 IF _ORIG.ERROR_TYPE$=_CUR.ERROR_TYPE$ OR ERROR_TYPE$=_CUR.ERROR_TYPE$ THEN GOTO *NEXT ELSE IF _ORIG.ERROR_TYPE$=ERROR_TYPE$ THEN _CHG2$=_CHG2$+SEP+MSG("ERR_TYPE")+" = "+_CUR.ERROR_TYPE$,_CHG_VAR$(4,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("ERR_TYPE")+" = "+_CUR.ERROR_TYPE$
35070 IF _ORIG.OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$ OR OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$ THEN GOTO *NEXT ELSE IF _ORIG.OS3_UNUSED_1$=OS3_UNUSED_1$ THEN _CHG2$=_CHG2$+SEP+MSG("UNUSED")+" = "+_CUR.OS3_UNUSED_1$,_CHG_VAR$(5,1)="Y" ELSE _CHG1$=_CHG1$+SEP+MSG("UNUSED")+" = "+_CUR.OS3_UNUSED_1$
35080 RETURN 
36000 ! 16000 - Incorporate changes made by another user into the record
36010 INCORPORATE_CHGS:
36020 IF _CHG_VAR$(1,1)="Y" THEN ERROR_CODE$=_CUR.ERROR_CODE$
36030 IF _CHG_VAR$(2,1)="Y" THEN DESC_1$=_CUR.DESC_1$
36040 IF _CHG_VAR$(3,1)="Y" THEN DESC_2$=_CUR.DESC_2$
36050 IF _CHG_VAR$(4,1)="Y" THEN ERROR_TYPE$=_CUR.ERROR_TYPE$
36060 IF _CHG_VAR$(5,1)="Y" THEN OS3_UNUSED_1$=_CUR.OS3_UNUSED_1$
36070 RETURN 
36100 PROCESS:
36120 GOTO 0100
36150 PROCESS_END:
36160 GOSUB WRAPUP
36180 CMD_STR$="END"
36190 RETURN 
56000 REM "SSP 184766/187122 Call to FM2ODH with extra string..don't update Order Booking file for Tops Orders
56001 REM "194096-List of Issues with importing Invoices from United  
56002 REM "213719-Installation - Office Supply Module 
56004 REM "237030-O/S System parameter to trigger customer's finders fee when 
56005 REM "307187-United invoice text file field error                        
56006 REM "307192-Office Products legacy code causes error in FM2ODH          
56007 REM "307191-United Invoice text file conversion to RP1 does not create  
