0010 ! ZZWDTE - Generic date validation/output routine
0020 ! Written by Michael F. King - Sybex Ltd
0030 ! Rev 1.0 March 1996 - MFK - Initial version
0035 REM "5.7 - 02/10/16 - 11.499722 - tma - SSP# 279934
0037 REM "279934-Order Entry is allowing an invalid dates in the Order header
0040 REM "Copyright 2016 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 VALIDATE:
0060 FIRST$="M"; IF %X3$(48,1)="2" THEN FIRST$="D"
0070 ENTER IN_DT$,ERR_MSG$,OPT_TAG$,ERR=0080
0080 IF STP(IN_DT$,1)="" THEN EXIT 
0090 IF POS(",DAY1ST,"=","+OPT_TAG$+",") THEN FIRST$="D"; IF %X3$(48,1)="2" THEN FIRST$="D"
0100 IF LEN(IN_DT$)=6 AND IN_DT$(1,1)>"9" THEN {
0110 IN_DT$=STR(DEC(IN_DT$(1,1))+125)+IN_DT$(2)
0120  }
0130 ! Take date format from %WINDATE_FMT$ or as "DAYFMT={CC}YYMMDD" from optional tag (C,Y,M & D should match format of incoming date field)
0140 X$=UCS(%WINDATE_FMT$),X=POS("DAYFMT="=UCS(OPT_TAG$)); IF X THEN X$=UCS(OPT_TAG$(X+7))
0150 X=POS("CYMD"^X$); IF X THEN X$=X$(1,X-1)
0160 IF LEN(X$)>8 THEN X$=X$(1,8) ELSE IF LEN(X$)<>6 AND LEN(X$)<>8 THEN GOTO 0200
0170 IF LEN(X$)=8 THEN IF POS("CC"=X$,2)=0 THEN X=POS("YYYY"=X$,2); IF X THEN X$(X,2)="CC" ELSE GOTO 0200 ! Invalid
0180 IF POS("YY"=X$,2) AND POS("MM"=X$,2) AND POS("DD"=X$,2) THEN _DAYFMT$=X$
0190 ! 
0200 D$="",M$="",Y$=""
0210 IF POS(SEP=IN_DT$)<>0 THEN GOTO BAD_DATE
0220 X$=STP(IN_DT$,3); TRANSLATE X$,DIM(10,SEP),"0" ! SSP#279934 
0230 IF POS(SEP<>X$)=0 THEN GOTO NUM_DATE
0240 X$=STP(UCS(IN_DT$),2) ! Strip leading/trail and convert case
0300 ! ^100 - Scan input data
0310 PARSE_DT:
0320 IF X$="" THEN GOTO CHK_DATE
0330 IF X$(1,1)>="0" AND X$(1,1)<="9" THEN GOTO NUM_FLD
0340 IF LCS(X$(1,1))=X$(1,1) THEN X$=X$(2); GOTO PARSE_DT
0400 ! ^ 100 - Alpha field -- must be month
0410 ALPHA_FLD:
0420 X1$=X$(1,1)
0430 X$=X$(2)
0440 IF X$<>"" AND Y$="" THEN IF X$(1,1)>="0" AND X$(1,1)<="9" THEN Y$=STR(2000+(ASC(UCS(X1$))-ASC("A"))*10+NUM(X$(1,1))),X$=X$(2); GOTO PARSE_DT
0450 IF X$<>"" AND LCS(X$(1,1))<>X$(1,1) THEN X1$=X1$+X$(1,1); GOTO 0430
0460 Z$=DTE(*) ! Get system date names
0470 Z$=","+UCS(Z$(1,POS(","=Z$,1,12)))
0480 M=POS(","+X1$=Z$); IF M=0 THEN GOTO BAD_DATE
0490 IF POS(","+X1$=Z$,1,2)<>0 THEN GOTO BAD_DATE ! Duplicate possible
0500 IF D$="" THEN D$=M$,M$=""
0510 IF M$<>"" THEN GOTO BAD_DATE
0520 M$=STR(POS(","=Z$(1,M),1,0))
0530 GOTO PARSE_DT
0600 ! ^ 100 - Numeric field
0610 NUM_FLD:
0620 X1$=X$(1,1)
0630 X$=X$(2)
0640 IF X$<>"" AND X$(1,1)>="0" AND X$(1,1)<="9" THEN X1$=X1$+X$(1,1); GOTO 0630
0650 IF LEN(X1$)=4 OR NUM(X1$)>31 THEN IF Y$="" THEN Y$=X1$; GOTO PARSE_DT ELSE GOTO BAD_DATE
0660 IF LEN(X1$)>2 THEN GOTO BAD_DATE
0670 IF FIRST$="M" AND M$="" THEN M$=X1$; GOTO PARSE_DT
0680 IF D$="" THEN D$=X1$ ELSE IF M$="" THEN M$=X1$ ELSE IF Y$="" THEN Y$=X1$ ELSE GOTO BAD_DATE
0690 GOTO PARSE_DT
0700 ! ^ 100 - Check parsed date
0710 CHK_DATE:
0720 IF Y$="" THEN Y$=DTE(0:"%Y")
0730 IF M$="" THEN M$=DTE(0:"%M")
0740 IF LEN(Y$)=2 THEN Y1$=DTE(%CNV_CENTURY:"%Y"),Y$=Y1$(1,2)+Y$,XXX=POS("CC"=_DAYFMT$); IF XXX<>0 AND MID(X$,XXX,2)<>Y$(1,2) THEN Y$(1,2)=MID(X$,XXX,2) ! SSP 228283
0750 IF LEN(Y$)<>4 THEN GOTO BAD_DATE
0760 D=NUM(D$,ERR=BAD_DATE),M=NUM(M$,ERR=BAD_DATE),Y=NUM(Y$,ERR=BAD_DATE)
0770 X=JUL(Y,M,D,ERR=BAD_DATE)
0780 IF X<>0 THEN IN_DT$=DTE(X:"%Y%Mz%Dz",ERR=BAD_DATE) ELSE IN_DT$="19700101" ! 228283
0781 IN_DT$=STR(CHR(NUM(IN_DT$(1,3))-125))+IN_DT$(4)
0790 EXIT 
0800 ! ^100 - Numeric dates
0810 NUM_DATE:
0820 X$=STP(IN_DT$,3) ! SSP#279934 dates should not have spaces in them
0830 IF LEN(X$)=6 THEN GOTO SIX_DIGIT
0840 IF LEN(X$)=8 THEN GOTO EIGHT_DIGIT
0850 IF LEN(X$)<>4 THEN GOTO BAD_DATE
0860 IF FIRST$="M" THEN M$=X$(1,2),D$=X$(3,2); GOTO CHK_DATE
0870 D$=X$(1,2),M$=X$(3,2); GOTO CHK_DATE
0900 ! ^100 - Six numeric
0910 SIX_DIGIT:
0920 IF LEN(_DAYFMT$)=0 THEN GOTO 0950 ELSE IF LEN(_DAYFMT$)>6 THEN X=POS("CC"=_DAYFMT$,2); IF X THEN _DAYFMT$=_DAYFMT$(1,X-1)+_DAYFMT$(X+2)
0930 Y$=X$(POS("YY"=_DAYFMT$,2),2),M$=X$(POS("MM"=_DAYFMT$,2),2),D$=X$(POS("DD"=_DAYFMT$,2),2)
0940 GOTO CHK_DATE
0950 IF X$(1,2)>"31" OR X$(1,2)="00" THEN Y$=X$(1,2),X$=X$(3) ELSE Y$=X$(5,2)
0960 IF FIRST$="M" THEN M$=X$(1,2),D$=X$(3,2); GOTO CHK_DATE
0970 D$=X$(1,2),M$=X$(3,2); GOTO CHK_DATE
1000 ! ^100 - Eigth digit
1010 EIGHT_DIGIT:
1020 IF LEN(_DAYFMT$)=8 THEN Y$=X$(POS("YY"=_DAYFMT$,2),2),M$=X$(POS("MM"=_DAYFMT$,2),2),D$=X$(POS("DD"=_DAYFMT$,2),2); GOTO CHK_DATE
1030 IF X$(3,2)>"31" OR X$(3,2)="00" OR (X$(1,2)>"12" AND FIRST$<>"D") THEN Y$=X$(1,4),X$=X$(5) ELSE Y$=X$(5,4)
1040 IF FIRST$="M" THEN M$=X$(1,2),D$=X$(3,2); GOTO CHK_DATE
1050 D$=X$(1,2),M$=X$(3); GOTO CHK_DATE
2000 ! ^1000 Error handler
2010 BAD_DATE:
2020 HINT$=""; IF M>12 AND M>=1 AND M<=31 AND D<=12 AND D>=1 THEN HINT$=SEP+SEP+"Likely you have reversed the day and month fields."+SEP; IF FIRST$="D" THEN HINT$=HINT$+"Day should be first" ELSE HINT$=HINT$+"Month should be first"
2030 ERR_MSG$="The value '"+IN_DT$+"' is not a valid date"+HINT$; EXIT 
2040 ! ^ 100
2050 TF_TODAY:
2054 ENTER DATE_STR$
2055 DATE_STR$=DTE(0:"%Yl%Mz%Dz")
2056 DATE_STR$=CHR(NUM(DATE_STR$(1,3))-125)+DATE_STR$(4)
2060 EXIT 
2070 ! ^100
2073 DISPLAY_SQL_DTE:
2076 ENTER IN_DT$,ERR_MSG$,OPT_TAG$,ERR=*NEXT
2080 IF STP(IN_DT$,1)="" THEN EXIT 
2081 IF NUM(IN_DT$,ERR=BAD_INTERNAL)=0 THEN IN_DT$=""; EXIT 
2090 OUT_FMT$="%M/%D/%Y %h:%m:%s"
2100 IN_DT$=DTE(IN_DT$:OUT_FMT$,ERR=*NEXT)
2120 EXIT 
2130 CREDIT_CARD_EXPIRY:
2140 ENTER IN_DT$,ERR_MSG$,ERR=2150
2150 IF STP(IN_DT$,1)="" THEN EXIT 
2160 LOCAL MM_NUM,YY_NUM,YSTART
2170 MM_NUM=NUM(MID(IN_DT$,1,2),ERR=BAD_CCE_MONTH)
2171 IF MM_NUM<1 OR MM_NUM>12 THEN GOTO BAD_CCE_MONTH
2180 YSTART=POS("/\":IN_DT$)
2190 IF YSTART=0 THEN YSTART=3 ELSE YSTART+=1
2200 YY_YEAR=NUM(MID(IN_DT$,YSTART,2),ERR=BAD_CCE_YEAR)
2210 EXIT 
2220 BAD_CCE_MONTH:
2230 ERR_MSG$="Invalid month entered! Enter numbers between 1 and twelve"
2240 EXIT 
2242 BAD_CCE_YEAR:
2244 ERR_MSG$="Invalid year entered! Enter numbers only"
2246 EXIT 
5000 ! 5000 - Display logic
5010 DISPLAY:
5020 IF %X3$(48,1)="1" THEN OUT_FMT$="%Mz"+%X3$(59,1)+"%Dz"+%X3$(59,1)+"%Yl" ELSE IF %X3$(48,1)="2" THEN OUT_FMT$="%Dz"+%X3$(59,1)+"%Mz"+%X3$(59,1)+"%Yl" ELSE OUT_FMT$="%Yl"+%X3$(59,1)+"%Mz"+%X3$(59,1)+"%Dz"
5030 ENTER IN_DT$,OPT_TAG$,ERR=5040
5040 IF STP(IN_DT$,1)="" THEN EXIT 
5045 IF LEN(STP(IN_DT$,1))>8 THEN IN_DT$=IN_DT$(1,6)
5050 IF LEN(IN_DT$)=6 AND IN_DT$(1,1)>"9" THEN {
5060 IN_DT$=STR(DEC(IN_DT$(1,1))+125)+IN_DT$(2)
5070  }
5080 X$=","+OPT_TAG$+","
5090 O=POS(",FMT="=X$); IF O<>0 THEN OUT_FMT$=X$(O+5),OUT_FMT$=OUT_FMT$(1,POS(","=OUT_FMT$)-1)
5100 IF LEN(IN_DT$)<>8 THEN GOTO BAD_INTERNAL
5110 Y=NUM(IN_DT$(1,4),ERR=BAD_INTERNAL),%Y=Y
5120 M=NUM(IN_DT$(5,2),ERR=BAD_INTERNAL),%M=M
5130 D=NUM(IN_DT$(7,2),ERR=BAD_INTERNAL),%D=D
5140 X=JUL(Y,M,D,ERR=BAD_INTERNAL); IF X<>0 THEN IN_DT$=DTE(X:OUT_FMT$,ERR=BAD_INTERNAL) ELSE IN_DT$="01/01/1970"
5150 EXIT 
5200 TF_QRY_DISPLAY:
5210 ! we are expecting a TF formated date w/4 extra characters on the end - being called by a QRY with FLD type column definition
5215 OUT_FMT$="%Mz/%Dz/%Yl"
5220 ENTER IN_DT$,OPT_TAG$,ERR=*NEXT
5230 IF NUL(IN_DT$) THEN EXIT ELSE IN_DT$=MID(IN_DT$,1,6)
5240 GOTO 5040
5500 ! ^500 Error handler
5510 BAD_INTERNAL: MSGBOX "The internal date value of '"+IN_DT$+"' is not a valid date","Date output error","!,TIM=2"; EXIT 
5520 ! 
6000 ! Validate Year Only ! SSP 228732
6010 VALIDATE_YEAR:
6020 ENTER IN_DT$,ERR_MSG$,OPT_TAG$,ERR=*NEXT
6030 IN_DT$=STR(CHR(NUM(IN_DT$(1,3))-125))+IN_DT$(4)
6040 EXIT 
6050 DISPLAY_YEAR:
6060 ENTER IN_DT$,OPT_TAG$,ERR=*NEXT
6070 IN_DT$=FN%FMT_TFDATE$(IN_DT$+"0101","YYYY")
6080 EXIT 
9999 END 
56000 ! "228283-Need to have date issue resolved so we don't have to        
56001 REM "279934-Order Entry is allowing an invalid dates in the Order header
