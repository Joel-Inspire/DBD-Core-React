0010 ! MODIFY FILES
0020 PROCESS "SEARCH","../KTG/KT.EN"
0030 SETERR 0040; EXIT 
0040 END 
0050 SEL_FILE:
0060 DIM V$[200]
0070 PERFORM "BRGMAA;SETUP_LIBRARY"; IF %FLMAINT_MSG$<>"" THEN MESSAGE_LIB %FLMAINT_MSG$
0080 IF %FILE_NAME$="" THEN GOSUB GET_FILES
0085 ! IF ARG_1$="1" THEN CHN_N=%CHN_N; GOTO 0100
0090 CHN_N=HFN; OPEN (CHN_N)%FILE_NAME$; GOSUB CHECK_KEY_NAME
0100 CALL "*WINGRP;ENABLE",BUTTONS.GRP$
0110 OPT$="QRY",RECSIZE$=FIN(CHN_N,"RECORD_SIZE"),RECUSED$=FIN(CHN_N,"RECORDS_USED"),KEYSIZ$=FIN(CHN_N,"KSZ"),FULL_PATH$=FIN(CHN_N,"PATHNAME"),REFRESH_FLG=1,%KEYSIZE=NUM(KEYSIZ$)
0120 CALL "ZZWIOL",CHN_N,OPT$,IOL$
0125 IF STP(IOL$)="" THEN MSGBOX "This Files: "+%FILE_NAME$+SEP+"Do Not Have Data Dictionary Definition",MSG("WARNING"),"!"; IF ARG_1$="1" THEN CMD_STR$="E" END_IF ; EXIT 
0127 IF ARG_1$="1" THEN CALL "*WINGRP;DISABLE",OPN.GRP$
0130 OPT$=OPT$+",",IOL$=IOL$+","
0140 BIOL$=IOL$,IOL$=IOL$(POS(" "=IOL$)+1)
0150 X=X.CTL,ROW=1,X'COLUMN=-1,X'ROW=-1,X'VALUE$="Print"
0160 GRID DELETE X.CTL,-1,0; GRID ADD X.CTL,0,1
0170 HIDE CONTROL X
0180 XX=POS(","=OPT$); IF XX=0 THEN SHOW CONTROL X; GRID DELETE X,0,ROW+1; CLOSE (CHN_N); OPEN (CHN_N,IOL=*)%FILE_NAME$; GOSUB FIRST_REC; RETURN 
0190 XXX=POS("],"=IOL$); IF XXX<>0 THEN TXT1$=IOL$(1,XXX-1),IOL$=IOL$(XXX+2) ELSE XXX=POS(","=IOL$); IF XXX<>0 THEN TXT1$=IOL$(1,XXX-1),IOL$=IOL$(XXX+1)
0200 XXXX=POS(":"=TXT1$); IF XXXX<>0 THEN TXT1$=TXT1$(1,XXXX-1)
0210 EXECUTE "TXT$="+OPT$(1,XX-1)
0220 TXT$=TXT$+":"
0230 COLUMN=COLUMN+1; IF COLUMN>3 THEN COLUMN=1,ROW=ROW+1; GRID ADD X,0,ROW; GRID LOCK X,0,ROW
0240 X'ROW=ROW,X'COLUMN=COLUMN,X'COLUMNWIDTH=20,X'VALUE$=TXT1$,X'BACKCOLOR$="Gray",X'CELLTYPE$="MULTI_LINE",X'ALIGN$="RIGHT",X'LOCK=1,X'ROWHEIGHT=1.5
0250 COLUMN=COLUMN+1,X'ROW=ROW,X'COLUMN=COLUMN,X'COLUMNWIDTH=20,X'VALUE$=TXT$,X'BACKCOLOR$="Gray",X'CELLTYPE$="MULTI_LINE",X'ALIGN$="RIGHT",X'LOCK=1,X'ROWHEIGHT=1.5
0260 ! COLUMN=COLUMN+1,X'COLUMN=COLUMN,X'COLUMNWIDTH=4,X'LOCK=0,X'CELLTYPE$="checkMarck",X'ROWHEIGHT=1.5
0270 ! COLUMN=COLUMN+1,X'COLUMN=COLUMN,X'COLUMNWIDTH=12,X'LOCK=0,X'CELLTYPE$="DropBox",XX$="Equal|Less Than|Greater Than|Not Equal|",X'TEXT$=XX$,X'ROWHEIGHT=1.5
0280 ! GRID WRITE X,3,ROW,XX$
0290 COLUMN=COLUMN+1,X'COLUMN=COLUMN,X'COLUMNWIDTH=50,X'CELLTYPE$="MULTI_LINE",X'LOCK=0,X'ROWHEIGHT=1.5
0300 OPT$=OPT$(XX+1),V$[ROW]=TXT1$
0310 GOTO 0180
0320 READ_REC:
2000 ! 2000 - Browsing mode
2010 ! - Next
2020 NEXT_REC:
2030 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
2040 _KEY$=KEY(CHN_N,END=END_OF_FILE)
2050 READ (CHN_N,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
2060 CHK_ERR_NXT:IF ERR<>0 THEN EXIT ERR
2070 _D$=_MSG_NEXT$; GOSUB BUSY_CHK
2080 _KEY$=KEN(CHN_N,KEY=_KEY$,END=END_OF_FILE); READ (CHN_N,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
2090 END_OF_FILE: MSGBOX _MSG_END_OF_FIL$,_FYI$,"!"; EXIT 
2200 ! 2200 - Prior record
2210 PRIOR_REC:
2220 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
2230 _KEY$=KEP(CHN_N,END=START_OF_FILE); READ (CHN_N,KEY=_KEY$,ERR=*NEXT); GOSUB PROCESS_READ; GOTO DISP_REC
2240 CHK_ERR_PRE:IF ERR<>0 THEN EXIT ERR
2250 _D$=_MSG_PRECEDING$; GOSUB BUSY_CHK
2260 _KEY$=KEP(CHN_N,KEY=_KEY$,END=START_OF_FILE); READ (CHN_N,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
2270 START_OF_FILE: MSGBOX _MSG_START_FILE$,_FYI$,"!"; EXIT 
2400 ! 2400 - First record
2410 FIRST_REC:
2420 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
2425 IF ARG_1$="1" AND %FIRST_KEY$<>"" THEN _KEY$=%FIRST_KEY$,%FIRST_KEY$=""; GOTO 2440
2430 _KEY$=KEF(CHN_N,ERR=NO_FIRST)
2440 READ (CHN_N,KEY=_KEY$,ERR=CHK_ERR_NXT); GOSUB PROCESS_READ; GOTO DISP_REC
2450 NO_FIRST: MSGBOX _MSG_REC_NO_1ST$,_FYI$,"!"; EXIT 
2600 ! 2600 - Last record
2610 LAST_REC:
2620 IF CHANGE_FLG<>0 THEN GOSUB CHECK_CHANGES
2630 _KEY$=KEL(CHN_N,ERR=NO_LAST)
2640 READ (CHN_N,KEY=_KEY$,ERR=CHK_ERR_PRE); GOSUB PROCESS_READ; GOTO DISP_REC
2650 NO_LAST: MSGBOX _MSG_REC_NO_LST$,_FYI$,"!"; EXIT 
2660 PROCESS_READ:
2670 KEY$=_KEY$,REFRESH_FLG=1
2680 READ DATA FROM _KEY$ TO IOL=IOL(CHN_N:KEY,ERR=*NEXT) ! load fields from external key
2690 RETURN 
2700 DISP_REC:
2710 FOR AA=1 TO ROW
2720 X'COLUMN=3,X'ROW=AA,X'BACKCOLOR$="White",X'VALUE$=STP(EVS(V$[AA],ERR=*NEXT)); GOTO 2740
2730 X'VALUE$=STR(EVN(V$[AA]))
2740 IF POS(V$[AA]=KEY_NAME$)<>0 THEN X'LOCK=1,X'BACKCOLOR$="Gray"
2745 REFRESH_FLG=1; NEXT AA; RETURN 
2750 BUSY_CHK:
2760 MSGBOX _MSG_REC_LOCKED$+SEP+SEP+_MSG_REC_VIEW1$+_D$+_MSG_REC_VIEW2$,_MSG_REC_ACCESS$,"YESNO,!",_D$
2770 IF _D$="NO" THEN EXIT 
2780 RETURN 
2790 CHECK_CHANGES:
2800 IF CHANGE_FLG=0 THEN GOTO *RETURN
2810 MSGBOX MSG("REC_ALTERD"),"Update","?,YESNO",OPT$
2820 IF OPT$="YES" THEN GOSUB WRITE_REC
2830 CHANGE_FLG=0
2840 RETURN 
2850 GET_FILES:CALL "/usr/lib/pvx/lib/_text/get_file",%FILE_NAME$
2870 RETURN 
2880 SEL_FILES:GOSUB GET_FILES
2885 SEL_FILES_NXT:CLOSE (CHN_N,ERR=*NEXT)
2890 HIDE CONTROL X.CTL
2900 FOR AA=1 TO ROW; GRID DELETE X.CTL,0,1; NEXT AA
2910 COLUMN=0; CLOSE (CHN_N,ERR=*NEXT)
2920 SHOW CONTROL X.CTL
2930 GOTO SEL_FILE
2940 RETURN 
2950 SEL_MODIFY:
2960 GRID SELECT READ X,COL1,ROW1
2970 IF COL1<>3 THEN GOTO *RETURN
2980 GRID FIND X,COL1,ROW1,VAL$
2990 GRID FIND X,COL1-1,ROW1,VAL1$
3000 ORIG$=STP(EVS(V$[ROW1],ERR=*NEXT)),NUM_F=0; GOTO CONT
3010 ORIG$=STR(EVN(V$[ROW1])),NUM_F=1
3020 CONT:
3030 IF VAL$=ORIG$ THEN GOTO *RETURN
3040 MSGBOX MSG("WISH")+" "+MSG("MODIFY")+" "+VAL1$+SEP+SEP+MSG("FROM")+": "+ORIG$+SEP+SEP+"    "+MSG("TO")+":"+VAL$,MSG("CONFING"),"?,YESNO",OPT$
3050 IF OPT$<>"YES" THEN X'COLUMN=COL1,X'ROW=ROW1,X'VALUE$=ORIG$; GOTO *RETURN
3060 CHANGE_FLG=1
3065 X'COLUMN=COL1,X'ROW=ROW1,X'BACKCOLOR$="Light Cyan"
3070 XXX$=V$[ROW1]; IF NUM_F=0 THEN EXECUTE XXX$+"=VAL$" ELSE EXECUTE XXX$+"=NUM(VAL$)"
3080 IF ROW1+1<=ROW THEN GRID GOTO X,3,ROW1+1; NEXT_ID=X
3090 RETURN 
3100 WRITE_REC:
3105 _KEY$=EVS(KEY_NAME$)
3110 WRITE (CHN_N,KEY=_KEY$)
3120 CHANGE_FLG=0
3130 RETURN 
3140 FROM_KEY:GOSUB CHECK_CHANGES
3150 READ (CHN_N,KEY=KEY$,DOM=*NEXT); _KEY$=KEY$; GOSUB PROCESS_READ; GOTO DISP_REC
3160 GOTO NEXT_REC
5000 ! 5000 - Delete
5010 DELETE_REC:
5020 READ DATA FROM REC(IOL(CHN_N:KEY,ERR=*NEXT)) TO _KEY$
5030 _R_KEY$=_KEY$; TRANSLATE _R_KEY$," ",$00$
5040 MSGBOX _MSG_REC_VFYDEL1$+_R_KEY$+_MSG_REC_VFYDEL2$,_MSG_JUST_CHECK$,"?,YESNO",_X$
5050 IF _X$<>"YES" THEN RETURN 
5060 REMOVE (CHN_N,KEY=_KEY$,ERR=NO_SUCH)
5070 _R_KEY$=_KEY$; TRANSLATE _R_KEY$," ",$00$; MSGBOX _MSG_REC_REMOVE$+_R_KEY$,_FYI$,"INFO"
5080 CHANGE_FLG=0
5090 NEXT_ID=_FIRST_KEY
5100 EXIT 
5110 NO_SUCH: MSGBOX _MSG_REC_NOTFND$,_FYI$,"!"; EXIT 
6000 CHECK_KEY_NAME:
6010 I=-1,KEY_NAME$=""
6020 RD:DICTIONARY READ (CHN_N,IND=I,ERR=END_READ)IOL=6090
6030 IF DDF_TYPE$="S" THEN S$="$" ELSE S$=""
6040 KEY_NAME$=KEY_NAME$+DDF_NAME$+S$+" + ",I=I-1
6050 GOTO 6020
6060 END_READ:
6070 X=POS("+"=KEY_NAME$,-1),KEY_NAME$=KEY_NAME$(1,X-1)
6080 RETURN 
6090 IOLIST DDF_IOLOBJ$,DDF_NAME$,DDF_DESC$,DDF_TYPE$,DDF_LEN$,DDF_OCC$,DDF_FORMAT$,DDF_VALID$,DDF_PRINT$,DDF_HELP$,DDF_NOTES$,DDF_KEYDEF$,DDF_QUERY$,DDF_CLASS$,DDF_FLAGS$,DDF_DFLT$,DDF_ALT_NAME$
6500 UNLOCK:
6510 FOR AA=1 TO ROW
6520 X'COLUMN=3,X'ROW=AA,X'LOCK=0,X'BACKCOLOR$="White"
6530 NEXT AA
6540 RETURN 
