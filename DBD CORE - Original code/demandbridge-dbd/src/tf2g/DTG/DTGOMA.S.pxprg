0010 REM + Customer Output Control Maintenance  <DTGOMA.P>
0035 REM "5.7 - 05/25/12 - 13.536111 - crg - SSP# 254735
0037 REM "254735-Report Scheduler maintenance panel enhancements     
0040 REM "Copyright 2012 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 REM + Begin Program Notes
0052 REM "This program is called from DTGOMA. It cannont be run
0053 REM "stand alone.
0099 REM + End Program Notes
0100 IF TCB(13)=1 THEN RUN "ZMENU" ELSE EXIT 
0310 IOLIST DT0$
0320 IOLIST AP4$,AP4[0],AP4[1]
0330 IOLIST ARH$,ARH[0]
0340 IOLIST FMP$
0350 IOL_ZZK_S:IOLIST ZZK_KEY_S$,RPT_PGM_NAME$,RPT_DESC$,SCHD_EXP1$,SCHD_EXP2$,SCHD_EXP3$,SCHD_EXP4$,SCHD_EXP5$ ! Scheduling Options
0360 IOL_ZZK_D:IOLIST ZZK_KEY_D$,RPT_OPTIONS_DESC$,RPT_OPTIONS_TYPE$,RPT_OPTIONS_OFFSET$,RPT_OPTIONS_VAR$,RPT_OPTIONS_INITVAL$,RPT_OPTIONS_STEP$,RPT_OPTIONS_INCR$,RPT_OPTIONS_DOMAIN$
0399 ! 
9000 ! 9000 - Retrieve messages from the *msglib.xxx library
9010 SETUP_MESSAGES:
9020 _FYI$=MSG("FYI"),_ERROR$=MSG("ERROR")
9030 _MSG_DIRECTORY$=MSG("DIRECTORY")
9040 _MSG_END_OF_FIL$=MSG("END_OF_FIL")
9050 _MSG_FILOPNERR1$=MSG("FILOPNERR1")
9060 _MSG_JUST_CHECK$=MSG("JUST_CHECK")
9070 _MSG_MANDATORY$=MSG("MANDATORY")
9080 _MSG_NEXT$=MSG("NEXT")
9090 _MSG_NON_NUMER$=MSG("NON_NUMER")
9100 _MSG_NOT_FOUND$=MSG("NOT_FOUND")
9110 _MSG_OVRWRT_CHG$=MSG("OVRWRT_CHG")
9120 _MSG_PRECEDING$=MSG("PRECEDING")
9130 _MSG_PREFIX$=MSG("PREFIX")
9140 _MSG_REC_ACCESS$=MSG("REC_ACCESS")
9150 _MSG_REC_ALTERD$=MSG("REC_ALTERD")
9160 _MSG_REC_CR_NEW$=MSG("REC_CR_NEW")
9170 _MSG_REC_LOCKED$=MSG("REC_LOCKED")
9180 _MSG_X$=MSG("REC_MISS","^"),P=POS("^"=_MSG_X$),_MSG_REC_MISS1$=_MSG_X$(1,P-1),_MSG_REC_MISS2$=_MSG_X$(P+1)
9190 _MSG_REC_NOTFND$=MSG("REC_NOTFND")
9200 _MSG_REC_NO_1ST$=MSG("REC_NO_1ST")
9210 _MSG_REC_NO_LST$=MSG("REC_NO_LST")
9220 _MSG_REC_REMOVE$=MSG("REC_REMOVE")
9230 _MSG_REC_UPDADD$=MSG("REC_UPDADD")
9240 _MSG_X$=MSG("REC_VFYDEL","^"),P=POS("^"=_MSG_X$),_MSG_REC_VFYDEL1$=_MSG_X$(1,P-1),_MSG_REC_VFYDEL2$=_MSG_X$(P+1)
9250 _MSG_X$=MSG("REC_VIEW","^"),P=POS("^"=_MSG_X$),_MSG_REC_VIEW1$=_MSG_X$(1,P-1),_MSG_REC_VIEW2$=_MSG_X$(P+1)
9260 _MSG_REQ_FIELDS$=MSG("REQ_FIELDS")
9270 _MSG_START_FILE$=MSG("START_FILE")
9280 _MSG_UPDATE$=MSG("UPDATE")
9290 _MSG_UPD_OTHER1$=MSG("UPD_OTHER1")
9300 _MSG_UPD_OTHER2$=MSG("UPD_OTHER2")
9310 _MSG_UPD_SAME$=MSG("UPD_SAME")
9320 _MSG_WARNING$=MSG("WARNING")
9330 _MSG_CANNOT_WRITE$=MSG("CANT_WRITE")
9340 _MSG_DUP_UNIQUE$=MSG("DUP_UNIQUE")
9350 RETURN 
9999 END 
10000 ! 
12000 DT0_LOOKUP:
12002 REM "This routine will call a Query window to display all of the
12004 REM "DT0 records for the Output Type
12010 VAR$=""
12015 QRY_USED=0
12020 IF NUL(DT0_QRY$) THEN DT0_QRY$="QRY_DT0_S" END_IF ; PROCESS DT0_QRY$,"../DTG/DT.EN",VAR$ ! 254735
12050 IF NOT(NUL(VAR$)) THEN {
12055 QRY_USED=1
12060 TMP_OUTPUT_TYPE$=VAR$(1,20),RPT_KEY$=PAD(VAR$(21),37)
12105 QRY_USED=0
12110 GOSUB SELECT_REPORT
12120  }
12190 REFRESH_FLG=1
12195 EXIT 
12200 ! 
18800 SELECT_REPORT:
18805 IF NUL(RPT_KEY$) THEN NEXT_ID=RPT_KEY.CTL; REFRESH_FLG=1; GOTO *RETURN
18810 REFRESH_FLG=1
18900 EN_GRID$="Y"
18905 EN_INPUT$="N"
18910 GOSUB ENABLE_GROUPS
18920 DT0_SEG1$=MID(RPT_KEY$,1,2)
18930 DT0_SEG2$=MID(RPT_KEY$,3,20)
18940 DT0_SEG3$=MID(RPT_KEY$,23,10)
18950 DT0_SEG4$=MID(RPT_KEY$,33,5)
18960 PERFORM "UPDDT0;BUILD_GRID"
18965 GOSUB BUILD_SCHD_GRID
18970 EXTRACT (Z[2],KEY=RPT_KEY$(1,31)+"S",DOM=*NEXT)IOL=IOL_ZZK_S
18995 RETURN 
19000 ! 
21000 INIT:
21001 X0$="DTGOMA.S",X1$="Output Control Maintenance"
21002 CALL "ZZCOMP",X0$,X1$,X2$,X3$,X4$,M9$,-1,X1,X2; IF X1>0 THEN GOSUB WRAPUP; GOTO *RETURN
21003 IF X3$(66,1)>"2" THEN PRECISION NUM(X3$(66,1),ERR=*NEXT)
21004 DIM Z[NUM(X3$(60,3))]
21006 SEG2$="",SEG3$="",SEG4$="",SEG5$=""
21010 %NO_X=1
21015 GOSUB CLEAR_FIELDS
21040 CHANGE_FLG=0,_ENABLE_FLG=0,_KCNT=1,_FIRST_KEY=0,_FIRST_FIELD=0
21070 Z$="01X DT0...  02O ZZK...  "
21080 CALL "ZZFLES",X3$,Y1$,Y0$,Z$,Z{ALL},Z0,Z1; IF Z0>0 THEN GOTO OPEN_ERR
21081 DT0=Z[1]
21082 TYPE_DESC$=%TYPE_DESC$; %TYPE_DESC$="",VTYPE$=%VTYPE$; %VTYPE$=""
21085 DTT$=%DTT$; %DTT$=""
21100 CALL "UPDDTT;GET_VAL_OUT_DROP",DTT$,VAL_OUT_DROP$
21110 VAL_OUT_REPT$="PREDEFINED"+"/"
21190 RETURN 
21191 ! 
21200 OPEN_ERR:
21205 MSGBOX _MSG_FILOPNERR1$+QUO+_FILE_NAME$+QUO+SEP+_MSG_DIRECTORY$+LWD+SEP+_MSG_PREFIX$+PFX,MSG(ERR),"!"
21210 CMD_STR$="END"
21290 RETURN 
21300 ! 
22000 MAIN_POST_DISPLAY:
22010 IF NOT(NUL(ARG_1$)) THEN RPT_KEY$=ARG_1$; GOSUB SELECT_REPORT
22020 NEXT_ID=RPT_KEY.CTL
22030 REFRESH_FLG=1
22090 RETURN 
22091 ! 
22100 WRAPUP:
22110 %NO_X=0
22120 CALL "ZZFLES",X3$,Y1$,Y0$,"END",Z{ALL},0,0
22150 IF %FROM_DTGOMA=1 THEN %FROM_DTGOMA=0; REPLACEMENT_SCRN$="DTGOMA"
22160 ARG_2$=SCH_OK$
22190 RETURN 
22200 ! 
22400 SELECT_SAVE:
22405 IF NOT(NUL(RPT_KEY$)) THEN GOSUB SAVE_SCHEDULE; IF SCH_OK$<>"Y" THEN MSGBOX "Scheduling information has not been entered. This report cannot be saved!",MSG("WARNING"),"OK"; RETURN 
22410 IF NUL(ARG_1$) THEN GOSUB SELECT_CLEAR ELSE CMD_STR$="END"
22495 RETURN 
22499 ! 
22500 SELECT_EXIT:
22505 IF NOT(NUL(RPT_KEY$)) THEN GOSUB SAVE_SCHEDULE; IF SCH_OK$<>"Y" THEN MSGBOX "Scheduling information has not been entered. This report will not be scheduled! Continue to exit?",MSG("WARNING"),"OK,CANCEL",OKCANCEL$; IF OKCANCEL$="CANCEL" THEN RETURN ELSE GOSUB DELETE_DT0
22510 GOSUB CLEAR_FIELDS
22570 CMD_STR$="END"
22590 RETURN 
22591 ! 
22600 SELECT_CLEAR:
22605 GOSUB CLEAR_FIELDS
22630 PERFORM "UPDDT0;DELETE_GRID"
22640 EN_INPUT$="Y"; EN_GRID$="N"; GOSUB ENABLE_GROUPS
22650 NEXT_ID=RPT_KEY.CTL,REFRESH_FLG=1
22690 RETURN 
22700 ! 
22800 CLEAR_FIELDS:
22830 ZZK_KEY_S$="",RPT_KEY$="",RPT_DESC$="",RPT_PGM_NAME$="",SCHD_EXP1$="",SCHD_EXP2$="",SCHD_EXP3$="",SCHD_EXP4$="",SCHD_EXP5$=""
22840 GRID LOAD GRID_2.CTL,0,0,""
22895 RETURN 
22899 ! 
22900 SET_DEFAULTS:
22910 GRID_1.CTL'COLUMN=5; GRID_1.CTL'VALUE$="PDF"
22920 GRID_1.CTL'COLUMN=6; GRID_1.CTL'VALUE$="PREDEFINED"
22995 RETURN 
22999 ! 
23000 SAVE_SCHEDULE:
23005 IF NOT(NUL(RPT_KEY$)) AND NUL(SCHD_EXP1$) AND NUL(SCHD_EXP2$) AND NUL(SCHD_EXP3$) AND NUL(SCHD_EXP5$) AND NUL(SCHD_EXP5$) THEN SCH_OK$="N"; RETURN 
23007 GOSUB VALIDATE_SCHEDULE; IF NOT(IS_VALID) THEN SCH_OK$="N"; RETURN 
23008 GRID_1.CTL'ROW=1,GRID_1.CTL'COLUMN=3; IF NUL(GRID_1.CTL'VALUE$) THEN SCH_OK$="N"; GOTO *RETURN
23010 WRITE (Z[2],KEY=RPT_KEY$(1,31)+"S")IOL=IOL_ZZK_S
23020 GRID2_COUNT=GRID_2.CTL'ROWSHIGH
23022 IF GRID2_COUNT<=0 THEN GOTO 23036
23025 FOR D=1 TO GRID2_COUNT
23027 GRID_2.CTL'ROW=D; GRID_2.CTL'COLUMN=5; RPT_D$=GRID_2.CTL'VALUE$
23028 READ (Z[2],KEY=RPT_KEY$(1,31)+RPT_D$,DOM=*CONTINUE)IOL=IOL_ZZK_D
23029 READ DATA FROM GRID_2.CTL'ROWDATA$ TO IOL=GRID_2.CTL'LOADIOLIST$
23031 ZZK_KEY_D$=RPT_KEY$(1,31)+RPT_D$; WRITE (Z[2],KEY=ZZK_KEY_D$)IOL=IOL_ZZK_D
23035 NEXT D
23040 SCH_OK$="Y"
23045 RETURN 
23049 ! 
23099 ! 
23100 BUILD_SCHD_GRID:
23105 GRID LOAD GRID_2.CTL,0,0,""
23106 NUMROWS=0
23110 FOR D=1 TO 9
23120 READ (Z[2],KEY=RPT_KEY$(1,31)+STR(D),DOM=23149)IOL=IOL_ZZK_D
23130 GRID LOAD GRID_2.CTL,1,0,SEP+SEP; GRID_2.CTL'ROW=++NUMROWS
23135 GRID_2.CTL'COLUMN=1,GRID_2.CTL'VALUE$=RPT_OPTIONS_DESC$
23138 GRID_LOCK=0; GRID_2.CTL'COLUMN=4; IF RPT_OPTIONS_INITVAL$=DIM(NUM(RPT_OPTIONS_TYPE$)," ") THEN GRID_2.CTL'VALUE$="FIRST"; GRID_LOCK=1 ELSE IF RPT_OPTIONS_INITVAL$=DIM(NUM(RPT_OPTIONS_TYPE$),"~") THEN GRID_2.CTL'VALUE$="LAST"; GRID_LOCK=1 ELSE IF RPT_OPTIONS_TYPE$="6" THEN GRID_2.CTL'VALUE$=FN%FMT_TFDATE$(RPT_OPTIONS_INITVAL$,"") ELSE GRID_2.CTL'VALUE$=RPT_OPTIONS_INITVAL$
23139 GRID_2.CTL'COLUMN=5,GRID_2.CTL'VALUE$=STR(D)
23145 GRID_2.CTL'COLUMN=2,GRID_2.CTL'VALUE$=RPT_OPTIONS_STEP$,GRID_2.CTL'TEXT$=MSG("SCH_DT_STP"); IF GRID_LOCK THEN GRID_2.CTL'LOCK=1
23146 GRID_2.CTL'COLUMN=3,GRID_2.CTL'VALUE$=RPT_OPTIONS_INCR$; IF GRID_LOCK THEN GRID_2.CTL'LOCK=1
23149 ! 
23150 NEXT D
23190 REFRESH_FLG=1
23195 RETURN 
23199 ! 
23200 DELETE_DT0:
23210 RPT_DT0_PFX$=PAD("SCHEDULED_DBD_RPT",20)+MID(RPT_KEY$,1,31)
23220 READ (Z[1],KEY=RPT_DT0_PFX$,DOM=*NEXT)
23230 RPT_DT0_KEY$=KEY(Z[1],END=23290); READ (Z[1],KEY=RPT_DT0_KEY$)
23240 IF MID(RPT_DT0_KEY$,1,LEN(RPT_DT0_PFX$))=RPT_DT0_PFX$ THEN REMOVE (Z[1],KEY=RPT_DT0_KEY$) ELSE GOTO 23290
23260 GOTO 23230
23295 RETURN 
23299 ! 
23400 DELETE_ZZK:
23410 REMOVE (Z[2],KEY=RPT_KEY$(1,31)+"P",DOM=*NEXT)
23415 REMOVE (Z[2],KEY=RPT_KEY$(1,31)+"O",DOM=*NEXT)
23420 REMOVE (Z[2],KEY=RPT_KEY$(1,31)+"S",DOM=*NEXT)
23430 FOR D=1 TO 9
23440 REMOVE (Z[2],KEY=RPT_KEY$(1,31)+STR(D),DOM=*NEXT)
23445 NEXT D
23450 GOSUB DELETE_DT0
23455 GOSUB SELECT_CLEAR
23495 RETURN 
23499 ! 
24000 VALIDATE_SCHD_EXP1:
24010 IS_VALID=0; EXPR_IN$=SCHD_EXP1$; GOSUB VALIDATE_COMMA_STRING
24015 IF IS_VALID THEN RANGE_START=0,RANGE_END=59; GOSUB VALIDATE_RANGE
24020 IF IS_VALID THEN SCHD_EXP1$=EXPR_IN$ ELSE NEXT_ID=SCHD_EXP1.CTL
24030 REFRESH_FLG=1
24045 RETURN 
24050 ! 
24060 VALIDATE_SCHD_EXP2:
24070 IS_VALID=0; EXPR_IN$=SCHD_EXP2$; GOSUB VALIDATE_COMMA_STRING
24075 IF IS_VALID THEN RANGE_START=0,RANGE_END=23; GOSUB VALIDATE_RANGE
24080 IF IS_VALID THEN SCHD_EXP2$=EXPR_IN$ ELSE NEXT_ID=SCHD_EXP2.CTL
24090 REFRESH_FLG=1
24095 RETURN 
24099 ! 
24100 VALIDATE_SCHD_EXP3:
24110 IS_VALID=0; EXPR_IN$=SCHD_EXP3$; GOSUB VALIDATE_COMMA_STRING
24115 IF IS_VALID THEN RANGE_START=1,RANGE_END=31; GOSUB VALIDATE_RANGE
24120 IF IS_VALID THEN SCHD_EXP3$=EXPR_IN$ ELSE NEXT_ID=SCHD_EXP3.CTL
24130 REFRESH_FLG=1
24145 RETURN 
24149 ! 
24150 VALIDATE_SCHD_EXP4:
24160 IS_VALID=0; EXPR_IN$=SCHD_EXP4$; GOSUB VALIDATE_COMMA_STRING
24165 IF IS_VALID THEN RANGE_START=1,RANGE_END=12; GOSUB VALIDATE_RANGE
24170 IF IS_VALID THEN SCHD_EXP4$=EXPR_IN$ ELSE NEXT_ID=SCHD_EXP4.CTL
24180 REFRESH_FLG=1
24195 RETURN 
24199 ! 
24250 VALIDATE_SCHD_EXP5:
24255 IS_VALID=0; EXPR_IN$=SCHD_EXP5$; GOSUB VALIDATE_COMMA_STRING
24260 IF IS_VALID THEN RANGE_START=0,RANGE_END=6; GOSUB VALIDATE_RANGE
24265 IF IS_VALID THEN SCHD_EXP5$=EXPR_IN$ ELSE NEXT_ID=SCHD_EXP5.CTL
24270 REFRESH_FLG=1
24280 RETURN 
24290 ! 
24300 VALIDATE_COMMA_STRING:
24310 ! Validates EXPR_IN$ for a comma separated list of numbers
24320 IS_VALID=1 ! Assume the string is valid to begin with
24325 IF NUL(EXPR_IN$) OR EXPR_IN$="*" THEN RETURN 
24330 EXPR_IN$=STP(EXPR_IN$,3," ") ! Strip spaces
24340 EXPR_IN$=STP(EXPR_IN$,2,",") ! Strip leading and trailing commas
24350 IF POS(",0123456789"^EXPR_IN$) THEN IS_VALID=0 ! String should only have commas and numbers, anything else is invalid
24360 IF POS(",,"=EXPR_IN$) THEN IS_VALID=0 ! String should not have two successive commas
24370 IF NOT(IS_VALID) THEN MSGBOX MSG("DTG_S_E01"),MSG("WARNING"),"!,OK"
24390 RETURN 
24399 ! 
24400 VALIDATE_RANGE:
24415 ! Numbers in EXPR_IN$ must be between RANGE_START and RANGE_END
24420 RANGE_IN$=EXPR_IN$; IS_VALID=1
24425 VALIDATE_NEXT_NUM:
24430 IF NUL(RANGE_IN$) OR RANGE_IN$="*" THEN GOTO *RETURN
24435 XX=POS(","=RANGE_IN$); IF XX=0 THEN NEXT_RANGE_NUM$=RANGE_IN$,RANGE_IN$="" ELSE NEXT_RANGE_NUM$=MID(RANGE_IN$,1,XX-1),RANGE_IN$=MID(RANGE_IN$,XX+1)
24440 NEXT_RANGE_NUM=NUM(NEXT_RANGE_NUM$,ERR=*NEXT); GOTO CHECK_WITHIN_RANGE
24445 IS_VALID=0; GOTO DONE_VALIDATE_RANGE
24450 CHECK_WITHIN_RANGE:
24455 IF NEXT_RANGE_NUM<RANGE_START OR NEXT_RANGE_NUM>RANGE_END THEN IS_VALID=0; GOTO DONE_VALIDATE_RANGE
24460 GOTO VALIDATE_NEXT_NUM
24485 DONE_VALIDATE_RANGE:
24490 IF NOT(IS_VALID) THEN MSGBOX MSG("DTG_S_E02",STR(RANGE_START),STR(RANGE_END),NEXT_RANGE_NUM$),MSG("WARNING"),"!,OK"
24495 RETURN 
24499 ! 
24900 VALIDATE_SCHEDULE:
24905 GOSUB VALIDATE_SCHD_EXP1; IF NOT(IS_VALID) THEN RETURN 
24910 GOSUB VALIDATE_SCHD_EXP2; IF NOT(IS_VALID) THEN RETURN 
24915 GOSUB VALIDATE_SCHD_EXP3; IF NOT(IS_VALID) THEN RETURN 
24920 GOSUB VALIDATE_SCHD_EXP4; IF NOT(IS_VALID) THEN RETURN 
24925 GOSUB VALIDATE_SCHD_EXP5; IF NOT(IS_VALID) THEN RETURN 
24995 RETURN 
24999 ! 
30000 ! First Record
30010 FIRST_REC:
30020 NAV_KEY$=KEF(Z[2],END=NO_FIRST)
30040 GOSUB NAV_LOAD_INFO
30090 RETURN 
30200 ! Last Record
30210 LAST_REC:
30220 NAV_KEY$=KEL(Z[2],ERR=NO_LAST)
30240 GOSUB NAV_LOAD_INFO
30290 RETURN 
30400 ! Prior Record
30410 PRIOR_REC:
30420 NAV_KEY$=""; NAV_KEY$=KEC(Z[2],ERR=*PROCEED); IF NOT(NUL(NAV_KEY$)) THEN READ (Z[2],KEY=MID(NAV_KEY$,1,30)+$00$,DOM=*NEXT)
30430 NAV_KEY$=KEP(Z[2],END=START_FILE)
30440 GOSUB NAV_LOAD_INFO
30490 RETURN 
30600 ! Next Record
30610 NEXT_REC:
30620 NAV_KEY$=""; NAV_KEY$=KEC(Z[2],ERR=*PROCEED); IF NOT(NUL(NAV_KEY$)) THEN READ (Z[2],KEY=MID(NAV_KEY$,1,30)+$FF$,DOM=*NEXT)
30630 NAV_KEY$=KEY(Z[2],END=END_FILE)
30640 GOSUB NAV_LOAD_INFO
30690 RETURN 
30900 ! Load navigate info
30905 NAV_LOAD_INFO:
30910 GOSUB SELECT_CLEAR
30920 TMP_OUTPUT_TYPE$=PAD("SCHEDULED_DBD_RPT",20),RPT_KEY$=PAD(NAV_KEY$(1,31),37)
30930 GOSUB SELECT_REPORT
30945 RETURN 
30949 ! 
30960 NO_FIRST: MSGBOX MSG("REC_NO_1ST"),"FYI","!"; RETURN 
30965 NO_LAST: MSGBOX MSG("REC_NO_LST"),"FYI","!"; RETURN 
30970 START_FILE: MSGBOX MSG("START_FILE"),"FYI","!"; RETURN 
30975 END_FILE: MSGBOX MSG("END_OF_FIL"),"FYI","!"; RETURN 
55000 ENABLE_GROUPS:
55020 IF EN_INPUT$="Y" THEN CALL "*wingrp;enable",INPUT_FIELDS.GRP$; EN_INPUT$=""
55030 IF EN_INPUT$="N" THEN CALL "*wingrp;disable",INPUT_FIELDS.GRP$; EN_INPUT$=""
55060 IF EN_GRID$="Y" THEN CALL "*wingrp;enable",GRID.GRP$; EN_GRID$=""
55070 IF EN_GRID$="N" THEN CALL "*wingrp;disable",GRID.GRP$; EN_GRID$=""
55290 RETURN 
56000 REM + Modification History
56001 REM "240570-GUI Printing - Support for queueing and scheduling reports. 
56002 REM "254735-Report Scheduler maintenance panel enhancements     
